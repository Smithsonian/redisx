.TH "src/redisx-client.c" 3 "Version v0.9" "RedisX" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/redisx-client.c
.SH SYNOPSIS
.br
.PP
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBREDIS_SIMPLE_STRING_SIZE\fP   256"
.br
.RI "(bytes) Only store up to this many characters from \fBRedis\fP confirms and errors\&. "
.ti -1c
.RI "#define \fBREDIS_TIMEOUT_SECONDS\fP   3"
.br
.RI "(seconds) Abort with an error if cannot send before this timeout (<=0 for not timeout) "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBredisxAbortBlockAsync\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "\fBRESP\fP * \fBredisxExecBlockAsync\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "\fBRedisClient\fP * \fBredisxGetClient\fP (\fBRedis\fP *redis, enum \fBredisx_channel\fP channel)"
.br
.ti -1c
.RI "\fBRedisClient\fP * \fBredisxGetLockedConnectedClient\fP (\fBRedis\fP *redis, enum \fBredisx_channel\fP channel)"
.br
.ti -1c
.RI "int \fBredisxIgnoreReplyAsync\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "int \fBredisxLockClient\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "int \fBredisxLockConnected\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "\fBRESP\fP * \fBredisxReadReplyAsync\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "int \fBredisxResetClient\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "int \fBredisxSendArrayRequestAsync\fP (\fBRedisClient\fP *cl, char *args[], int lengths[], int n)"
.br
.ti -1c
.RI "int \fBredisxSendRequestAsync\fP (\fBRedisClient\fP *cl, const char *command, const char *arg1, const char *arg2, const char *arg3)"
.br
.ti -1c
.RI "int \fBredisxSkipReplyAsync\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "int \fBredisxStartBlockAsync\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "int \fBredisxUnlockClient\fP (\fBRedisClient\fP *cl)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.PP
\fBDate\fP
.RS 4
Created on Aug 26, 2024 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP
Basic I/O (send/receive) functions for the RedisX library\&. 
.SH "Function Documentation"
.PP 
.SS "int redisxAbortBlockAsync (\fBRedisClient\fP * cl)"
Abort an atomic transaction block\&. It sends \fCDISCARD\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to a \fBRedis\fP client
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful or else an error code from send() (see errno\&.h)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxStartBlockAsync()\fP 
.RE
.PP

.PP
References \fBredisxError()\fP, \fBredisxIgnoreReplyAsync()\fP, \fBTRUE\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "\fBRESP\fP * redisxExecBlockAsync (\fBRedisClient\fP * cl)"
Finish and execute an atomic transaction block\&. It sends \fCEXEC\fP, skips through all \fCOK\fP and \fCQUEUED\fP acknowledgements, and returns the reply to the transaction block itself\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to a \fBRedis\fP client
.RE
.PP
\fBReturns\fP
.RS 4
The array \fBRESP\fP returned by EXEC, or NULL if there was an error\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxStartBlockAsync()\fP 
.PP
\fBredisxAbortBlockAsync()\fP 
.RE
.PP

.PP
References \fBREDIS_NULL\fP, \fBredisxDestroyRESP()\fP, \fBredisxError()\fP, \fBredisxReadReplyAsync()\fP, \fBredisxSkipReplyAsync()\fP, \fBRESP_ARRAY\fP, \fBRESP_ERROR\fP, \fBTRUE\fP, \fBRESP::type\fP, and \fBX_NULL\fP\&.
.SS "\fBRedisClient\fP * redisxGetClient (\fBRedis\fP * redis, enum \fBredisx_channel\fP channel)"
Returns the redis client for a given connection type in a \fBRedis\fP instance\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIchannel\fP REDISX_INTERACTIVE_CHANNEL, REDISX_PIPELINE_CHANNEL, or REDISX_SUBSCRIPTION_CHANNEL
.RE
.PP
\fBReturns\fP
.RS 4
Pointer to the matching \fBRedis\fP client, or NULL if the channel argument is invalid\&. 
.RE
.PP

.PP
References \fBREDISX_CHANNELS\fP\&.
.SS "\fBRedisClient\fP * redisxGetLockedConnectedClient (\fBRedis\fP * redis, enum \fBredisx_channel\fP channel)"
Returns the redis client for a given connection type in a \fBRedis\fP instance, with the exclusive access lock if the client is valid and is connected, or else NULL\&. It is effectively the combination of \fC\fBredisxGetClient()\fP\fP followed by \fC\fBredisxLockConnected()\fP\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIchannel\fP REDISX_INTERACTIVE_CHANNEL, REDISX_PIPELINE_CHANNEL, or REDISX_SUBSCRIPTION_CHANNEL 
.RE
.PP
\fBReturns\fP
.RS 4
The locked client, if it is enabled, or NULL if the redis argument is NULL, the channel is invalid, or the requested client is not currently connected\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxGetClient()\fP 
.PP
\fBredisxUnlockClient()\fP 
.PP
\fBredisxLockConnected()\fP 
.RE
.PP

.PP
References \fBredisxGetClient()\fP, \fBredisxLockConnected()\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxIgnoreReplyAsync (\fBRedisClient\fP * cl)"
Silently consumes a reply from the specified \fBRedis\fP channel\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to a \fBRedis\fP channel\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS if a response was successfully consumed, or REDIS_NULL if a valid response could not be obtained\&. 
.RE
.PP

.PP
References \fBREDIS_NULL\fP, \fBredisxDestroyRESP()\fP, \fBredisxError()\fP, \fBredisxReadReplyAsync()\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxLockClient (\fBRedisClient\fP * cl)"
Get exclusive write access to the specified REDIS channel\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to the \fBRedis\fP client instance\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS if the exclusive lock for the channel was successfully obtained X_FAILURE if pthread_mutex_lock() returned an error X_NULL if the client is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxLockConnected()\fP 
.PP
\fBredisxUnlockClient()\fP 
.RE
.PP

.PP
References \fBredisxError()\fP, \fBX_FAILURE\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxLockConnected (\fBRedisClient\fP * cl)"
Lock a channel, but only if it has been enabled for communication\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to the \fBRedis\fP client instance
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if an excusive lock to the channel has been granted\&. X_FAILURE if pthread_mutex_lock() returned an error X_NULL if the client is NULL REDIS_INVALID_CHANNEL if the channel is not enabled/connected\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxLockClient()\fP 
.PP
\fBredisxUnlockClient()\fP 
.PP
\fBredisxGetLockedConnectedClient()\fP 
.RE
.PP

.PP
References \fBREDIS_INVALID_CHANNEL\fP, \fBredisxError()\fP, \fBredisxLockClient()\fP, \fBredisxUnlockClient()\fP, and \fBX_SUCCESS\fP\&.
.SS "\fBRESP\fP * redisxReadReplyAsync (\fBRedisClient\fP * cl)"
Reads a response from \fBRedis\fP and returns it\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to a \fBRedis\fP channel
.RE
.PP
\fBReturns\fP
.RS 4
The \fBRESP\fP structure for the reponse received from \fBRedis\fP, or NULL if an error was encountered (errno will be set to describe the error, which may either be an errno produced by recv() or EBADMSG if the message was corrupted and/or unparseable\&. 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRESP::n\fP, \fBREDIS_INCOMPLETE_TRANSFER\fP, \fBREDIS_SIMPLE_STRING_SIZE\fP, \fBREDIS_UNEXPECTED_RESP\fP, \fBredisxDestroyRESP()\fP, \fBredisxError()\fP, \fBredisxReadReplyAsync()\fP, \fBRESP_ARRAY\fP, \fBRESP_BULK_STRING\fP, \fBRESP_ERROR\fP, \fBRESP_INT\fP, \fBRESP_PONG\fP, \fBRESP_SIMPLE_STRING\fP, \fBRESP::type\fP, \fBRESP::value\fP, \fBX_FAILURE\fP, \fBX_PARSE_ERROR\fP, \fBX_SUCCESS\fP, and \fBxdprintf\fP\&.
.SS "int redisxResetClient (\fBRedisClient\fP * cl)"
Sends a \fCRESET\fP request to the specified \fBRedis\fP client\&. The server will perform a reset as if the client disconnected and reconnected again\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP The \fBRedis\fP client 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else an error code (<0) from \fBredisx\&.h\fP / \fBxchange\&.h\fP\&. 
.RE
.PP

.PP
References \fBREDIS_UNEXPECTED_RESP\fP, \fBredisxCheckRESP()\fP, \fBredisxDestroyRESP()\fP, \fBredisxError()\fP, \fBredisxLockConnected()\fP, \fBredisxReadReplyAsync()\fP, \fBredisxSendRequestAsync()\fP, \fBredisxUnlockClient()\fP, \fBRESP_SIMPLE_STRING\fP, \fBRESP::value\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSendArrayRequestAsync (\fBRedisClient\fP * cl, char * args[], int lengths[], int n)"
Send a \fBRedis\fP request with an arbitrary number of arguments\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to the \fBRedis\fP client\&. 
.br
\fIargs\fP The array of string arguments to send\&. 
.br
\fIlengths\fP Array indicating the number of bytes to send from each string argument\&. Zero or negative values can be used to determine the string length automatically using strlen(), and the length argument itself may be NULL to determine the lengths of all string arguments automatically\&. 
.br
\fIn\fP The number of arguments to send\&.
.RE
.PP
\fBReturns\fP
.RS 4
0 on success or an error code on failure, is either X_NO_SERVICE (if not connected to the REDIS server on the requested channel) or the errno set by send()\&. 
.RE
.PP

.PP
References \fBFALSE\fP, \fBREDISX_CMDBUF_SIZE\fP, \fBredisxError()\fP, \fBTRUE\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSendRequestAsync (\fBRedisClient\fP * cl, const char * command, const char * arg1, const char * arg2, const char * arg3)"
Send a command (with up to 3 arguments) to the REDIS server\&. The caller must have an exclusive lock on the client for this version\&. The arguments supplied will be used up to the first non-NULL value\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to the \fBRedis\fP client instance\&. 
.br
\fIcommand\fP REDIS command string\&. 
.br
\fIarg1\fP Optional first string argument or NULL\&. 
.br
\fIarg2\fP Optional second string argument or NULL\&. 
.br
\fIarg3\fP Optional third string argument or NULL\&.
.RE
.PP
\fBReturns\fP
.RS 4
0 on success or an error code on failure, is either X_NO_SERVICE (if not connected to the REDIS server on the requested channel) or the errno set by send()\&. 
.RE
.PP

.PP
References \fBredisxSendArrayRequestAsync()\fP, \fBX_NAME_INVALID\fP, \fBX_NO_INIT\fP, and \fBX_NULL\fP\&.
.SS "int redisxSkipReplyAsync (\fBRedisClient\fP * cl)"
Instructs \fBRedis\fP to skip sending a reply for the next command\&.
.PP
Sends \fCCLIENT REPLY SKIP\fP
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to the \fBRedis\fP client to use\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) on success or an error code on failure, is either X_NO_SERVICE (if not connected to the REDIS server on the requested channel) or the errno set by send()\&. 
.PP
.nf
X_NULL      if the client is NULL\&.

.fi
.PP
 
.RE
.PP

.PP
References \fBredisxError()\fP, \fBTRUE\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxStartBlockAsync (\fBRedisClient\fP * cl)"
Starts an atomic \fBRedis\fP transaction block, by sending \fCMULTI\fP on the specified client connection\&. \fBRedis\fP transaction blocks behave just like scripts (in fact they are effectively improptu scripts themselves)\&. As such the rules of \fBRedis\fP scripting apply, such as you cannot call LUA from within a transaction block (which is a real pity\&.\&.\&.)
.PP
Once you start a transaction block you may ignore all acknowledgedments such as \fCOK\fP and \fCQUEUED\fP responses that \fBRedis\fP sends back\&. These will be 'processed' in bulk by redisEndBlockAsync(), at the end of the transaction block\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to a \fBRedis\fP client\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or X_NULL if the \fBRedis\fP client is NULL
.RE
.PP
or else the error set by send()\&.
.PP
\fBSee also\fP
.RS 4
\fBredisxExecBlockAsync()\fP 
.PP
\fBredisxAbortBlockAsync()\fP 
.RE
.PP

.PP
References \fBredisxError()\fP, \fBTRUE\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxUnlockClient (\fBRedisClient\fP * cl)"
Relinquish exclusive write access to the specified REDIS channel
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to the \fBRedis\fP client instance
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS if the exclusive lock for the channel was successfully obtained X_FAILURE if pthread_mutex_lock() returned an error X_NULL if the client is NULL
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxLockClient()\fP 
.PP
\fBredisxLockConnected()\fP 
.RE
.PP

.PP
References \fBredisxError()\fP, \fBX_FAILURE\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for RedisX from the source code\&.
