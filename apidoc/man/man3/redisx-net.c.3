.TH "src/redisx-net.c" 3 "Version v1.0" "RedisX" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/redisx-net.c
.SH SYNOPSIS
.br
.PP
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fB_POSIX_C_SOURCE\fP   200112L"
.br
.RI "for getaddrinfo() "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBrCloseClientAsync\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "int \fBrConnectAsync\fP (\fBRedis\fP *redis, \fBboolean\fP usePipeline)"
.br
.ti -1c
.RI "void \fBrDisconnectAsync\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "void * \fBRedisPipelineListener\fP (void *pRedis)"
.br
.ti -1c
.RI "int \fBredisxConnect\fP (\fBRedis\fP *redis, \fBboolean\fP usePipeline)"
.br
.ti -1c
.RI "void \fBredisxDestroy\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "void \fBredisxDisconnect\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "\fBRedis\fP * \fBredisxInit\fP (const char *server)"
.br
.ti -1c
.RI "\fBboolean\fP \fBredisxIsConnected\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "int \fBredisxReconnect\fP (\fBRedis\fP *redis, \fBboolean\fP usePipeline)"
.br
.ti -1c
.RI "int \fBredisxSetHostname\fP (\fBRedis\fP *redis, const char *host)"
.br
.ti -1c
.RI "int \fBredisxSetPort\fP (\fBRedis\fP *redis, int port)"
.br
.ti -1c
.RI "int \fBredisxSetSocketTimeout\fP (\fBRedis\fP *redis, int millis)"
.br
.ti -1c
.RI "int \fBredisxSetTcpBuf\fP (\fBRedis\fP *redis, int size)"
.br
.ti -1c
.RI "int \fBrSetServerAsync\fP (\fBRedis\fP *redis, const char *desc, const char *hostname, int port)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.PP
\fBDate\fP
.RS 4
Created on Aug 26, 2024 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP
Network layer management functions for the RedisX library\&. 
.SH "Function Documentation"
.PP 
.SS "void rCloseClientAsync (\fBRedisClient\fP * cl)"
Closes the \fBRedis\fP client on the specified communication channel\&. This call assumes that the caller has an exlusive lock on the client\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to the \fBRedis\fP client instance\&. 
.RE
.PP

.SS "int rConnectAsync (\fBRedis\fP * redis, \fBboolean\fP usePipeline)"
Same as rConnectClient() but called with the client's mutex already locked\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIusePipeline\fP TRUE (non-zero) if a pipeline client should be connected also, or FALSE to create an interactive connection only\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or X_ALREADY_OPEN if the \fBRedis\fP instance is alreast connected\&. X_NO_SERVICE if there was an error connecting to \fBRedis\fP, or else an error (<0) returned by rConnectClientAsync()\&.
.RE
.PP
\fBSee also\fP
.RS 4
rConnectClient() 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRedis::id\fP, \fBRedis::interactive\fP, \fBRedis::pipeline\fP, \fBREDISX_INTERACTIVE_CHANNEL\fP, \fBREDISX_PIPELINE_CHANNEL\fP, \fBredisxErrorDescription()\fP, \fBredisxIsConnected()\fP, \fBTRUE\fP, \fBX_ALREADY_OPEN\fP, \fBX_NO_SERVICE\fP, \fBX_SUCCESS\fP, \fBx_trace()\fP, \fBx_warn()\fP, and \fBxvprintf\fP\&.
.SS "void rDisconnectAsync (\fBRedis\fP * redis)"
Same as rCloseClient() except without the exlusive locking mechanism of the client's IO\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRedis::interactive\fP, \fBRedis::pipeline\fP, and \fBxvprintf\fP\&.
.SS "void * RedisPipelineListener (void * pRedis)"
The listener function that processes pipelined responses in the background\&. It is started when \fBRedis\fP is connected with the pipeline enabled\&.
.PP
\fBParameters\fP
.RS 4
\fIpRedis\fP Pointer to a \fBRedis\fP instance\&.
.RE
.PP
\fBReturns\fP
.RS 4
Always NULL\&. 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRESP::n\fP, \fBRedis::pipeline\fP, \fBredisxCheckValid()\fP, \fBredisxDestroyRESP()\fP, \fBredisxReadReplyAsync()\fP, \fBRESP_SIMPLE_STRING\fP, \fBRESP::type\fP, \fBX_SUCCESS\fP, \fBx_trace_null()\fP, and \fBxvprintf\fP\&.
.SS "int redisxConnect (\fBRedis\fP * redis, \fBboolean\fP usePipeline)"
Connects to a \fBRedis\fP server\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIusePipeline\fP TRUE (non-zero) if \fBRedis\fP should be connected with a pipeline client also, or FALSE (0) if only the interactive client is needed\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successfully connected to the \fBRedis\fP server\&. X_NO_INIT if library was not initialized via initRedis()\&. X_ALREADY_OPEN if already connected\&. X_NO_SERVICE if the connection failed\&. X_NULL if the redis argument is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxInit()\fP 
.PP
\fBredisxSetPort()\fP 
.PP
\fBredisxSetUser()\fP 
.PP
\fBredisxSetPassword()\fP 
.PP
\fBredisxSetTcpBuf()\fP 
.PP
\fBredisxSelectDB()\fP 
.PP
\fBredisxDisconnect()\fP 
.RE
.PP

.PP
References \fBrConnectAsync()\fP, and \fBX_SUCCESS\fP\&.
.SS "void redisxDestroy (\fBRedis\fP * redis)"
Destroys a \fBRedis\fP intance, disconnecting any clients that may be connected, and freeing all resources used by that \fBRedis\fP instance\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.RE
.PP

.PP
References \fBRedis::id\fP, \fBREDISX_CHANNELS\fP, \fBredisxClearSubscribers()\fP, \fBredisxDestroyRESP()\fP, \fBredisxDisconnect()\fP, and \fBredisxIsConnected()\fP\&.
.SS "void redisxDisconnect (\fBRedis\fP * redis)"
Disconnect all clients from the \fBRedis\fP server\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.RE
.PP

.PP
References \fBrDisconnectAsync()\fP, \fBredisxCheckValid()\fP, and \fBX_SUCCESS\fP\&.
.SS "\fBRedis\fP * redisxInit (const char * server)"
Initializes the \fBRedis\fP client library, and sets the hostname or IP address for the \fBRedis\fP server\&.
.PP
\fBParameters\fP
.RS 4
\fIserver\fP Server host name or numeric IP address, e\&.g\&. '127\&.0\&.0\&.1'\&. The string will be copied, not referenced, for the internal configuration, such that the string passed may be destroyed freely after the call\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS or X_FAILURE if the IP address is invalid\&. X_NULL if the IP address is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxInitSentinel()\fP 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRedis::interactive\fP, \fBRedis::pipeline\fP, \fBREDISX_CHANNELS\fP, \fBREDISX_DEFAULT_TIMEOUT_MILLIS\fP, \fBREDISX_INTERACTIVE_CHANNEL\fP, \fBREDISX_PIPELINE_CHANNEL\fP, \fBREDISX_RESP2\fP, \fBREDISX_SUBSCRIPTION_CHANNEL\fP, \fBREDISX_TCP_BUF_SIZE\fP, \fBrSetServerAsync()\fP, \fBRedis::subscription\fP, \fBTRUE\fP, \fBx_error()\fP, \fBX_SUCCESS\fP, and \fBx_trace_null()\fP\&.
.SS "\fBboolean\fP redisxIsConnected (\fBRedis\fP * redis)"
Checks if a \fBRedis\fP instance is connected\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&.
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) if the \fBRedis\fP instance is connected, or FALSE (0) otherwise\&. 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRedis::interactive\fP, \fBredisxCheckValid()\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxReconnect (\fBRedis\fP * redis, \fBboolean\fP usePipeline)"
Disconnects from \fBRedis\fP, and then connects again\&.\&.\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIusePipeline\fP Whether to reconnect in pipelined mode\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful X_NULL if the \fBRedis\fP instance is NULL
.RE
.PP
or else an error (<0) as would be returned by \fBredisxConnect()\fP\&. 
.PP
References \fBX_SUCCESS\fP\&.
.SS "int redisxSetHostname (\fBRedis\fP * redis, const char * host)"
Changes the host name for the \fBRedis\fP server, prior to calling \fC\fBredisxConnect()\fP\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIhost\fP New host name or IP address to use\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else X_NULL if the redis instance or the host name is NULL, or X_NO_INIT if the redis instance is not initialized, X_ALREADY_OPEN if the redis instance is currently in a connected state, or X_FAILURE if \fBRedis\fP was initialized in Sentinel configuration\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetPort()\fP 
.PP
\fBredisxConnect()\fP 
.RE
.PP

.PP
References \fBredisxIsConnected()\fP, \fBrSetServerAsync()\fP, \fBX_ALREADY_OPEN\fP, \fBx_error()\fP, \fBX_FAILURE\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetPort (\fBRedis\fP * redis, int port)"
Sets a non-standard TCP port number to use for the \fBRedis\fP server, prior to calling \fC\fBredisxConnect()\fP\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIport\fP The TCP port number to use\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else X_NULL if the redis instance is NULL, or X_NO_INIT if the redis instance is not initialized, X_ALREADY_OPEN if the \fBRedis\fP instance is lready connected to a server, or X_FAILURE if \fBRedis\fP was initialized in Sentinel configuration\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetHostname()\fP 
.PP
\fBredisxConnect()\fP 
.RE
.PP

.PP
References \fBredisxIsConnected()\fP, \fBX_ALREADY_OPEN\fP, \fBx_error()\fP, \fBX_FAILURE\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetSocketTimeout (\fBRedis\fP * redis, int millis)"
Sets a socket timeout for future client connections on a \fBRedis\fP instance\&. Effectively this is a timeout for send() only\&. The timeout for interatvice replies is controlled separately via redisxSetReplyTimoeut()\&.
.PP
If not set (or set to zero or a negative value), then the timeout will not be configured for sockets, and the system default timeout values will apply\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP The \fBRedis\fP instance 
.br
\fImillis\fP [ms] The desired socket read/write timeout, or <0 for socket default\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else X_NULL if the redis instance is NULL, or X_NO_INIT if the redis instance is not initialized\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetReplyTimeout()\fP 
.RE
.PP

.PP
References \fBREDISX_DEFAULT_TIMEOUT_MILLIS\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetTcpBuf (\fBRedis\fP * redis, int size)"
Set the size of the TCP/IP buffers (send and receive) for future client connections\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIsize\fP (bytes) requested buffer size, or <= 0 to use default value 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else X_NULL if the redis instance is NULL, or X_NO_INIT if the redis instance is not initialized, or X_FAILURE if \fBRedis\fP was initialized in Sentinel configuration\&. 
.RE
.PP

.PP
References \fBX_SUCCESS\fP\&.
.SS "int rSetServerAsync (\fBRedis\fP * redis, const char * desc, const char * hostname, int port)"
Configures a new server by name or IP address and port number for a given \fBRedis\fP instance
.PP
\fBParameters\fP
.RS 4
\fIredis\fP A \fBRedis\fP instance 
.br
\fIdesc\fP The type of server, e\&.g\&. 'master', 'replica', 'sentinel-18' 
.br
\fIhostname\fP The new host name or IP address 
.br
\fIport\fP The new port number, or &lt=0 to use the default \fBRedis\fP port\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful or else an error code <0\&. 
.RE
.PP

.PP
References \fBRedis::id\fP, \fBREDISX_TCP_PORT\fP, \fBx_error()\fP, \fBX_NAME_INVALID\fP, \fBX_NULL\fP, \fBX_SUCCESS\fP, \fBx_trace()\fP, and \fBxStringCopyOf()\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for RedisX from the source code\&.
