.TH "src/redisx-net.c" 3 "Version v0.9" "RedisX" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/redisx-net.c
.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "void * \fBRedisPipelineListener\fP (void *pRedis)"
.br
.ti -1c
.RI "int \fBredisxConnect\fP (\fBRedis\fP *redis, \fBboolean\fP usePipeline)"
.br
.ti -1c
.RI "void \fBredisxDestroy\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "void \fBredisxDisconnect\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "\fBRedis\fP * \fBredisxInit\fP (const char *server)"
.br
.ti -1c
.RI "\fBRedis\fP * \fBredisxInitSentinel\fP (const char *serviceName, const \fBRedisServer\fP *serverList, int nServers)"
.br
.ti -1c
.RI "\fBboolean\fP \fBredisxIsConnected\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "int \fBredisxReconnect\fP (\fBRedis\fP *redis, \fBboolean\fP usePipeline)"
.br
.ti -1c
.RI "int \fBredisxSetPort\fP (\fBRedis\fP *redis, int port)"
.br
.ti -1c
.RI "int \fBredisxSetSentinelTimeout\fP (\fBRedis\fP *redis, int millis)"
.br
.ti -1c
.RI "int \fBredisxSetSocketTimeout\fP (\fBRedis\fP *redis, int millis)"
.br
.ti -1c
.RI "void \fBredisxSetTcpBuf\fP (int size)"
.br
.ti -1c
.RI "int \fBredisxValidateSentinel\fP (const char *serviceName, const \fBRedisServer\fP *serverList, int nServers)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.PP
\fBDate\fP
.RS 4
Created on Aug 26, 2024 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP
Network layer management functions for the RedisX library\&. 
.SH "Function Documentation"
.PP 
.SS "void * RedisPipelineListener (void * pRedis)"
The listener function that processes pipelined responses in the background\&. It is started when \fBRedis\fP is connected with the pipeline enabled\&.
.PP
\fBParameters\fP
.RS 4
\fIpRedis\fP Pointer to a \fBRedis\fP instance\&.
.RE
.PP
\fBReturns\fP
.RS 4
Always NULL\&. 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRESP::n\fP, \fBRedis::pipeline\fP, \fBredisxCheckValid()\fP, \fBredisxDestroyRESP()\fP, \fBredisxReadReplyAsync()\fP, \fBRESP_SIMPLE_STRING\fP, \fBRESP::type\fP, \fBX_SUCCESS\fP, \fBx_trace_null()\fP, and \fBxvprintf\fP\&.
.SS "int redisxConnect (\fBRedis\fP * redis, \fBboolean\fP usePipeline)"
Connects to a \fBRedis\fP server\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIusePipeline\fP TRUE (non-zero) if \fBRedis\fP should be connected with a pipeline client also, or FALSE (0) if only the interactive client is needed\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successfully connected to the \fBRedis\fP server\&. X_NO_INIT if library was not initialized via initRedis()\&. X_ALREADY_OPEN if already connected\&. X_NO_SERVICE if the connection failed\&. X_NULL if the redis argument is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxInit()\fP 
.PP
\fBredisxSetPort()\fP 
.PP
\fBredisxSetUser()\fP 
.PP
\fBredisxSetPassword()\fP 
.PP
\fBredisxSetTcpBuf()\fP 
.PP
\fBredisxSelectDB()\fP 
.PP
\fBredisxDisconnect()\fP 
.RE
.PP

.PP
References \fBX_SUCCESS\fP\&.
.SS "void redisxDestroy (\fBRedis\fP * redis)"
Destroys a \fBRedis\fP intance, disconnecting any clients that may be connected, and freeing all resources used by that \fBRedis\fP instance\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.RE
.PP

.PP
References \fBRedis::id\fP, \fBREDISX_CHANNELS\fP, \fBredisxClearConnectHooks()\fP, \fBredisxClearSubscribers()\fP, \fBredisxDestroyRESP()\fP, \fBredisxDisconnect()\fP, and \fBredisxIsConnected()\fP\&.
.SS "void redisxDisconnect (\fBRedis\fP * redis)"
Disconnect all clients from the \fBRedis\fP server\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.RE
.PP

.PP
References \fBredisxCheckValid()\fP, and \fBX_SUCCESS\fP\&.
.SS "\fBRedis\fP * redisxInit (const char * server)"
Initializes the \fBRedis\fP client library, and sets the hostname or IP address for the \fBRedis\fP server\&.
.PP
\fBParameters\fP
.RS 4
\fIserver\fP Server host name or numeric IP address, e\&.g\&. '127\&.0\&.0\&.1'\&. The string will be copied, not referenced, for the internal configuration, such that the string passed may be destroyed freely after the call\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS or X_FAILURE if the IP address is invalid\&. X_NULL if the IP address is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxInitSentinel()\fP 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRedis::interactive\fP, \fBRedis::pipeline\fP, \fBREDISX_CHANNELS\fP, \fBREDISX_DEFAULT_TIMEOUT_MILLIS\fP, \fBREDISX_INTERACTIVE_CHANNEL\fP, \fBREDISX_PIPELINE_CHANNEL\fP, \fBREDISX_RESP2\fP, \fBREDISX_SUBSCRIPTION_CHANNEL\fP, \fBRedis::subscription\fP, \fBTRUE\fP, \fBx_error()\fP, and \fBx_trace_null()\fP\&.
.SS "\fBRedis\fP * redisxInitSentinel (const char * serviceName, const \fBRedisServer\fP * serverList, int nServers)"
Initializes a \fBRedis\fP client with a Sentinel configuration of alternate servers, and the default sentinel node connection timeout\&.
.PP
\fBParameters\fP
.RS 4
\fIserviceName\fP The service name as registered in the Sentinel server configuration\&. The supplied name will be copied, not referenced, so that the value passed may be freely destroyed after the call\&. 
.br
\fIserverList\fP An set of Sentinel servers to use to dynamically find the current master\&. The list itself and its contents are not referenced\&. Instead a deep copy will be made of it, so the list that was pased can be freely destroyed after the call\&. 
.br
\fInServers\fP The number of servers in the list 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else an error code <0\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetSentinelTimeout()\fP 
.PP
\fBredisxInit()\fP 
.PP
\fBredisxConnect()\fP 
.RE
.PP

.PP
References \fBREDISX_DEFAULT_SENTINEL_TIMEOUT_MILLIS\fP, \fBredisxInit()\fP, \fBredisxValidateSentinel()\fP, \fBx_error()\fP, \fBX_SUCCESS\fP, \fBx_trace_null()\fP, and \fBxStringCopyOf()\fP\&.
.SS "\fBboolean\fP redisxIsConnected (\fBRedis\fP * redis)"
Checks if a \fBRedis\fP instance is connected\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&.
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) if the \fBRedis\fP instance is connected, or FALSE (0) otherwise\&. 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRedis::interactive\fP, \fBredisxCheckValid()\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxReconnect (\fBRedis\fP * redis, \fBboolean\fP usePipeline)"
Disconnects from \fBRedis\fP, and then connects again\&.\&.\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIusePipeline\fP Whether to reconnect in pipelined mode\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful X_NULL if the \fBRedis\fP instance is NULL
.RE
.PP
or else an error (<0) as would be returned by \fBredisxConnect()\fP\&. 
.PP
References \fBX_SUCCESS\fP\&.
.SS "int redisxSetPort (\fBRedis\fP * redis, int port)"
Sets a non-standard TCP port number to use for the \fBRedis\fP server, prior to calling \fC\fBredisxConnect()\fP\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIport\fP The TCP port number to use\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else X_NULL if the redis instance is NULL, or X_NO_INIT if the redis instance is not initialized, or X_FAILURE if \fBRedis\fP was initialized in Sentinel configuration\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxConnect()\fP; 
.RE
.PP

.PP
References \fBx_error()\fP, \fBX_FAILURE\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetSentinelTimeout (\fBRedis\fP * redis, int millis)"
Changes the connection timeout for Sentinel server instances in the discovery phase\&. This is different from the timeout that is used for the master server, once it is discovered\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP The \fBRedis\fP instance, which was initialized for Sentinel via \fBredisxInitSentinel()\fP\&. 
.br
\fImillis\fP [ms] The new connection timeout or <=0 to use the default value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successfully set sentinel connection timeout, or else X_NULL if the redis instance is NULL, or X_NO_INIT if the redis instance is not initialized for Sentinel\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetSocketTimeout()\fP 
.PP
\fBredisxInitSentinel()\fP 
.RE
.PP

.PP
References \fBREDISX_DEFAULT_SENTINEL_TIMEOUT_MILLIS\fP, \fBx_error()\fP, \fBX_NO_INIT\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetSocketTimeout (\fBRedis\fP * redis, int millis)"
Sets a socket timeout for future client connections on a \fBRedis\fP instance\&. If not set (or set to zero or a negative value), then the timeout will not be configured for sockets, and the system default timeout values will apply\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP The \fBRedis\fP instance 
.br
\fImillis\fP [ms] The desired socket read/write timeout, or <0 for socket default\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else X_NULL if the redis instance is NULL, or X_NO_INIT if the redis instance is not initialized\&. 
.RE
.PP

.PP
References \fBREDISX_DEFAULT_TIMEOUT_MILLIS\fP, and \fBX_SUCCESS\fP\&.
.SS "void redisxSetTcpBuf (int size)"
Set the size of the TCP/IP buffers (send and receive) for future client connections\&.
.PP
\fBParameters\fP
.RS 4
\fIsize\fP (bytes) requested buffer size, or <= 0 to use default value 
.RE
.PP

.PP
References \fBxvprintf\fP\&.
.SS "int redisxValidateSentinel (const char * serviceName, const \fBRedisServer\fP * serverList, int nServers)"
Validates a Sentinel configuration\&.
.PP
\fBParameters\fP
.RS 4
\fIserviceName\fP The service name as registered in the Sentinel server configuration\&. 
.br
\fIserverList\fP An set of Sentinel servers to use to dynamically find the current master\&. 
.br
\fInServers\fP The number of servers in the list 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or X_NAME_INVALID if the serviceName is NULL or empty, or X_NULL if the serverList is NULL, or X_SIZE_INVALID if nServers is 0 or negative, or else X_GROUP_INVALID if the first server has a NULL or empty host name\&. 
.RE
.PP

.PP
References \fBx_error()\fP, \fBX_GROUP_INVALID\fP, \fBX_NAME_INVALID\fP, \fBX_NULL\fP, \fBX_SIZE_INVALID\fP, and \fBX_SUCCESS\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for RedisX from the source code\&.
