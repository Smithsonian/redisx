.TH "include/redisx.h" 3 "Version v1.0" "RedisX" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/redisx.h
.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBRedis\fP"
.br
.RI "Structure that represents a \fBRedis\fP database instance, with one or more \fBRedisClient\fP connections\&. "
.ti -1c
.RI "struct \fBRedisClient\fP"
.br
.RI "Structure that represents a single \fBRedis\fP client connection instance\&. "
.ti -1c
.RI "struct \fBRedisCluster\fP"
.br
.ti -1c
.RI "struct \fBRedisEntry\fP"
.br
.RI "A single key / value entry, or field, in the \fBRedis\fP database\&. "
.ti -1c
.RI "struct \fBRedisMap\fP"
.br
.ti -1c
.RI "struct \fBRedisServer\fP"
.br
.ti -1c
.RI "struct \fBRESP\fP"
.br
.RI "Structure that represents a \fBRedis\fP response (\fBRESP\fP format)\&. "
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBREDIS_ERROR\fP"
.br
.RI "\fBRedis\fP returned an error\&. "
.ti -1c
.RI "#define \fBREDIS_INCOMPLETE_TRANSFER\fP"
.br
.RI "The transfer to/from \fBRedis\fP is incomplete\&. "
.ti -1c
.RI "#define \fBREDIS_INVALID_CHANNEL\fP"
.br
.RI "There is no such channel in the \fBRedis\fP instance\&. "
.ti -1c
.RI "#define \fBREDIS_MIGRATING\fP"
.br
.RI "The requested key is importing, and you may query with ASKED on the specified node\&. "
.ti -1c
.RI "#define \fBREDIS_MOVED\fP"
.br
.RI "The requested key has moved to another cluster shard\&. "
.ti -1c
.RI "#define \fBREDIS_NULL\fP"
.br
.RI "\fBRedis\fP returned NULL\&. "
.ti -1c
.RI "#define \fBREDIS_UNEXPECTED_ARRAY_SIZE\fP"
.br
.RI "Got a \fBRedis\fP response with different number of elements than expected\&. "
.ti -1c
.RI "#define \fBREDIS_UNEXPECTED_RESP\fP"
.br
.RI "Got a \fBRedis\fP response of a different type than expected\&. "
.ti -1c
.RI "#define \fBREDISX_CHANNELS\fP"
.br
.RI "The number of channels a \fBRedis\fP instance has\&. "
.ti -1c
.RI "#define \fBREDISX_CMDBUF_SIZE\fP   8192"
.br
.RI "(bytes) Size of many internal arrays, and the max\&. send chunk size\&. At least ~16 bytes\&.\&.\&. "
.ti -1c
.RI "#define \fBREDISX_DEFAULT_SENTINEL_TIMEOUT_MILLIS\fP   100"
.br
.RI "[ms] Default socket read/write timeout for \fBRedis\fP clients "
.ti -1c
.RI "#define \fBREDISX_DEFAULT_TIMEOUT_MILLIS\fP   3000"
.br
.RI "[ms] Default socket read/write timeout for \fBRedis\fP clients "
.ti -1c
.RI "#define \fBREDISX_LISTENER_REL_PRIORITY\fP   (0\&.5)"
.br
.ti -1c
.RI "#define \fBREDISX_MAJOR_VERSION\fP   1"
.br
.RI "API major version\&. "
.ti -1c
.RI "#define \fBREDISX_MINOR_VERSION\fP   0"
.br
.RI "API minor version\&. "
.ti -1c
.RI "#define \fBREDISX_PATCHLEVEL\fP   0"
.br
.RI "Integer sub version of the release\&. "
.ti -1c
.RI "#define \fBREDISX_RCVBUF_SIZE\fP   8192"
.br
.RI "(bytes) \fBRedis\fP receive buffer size (at most that much is read from the socket in a single call)\&. "
.ti -1c
.RI "#define \fBREDISX_RELEASE_STRING\fP   '\-rc4'"
.br
.RI "Additional release information in version, e\&.g\&. '-1', or '-rc1'\&. "
.ti -1c
.RI "#define \fBREDISX_SET_LISTENER_PRIORITY\fP   \fBFALSE\fP"
.br
.RI "Whether to explicitly set listener thread priorities\&. "
.ti -1c
.RI "#define \fBREDISX_TCP_BUF_SIZE\fP   0"
.br
.RI "(bytes) Default TCP buffer size (send/recv) for \fBRedis\fP clients\&. Values <= 0 will use system default\&. "
.ti -1c
.RI "#define \fBREDISX_TCP_PORT\fP   6379"
.br
.RI "Default TCP/IP port on which \fBRedis\fP server listens to clients\&. "
.ti -1c
.RI "#define \fBREDISX_VERSION_STRING\fP"
.br
.ti -1c
.RI "#define \fBRESP3_CONTINUED\fP"
.br
.RI "RESP3 dictionary of attributes (metadata) "
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void(* \fBRedisErrorHandler\fP) (\fBRedis\fP *redis, enum \fBredisx_channel\fP channel, const char *op)"
.br
.ti -1c
.RI "typedef void(* \fBRedisPipelineProcessor\fP) (\fBRESP\fP *response)"
.br
.ti -1c
.RI "typedef void(* \fBRedisPushProcessor\fP) (\fBRedisClient\fP *cl, \fBRESP\fP *message, void *ptr)"
.br
.ti -1c
.RI "typedef int(* \fBRedisSocketConfigurator\fP) (int socket, enum \fBredisx_channel\fP channel)"
.br
.ti -1c
.RI "typedef void(* \fBRedisSubscriberCall\fP) (const char *pattern, const char *channel, const char *msg, long length)"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBredisx_channel\fP { \fBREDISX_INTERACTIVE_CHANNEL\fP, \fBREDISX_PIPELINE_CHANNEL\fP, \fBREDISX_SUBSCRIPTION_CHANNEL\fP }"
.br
.ti -1c
.RI "enum \fBredisx_protocol\fP { \fBREDISX_RESP2\fP, \fBREDISX_RESP3\fP }"
.br
.ti -1c
.RI "enum \fBresp_type\fP { \fBRESP_ARRAY\fP, \fBRESP_INT\fP, \fBRESP_SIMPLE_STRING\fP, \fBRESP_ERROR\fP, \fBRESP_BULK_STRING\fP, \fBRESP3_NULL\fP, \fBRESP3_DOUBLE\fP, \fBRESP3_BOOLEAN\fP, \fBRESP3_BLOB_ERROR\fP, \fBRESP3_VERBATIM_STRING\fP, \fBRESP3_BIG_NUMBER\fP, \fBRESP3_MAP\fP, \fBRESP3_SET\fP, \fBRESP3_ATTRIBUTE\fP, \fBRESP3_PUSH\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBredisxAbortBlockAsync\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "int \fBredisxAddConnectHook\fP (\fBRedis\fP *redis, void(*setupCall)(\fBRedis\fP *))"
.br
.ti -1c
.RI "int \fBredisxAddDisconnectHook\fP (\fBRedis\fP *redis, void(*cleanupCall)(\fBRedis\fP *))"
.br
.ti -1c
.RI "int \fBredisxAddSubscriber\fP (\fBRedis\fP *redis, const char *channelStem, \fBRedisSubscriberCall\fP f)"
.br
.ti -1c
.RI "\fBRESP\fP * \fBredisxArrayRequest\fP (\fBRedis\fP *redis, const char **args, const int *length, int n, int *status)"
.br
.ti -1c
.RI "int \fBredisxCheckDestroyRESP\fP (\fBRESP\fP *resp, enum \fBresp_type\fP, int expectedSize)"
.br
.ti -1c
.RI "int \fBredisxCheckRESP\fP (const \fBRESP\fP *resp, enum \fBresp_type\fP expectedType, int expectedSize)"
.br
.ti -1c
.RI "int \fBredisxCheckValid\fP (const \fBRedis\fP *redis)"
.br
.ti -1c
.RI "int \fBredisxClearAttributesAsync\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "void \fBredisxClearConnectHooks\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "void \fBredisxClearDisconnectHooks\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "int \fBredisxClearSubscribers\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "\fBRESP\fP * \fBredisxClusterAskMigrating\fP (\fBRedis\fP *redis, const char **args, const int *lengths, int n, int *status)"
.br
.ti -1c
.RI "int \fBredisxClusterAskMigratingAsync\fP (\fBRedisClient\fP *cl, const char **args, const int *lengths, int n)"
.br
.ti -1c
.RI "int \fBredisxClusterConnect\fP (\fBRedisCluster\fP *cluster)"
.br
.ti -1c
.RI "void \fBredisxClusterDestroy\fP (\fBRedisCluster\fP *cluster)"
.br
.ti -1c
.RI "int \fBredisxClusterDisconnect\fP (\fBRedisCluster\fP *cluster)"
.br
.ti -1c
.RI "\fBRedis\fP * \fBredisxClusterGetRedirection\fP (\fBRedisCluster\fP *cluster, const \fBRESP\fP *redirect, \fBboolean\fP refresh)"
.br
.ti -1c
.RI "\fBRedis\fP * \fBredisxClusterGetShard\fP (\fBRedisCluster\fP *cluster, const char *key)"
.br
.ti -1c
.RI "\fBRedisCluster\fP * \fBredisxClusterInit\fP (\fBRedis\fP *node)"
.br
.ti -1c
.RI "\fBboolean\fP \fBredisxClusterIsMigrating\fP (const \fBRESP\fP *reply)"
.br
.ti -1c
.RI "\fBboolean\fP \fBredisxClusterIsRedirected\fP (const \fBRESP\fP *reply)"
.br
.ti -1c
.RI "\fBboolean\fP \fBredisxClusterMoved\fP (const \fBRESP\fP *reply)"
.br
.ti -1c
.RI "int \fBredisxConnect\fP (\fBRedis\fP *redis, \fBboolean\fP usePipeline)"
.br
.ti -1c
.RI "\fBRESP\fP * \fBredisxCopyOfRESP\fP (const \fBRESP\fP *resp)"
.br
.ti -1c
.RI "void \fBredisxDebugTraffic\fP (\fBboolean\fP value)"
.br
.ti -1c
.RI "void \fBredisxDestroy\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "void \fBredisxDestroyEntries\fP (\fBRedisEntry\fP *entries, int count)"
.br
.ti -1c
.RI "void \fBredisxDestroyKeys\fP (char **keys, int count)"
.br
.ti -1c
.RI "void \fBredisxDestroyRESP\fP (\fBRESP\fP *resp)"
.br
.ti -1c
.RI "void \fBredisxDisconnect\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "int \fBredisxEndSubscription\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "int \fBredisxError\fP (const char *func, int errorCode)"
.br
.ti -1c
.RI "const char * \fBredisxErrorDescription\fP (int code)"
.br
.ti -1c
.RI "\fBRESP\fP * \fBredisxExecBlockAsync\fP (\fBRedisClient\fP *cl, int *pStatus)"
.br
.ti -1c
.RI "\fBRESP\fP * \fBredisxGetAttributes\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "const \fBRESP\fP * \fBredisxGetAttributesAsync\fP (const \fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "int \fBredisxGetAvailable\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "int \fBredisxGetAvailableAsync\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "\fBRedisClient\fP * \fBredisxGetClient\fP (\fBRedis\fP *redis, enum \fBredisx_channel\fP channel)"
.br
.ti -1c
.RI "\fBRESP\fP * \fBredisxGetHelloData\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "\fBXLookupTable\fP * \fBredisxGetInfo\fP (\fBRedis\fP *redis, const char *parameter)"
.br
.ti -1c
.RI "char ** \fBredisxGetKeys\fP (\fBRedis\fP *redis, const char *table, int *n)"
.br
.ti -1c
.RI "\fBRedisMap\fP * \fBredisxGetKeywordEntry\fP (const \fBRESP\fP *map, const char *key)"
.br
.ti -1c
.RI "\fBRedisClient\fP * \fBredisxGetLockedConnectedClient\fP (\fBRedis\fP *redis, enum \fBredisx_channel\fP channel)"
.br
.ti -1c
.RI "\fBRedisMap\fP * \fBredisxGetMapEntry\fP (const \fBRESP\fP *map, const \fBRESP\fP *key)"
.br
.ti -1c
.RI "enum \fBredisx_protocol\fP \fBredisxGetProtocol\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "int \fBredisxGetScanCount\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "char * \fBredisxGetStringValue\fP (\fBRedis\fP *redis, const char *table, const char *key, int *len)"
.br
.ti -1c
.RI "\fBRedisEntry\fP * \fBredisxGetTable\fP (\fBRedis\fP *redis, const char *table, int *n)"
.br
.ti -1c
.RI "int \fBredisxGetTime\fP (\fBRedis\fP *redis, struct timespec *t)"
.br
.ti -1c
.RI "\fBRESP\fP * \fBredisxGetValue\fP (\fBRedis\fP *redis, const char *table, const char *key, int *status)"
.br
.ti -1c
.RI "\fBboolean\fP \fBredisxHasComponents\fP (const \fBRESP\fP *r)"
.br
.ti -1c
.RI "\fBboolean\fP \fBredisxHasPipeline\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "int \fBredisxIgnoreReplyAsync\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "\fBRedis\fP * \fBredisxInit\fP (const char *server)"
.br
.ti -1c
.RI "\fBRedis\fP * \fBredisxInitSentinel\fP (const char *serviceName, const \fBRedisServer\fP *serverList, int nServers)"
.br
.ti -1c
.RI "\fBboolean\fP \fBredisxIsArrayType\fP (const \fBRESP\fP *r)"
.br
.ti -1c
.RI "\fBboolean\fP \fBredisxIsConnected\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "\fBboolean\fP \fBredisxIsEqualRESP\fP (const \fBRESP\fP *a, const \fBRESP\fP *b)"
.br
.ti -1c
.RI "int \fBredisxIsGlobPattern\fP (const char *str)"
.br
.ti -1c
.RI "\fBboolean\fP \fBredisxIsMapType\fP (const \fBRESP\fP *r)"
.br
.ti -1c
.RI "\fBboolean\fP \fBredisxIsScalarType\fP (const \fBRESP\fP *r)"
.br
.ti -1c
.RI "\fBboolean\fP \fBredisxIsStringType\fP (const \fBRESP\fP *r)"
.br
.ti -1c
.RI "\fBboolean\fP \fBredisxIsVerbose\fP ()"
.br
.ti -1c
.RI "int \fBredisxLoadScript\fP (\fBRedis\fP *redis, const char *script, char **sha1)"
.br
.ti -1c
.RI "int \fBredisxLockClient\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "int \fBredisxLockConnected\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "int \fBredisxMultiSet\fP (\fBRedis\fP *redis, const char *table, const \fBRedisEntry\fP *entries, int n, \fBboolean\fP confirm)"
.br
.ti -1c
.RI "int \fBredisxMultiSetAsync\fP (\fBRedisClient\fP *cl, const char *table, const \fBRedisEntry\fP *entries, int n, \fBboolean\fP confirm)"
.br
.ti -1c
.RI "int \fBredisxNotify\fP (\fBRedis\fP *redis, const char *channel, const char *message)"
.br
.ti -1c
.RI "int \fBredisxPing\fP (\fBRedis\fP *redis, const char *message)"
.br
.ti -1c
.RI "void \fBredisxPrintDelimited\fP (const \fBRESP\fP *resp, const char *delim, const char *groupPrefix)"
.br
.ti -1c
.RI "int \fBredisxPrintJSON\fP (const char *name, const \fBRESP\fP *resp)"
.br
.ti -1c
.RI "int \fBredisxPrintRESP\fP (const \fBRESP\fP *resp)"
.br
.ti -1c
.RI "int \fBredisxPublish\fP (\fBRedis\fP *redis, const char *channel, const char *message, int length)"
.br
.ti -1c
.RI "int \fBredisxPublishAsync\fP (\fBRedis\fP *redis, const char *channel, const char *data, int length)"
.br
.ti -1c
.RI "\fBRESP\fP * \fBredisxReadReplyAsync\fP (\fBRedisClient\fP *cl, int *pStatus)"
.br
.ti -1c
.RI "int \fBredisxReconnect\fP (\fBRedis\fP *redis, \fBboolean\fP usePipeline)"
.br
.ti -1c
.RI "int \fBredisxRemoveConnectHook\fP (\fBRedis\fP *redis, void(*setupCall)(\fBRedis\fP *))"
.br
.ti -1c
.RI "int \fBredisxRemoveDisconnectHook\fP (\fBRedis\fP *redis, void(*cleanupCall)(\fBRedis\fP *))"
.br
.ti -1c
.RI "int \fBredisxRemoveSubscribers\fP (\fBRedis\fP *redis, \fBRedisSubscriberCall\fP f)"
.br
.ti -1c
.RI "\fBRESP\fP * \fBredisxRequest\fP (\fBRedis\fP *redis, const char *command, const char *arg1, const char *arg2, const char *arg3, int *status)"
.br
.ti -1c
.RI "char * \fBredisxRESP2JSON\fP (const char *name, const \fBRESP\fP *resp)"
.br
.ti -1c
.RI "\fBXField\fP * \fBredisxRESP2XField\fP (const char *name, const \fBRESP\fP *resp)"
.br
.ti -1c
.RI "\fBRESP\fP * \fBredisxRunScript\fP (\fBRedis\fP *redis, const char *sha1, const char **keys, const char **params, int *status)"
.br
.ti -1c
.RI "char ** \fBredisxScanKeys\fP (\fBRedis\fP *redis, const char *pattern, int *n)"
.br
.ti -1c
.RI "\fBRedisEntry\fP * \fBredisxScanTable\fP (\fBRedis\fP *redis, const char *table, const char *pattern, int *n)"
.br
.ti -1c
.RI "int \fBredisxSelectDB\fP (\fBRedis\fP *redis, int idx)"
.br
.ti -1c
.RI "int \fBredisxSendArrayRequestAsync\fP (\fBRedisClient\fP *cl, const char **args, const int *length, int n)"
.br
.ti -1c
.RI "int \fBredisxSendRequestAsync\fP (\fBRedisClient\fP *cl, const char *command, const char *arg1, const char *arg2, const char *arg3)"
.br
.ti -1c
.RI "int \fBredisxSetDHCipherParams\fP (\fBRedis\fP *redis, const char *dh_params_file)"
.br
.ti -1c
.RI "int \fBredisxSetHostname\fP (\fBRedis\fP *redis, const char *host)"
.br
.ti -1c
.RI "int \fBredisxSetMutualTLS\fP (\fBRedis\fP *redis, const char *cert_file, const char *key_file)"
.br
.ti -1c
.RI "int \fBredisxSetPassword\fP (\fBRedis\fP *redis, const char *passwd)"
.br
.ti -1c
.RI "int \fBredisxSetPipelineConsumer\fP (\fBRedis\fP *redis, \fBRedisPipelineProcessor\fP f)"
.br
.ti -1c
.RI "int \fBredisxSetPort\fP (\fBRedis\fP *redis, int port)"
.br
.ti -1c
.RI "int \fBredisxSetProtocol\fP (\fBRedis\fP *redis, enum \fBredisx_protocol\fP protocol)"
.br
.ti -1c
.RI "int \fBredisxSetPushProcessor\fP (\fBRedis\fP *redis, \fBRedisPushProcessor\fP func, void *arg)"
.br
.ti -1c
.RI "int \fBredisxSetReplyTimeout\fP (\fBRedis\fP *redis, int timeoutMillis)"
.br
.ti -1c
.RI "int \fBredisxSetScanCount\fP (\fBRedis\fP *redis, int count)"
.br
.ti -1c
.RI "int \fBredisxSetSentinelTimeout\fP (\fBRedis\fP *redis, int millis)"
.br
.ti -1c
.RI "int \fBredisxSetSocketConfigurator\fP (\fBRedis\fP *redis, \fBRedisSocketConfigurator\fP func)"
.br
.ti -1c
.RI "int \fBredisxSetSocketErrorHandler\fP (\fBRedis\fP *redis, \fBRedisErrorHandler\fP f)"
.br
.ti -1c
.RI "int \fBredisxSetSocketTimeout\fP (\fBRedis\fP *redis, int millis)"
.br
.ti -1c
.RI "int \fBredisxSetTcpBuf\fP (\fBRedis\fP *redis, int size)"
.br
.ti -1c
.RI "int \fBredisxSetTLS\fP (\fBRedis\fP *redis, const char *ca_path, const char *ca_file)"
.br
.ti -1c
.RI "int \fBredisxSetTLSCiphers\fP (\fBRedis\fP *redis, const char *cipher_list)"
.br
.ti -1c
.RI "int \fBredisxSetTLSCipherSuites\fP (\fBRedis\fP *redis, const char *list)"
.br
.ti -1c
.RI "int \fBredisxSetTLSServerName\fP (\fBRedis\fP *redis, const char *host)"
.br
.ti -1c
.RI "int \fBredisxSetTLSVerify\fP (\fBRedis\fP *redis, \fBboolean\fP value)"
.br
.ti -1c
.RI "int \fBredisxSetUser\fP (\fBRedis\fP *redis, const char *username)"
.br
.ti -1c
.RI "int \fBredisxSetValue\fP (\fBRedis\fP *redis, const char *table, const char *key, const char *value, \fBboolean\fP confirm)"
.br
.ti -1c
.RI "int \fBredisxSetValueAsync\fP (\fBRedisClient\fP *cl, const char *table, const char *key, const char *value, \fBboolean\fP confirm)"
.br
.ti -1c
.RI "void \fBredisxSetVerbose\fP (\fBboolean\fP value)"
.br
.ti -1c
.RI "int \fBredisxSkipReplyAsync\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "int \fBredisxSplitText\fP (\fBRESP\fP *resp, char **text)"
.br
.ti -1c
.RI "int \fBredisxStartBlockAsync\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "int \fBredisxSubscribe\fP (\fBRedis\fP *redis, const char *channel)"
.br
.ti -1c
.RI "int \fBredisxUnlockClient\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "int \fBredisxUnsubscribe\fP (\fBRedis\fP *redis, const char *channel)"
.br
.ti -1c
.RI "int \fBredisxValidateSentinel\fP (const char *serviceName, const \fBRedisServer\fP *serverList, int nServers)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.PP
\fBDate\fP
.RS 4
May 4, 2018 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs 
.RE
.PP
\fBVersion\fP
.RS 4
1\&.0
.RE
.PP
RedisX is a completely free \fBRedis\fP / Valkey client library, available on Github as:
.PP
https://github.com/Smithsonian/redisx 
.SH "Macro Definition Documentation"
.PP 
.SS "#define REDISX_LISTENER_REL_PRIORITY   (0\&.5)"
[0\&.0:1\&.0] Listener priority as fraction of available range You may want to set it quite high to ensure that the receive buffer is promptly cleared\&. 
.SS "#define REDISX_VERSION_STRING"
The version string for this library 
.SH "Typedef Documentation"
.PP 
.SS "typedef void(* RedisErrorHandler) (\fBRedis\fP *redis, enum \fBredisx_channel\fP channel, const char *op)"
User-specified callback function for handling RedisX errors from socket-level read / write calls\&. It's mainly there for the application to perform any cleanup as necessary or to report the error\&. However, it can also interacti with the \fBRedis\fP instance in limited ways\&. The implementation should follow a set of basic rules:
.PP
.PD 0
.IP "\(bu" 2
It should not call synchronized functions on the affected client, including attempts to connect, disconnect, or reconnect the client\&. 
.IP "\(bu" 2
It may call \fCAsync\fP functions for the client (the client is in a locked state when the handler is called)\&. 
.IP "\(bu" 2
It should not attempt to lock or unlock the affected client\&. 
.IP "\(bu" 2
It may use \fCerrno\fP to gather information about the source of the error, and may even change or reset \fCerrno\fP, to change behavior (e\&.g\&. re-setting to \fCEAGAIN\fP or \fCEWOULBLOCK\fP will keep the client connected and the return status of the failed call will become X_TIMEDOUT; or setting it to any other value will disconnect the client and the failed call will return X_NO_SERVICE instead\&.)\&. 
.IP "\(bu" 2
The limitations can by bypassed by placing the error on a queue and let an asynchronous thread take it from there\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to the RedisX instance 
.br
\fIchannel\fP the channel over which the error occurred 
.br
\fIop\fP the name/ID of the operation where the error occurred\&. 
.RE
.PP

.SS "typedef void(* RedisPipelineProcessor) (\fBRESP\fP *response)"
A user-defined function for consuming responses from a \fBRedis\fP pipeline connection\&. The implementation should follow a set of simple rules:
.PP
.PD 0
.IP "\(bu" 2
the implementation should not destroy the \fBRESP\fP data\&. The \fBRESP\fP will be destroyed automatically after the call returns\&. However, the call may retain any data from the \fBRESP\fP itself, provided the data is de-referenced from the \fBRESP\fP before return\&.
.IP "\(bu" 2

.IP "\(bu" 2
The implementation should not block (aside from maybe a quick mutex unlock) and return quickly, so as to not block the client for long periods 
.IP "\(bu" 2
If extensive processing or blocking calls are required to process the message, it is best to simply place a copy of the \fBRESP\fP on a queue and then return quickly, and then process the message asynchronously in a background thread\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIresponse\fP A response received from the pipeline client\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetPipelineConsumer()\fP 
.RE
.PP

.SS "typedef void(* RedisPushProcessor) (\fBRedisClient\fP *cl, \fBRESP\fP *message, void *ptr)"
A user-defined function for consuming push messages from a \fBRedis\fP client\&. The implementation should follow a set of simple rules:
.PP
.PD 0
.IP "\(bu" 2
the implementation should not destroy the \fBRESP\fP data\&. The \fBRESP\fP will be destroyed automatically after the call returns\&. However, the call may retain any data from the \fBRESP\fP itself, provided that such data is de-referenced from the \fBRESP\fP before the return\&.
.IP "\(bu" 2

.IP "\(bu" 2
The implementation should not block (aside from maybe a quick mutex unlock) and return quickly, so as to not block the client for long periods 
.IP "\(bu" 2
If extensive processing or blocking calls are required to process the message, it is best to simply place a copy of the \fBRESP\fP on a queue and then return quickly, and then process the message asynchronously in a background thread\&. 
.IP "\(bu" 2
The client on which the push notification originated will be locked when this function is called, waiting for a response to an earlier query\&. Thus the implementation should not attempt to lock the client again or release the lock\&. It may send asynchronous requests on the client, e\&.g\&. via \fBredisxSendRequestAsync()\fP, but it should not try to read a response (given that the client is blocked for another read operation)\&. If more flexible client access is needed, the implementation should make a copy of the \fBRESP\fP and place it on a queue for asynchronous processing by another thread\&.  
.PP
.PP
\fBParameters\fP
.RS 4
\fIcl\fP The \fBRedis\fP client that sent the push\&. The client is locked for exlusive access when this function is called\&. 
.br
\fImessage\fP The RESP3 message that was pushed by the client 
.br
\fIptr\fP Additional data passed along\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetPushProcessor()\fP 
.RE
.PP

.SS "typedef int(* RedisSocketConfigurator) (int socket, enum \fBredisx_channel\fP channel)"
User callback function allowing additional customization of the client socket before connection\&.
.PP
\fBParameters\fP
.RS 4
\fIsocket\fP The socket descriptor\&. 
.br
\fIchannel\fP REDISX_INTERACTIVE_CHANNEL, REDISX_PIPELINE_CHANNEL, REDISX_SUBSCRIPTION_CHANNEL 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if the socket may be used as is after the return\&. Any other value will indicate that the socket should not be used and that the caller itself should fail with an error\&. 
.RE
.PP

.SS "typedef void(* RedisSubscriberCall) (const char *pattern, const char *channel, const char *msg, long length)"
A type of function that handles \fBRedis\fP PUB/SUB messages\&. These functions should follow a set of basic rules:
.PP
.PD 0
.IP "\(bu" 2
The call should return promptly and never block for significant periors\&. If it has blocking calls or if extended processing is required, the function should simply place a copy of the necessary information on a queue and process queued entries in a separate thread\&. (The call arguments will not persist beyond the scope of the call, so don't attempt to place them directly in a queue\&.)
.PP

.IP "\(bu" 2
The subscriber call should not attempt to modify or free() the strings it is called with\&. The same strings maybe used by other subscribers, and thus modifying their content would produce unpredictable results with those subscribers\&.
.PP

.IP "\(bu" 2
If the call needs to manipulate the supplied string arguments, it should operate on copies (e\&.g\&. obtained via xStringCopy())\&.
.PP

.IP "\(bu" 2
The caller should free up any temporary resources it allocates, including copies of the argument strings, before returning\&. However, it should never call free() on the supplied arguments directly\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIpattern\fP The subscription pattern for which this notification came for or NULL if not a pattern match\&.
.br
\fIchannel\fP The PUB/SUB channel on which the message arrived\&.
.br
\fImsg\fP A pointer to the message content received\&. The message buffer itself is not expected to last beyond the call, so the function f() should make a copy if it for any persistent use\&.
.br
\fIlength\fP The number of bytes in the message\&. Since \fBRedis\fP messages can be binary a '\\0' termination should no be assumed\&. Instead, the length of the message is specified explicitly\&. 
.RE
.PP

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBredisx_channel\fP"
RedisX channel IDs\&. RedisX uses up to three separate connections to the server: (1) an interactive client, in which each query is a full round trip, (2) a pipeline clinet, in which queries are submitted in bulk, and responses arrive asynchronously, and (3) a substription client devoted to PUB/SUB requests and push messages\&. Not all clients are typically initialized at start\&. The interactive channel is always connected; the pipeline client can be selected when connecting to the server; and the subscription client is connected as needed to process PUB/SUB requests\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIREDISX_INTERACTIVE_CHANNEL \fP\fP
\fBRedis\fP channel number for interactive queries\&. 
.TP
\fB\fIREDISX_PIPELINE_CHANNEL \fP\fP
\fBRedis\fP channel number for pipelined transfers\&. 
.TP
\fB\fIREDISX_SUBSCRIPTION_CHANNEL \fP\fP
\fBRedis\fP channel number for PUB/SUB messages\&. 
.SS "enum \fBredisx_protocol\fP"
The \fBRESP\fP protocol to use for a \fBRedis\fP instance\&. \fBRedis\fP originally used RESP2, but later releases added support for RESP3\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIREDISX_RESP2 \fP\fP
RESP2 protocol\&. 
.TP
\fB\fIREDISX_RESP3 \fP\fP
RESP3 protocol (since \fBRedis\fP version 6\&.0\&.0) 
.SS "enum \fBresp_type\fP"
Enumeration of \fBRESP\fP component types\&. These are the first character IDs for the standard \fBRESP\fP interface implemented by \fBRedis\fP\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIRESP_ARRAY \fP\fP
\fBRESP\fP array type\&. 
.TP
\fB\fIRESP_INT \fP\fP
\fBRESP\fP integer type\&. 
.TP
\fB\fIRESP_SIMPLE_STRING \fP\fP
\fBRESP\fP simple string type\&. 
.TP
\fB\fIRESP_ERROR \fP\fP
\fBRESP\fP error message type\&. 
.TP
\fB\fIRESP_BULK_STRING \fP\fP
\fBRESP\fP bulk string type\&. 
.TP
\fB\fIRESP3_NULL \fP\fP
RESP3 null value\&. 
.TP
\fB\fIRESP3_DOUBLE \fP\fP
RESP3 floating-point value\&. 
.TP
\fB\fIRESP3_BOOLEAN \fP\fP
RESP3 boolean value\&. 
.TP
\fB\fIRESP3_BLOB_ERROR \fP\fP
RESP3 blob error\&. 
.TP
\fB\fIRESP3_VERBATIM_STRING \fP\fP
RESP3 verbatim string (with type) 
.TP
\fB\fIRESP3_BIG_NUMBER \fP\fP
RESP3 big integer / decimal\&. 
.TP
\fB\fIRESP3_MAP \fP\fP
RESP3 dictionary of key / value\&. 
.TP
\fB\fIRESP3_SET \fP\fP
RESP3 unordered set of elements\&. 
.TP
\fB\fIRESP3_ATTRIBUTE \fP\fP
RESP3 dictionary of attributes (metadata) 
.TP
\fB\fIRESP3_PUSH \fP\fP
RESP3 dictionary of attributes (metadata) 
.SH "Function Documentation"
.PP 
.SS "int redisxAbortBlockAsync (\fBRedisClient\fP * cl)"
Abort an atomic transaction block\&. It sends \fCDISCARD\fP\&. This function should be called with an exclusive lock on a connected client, and after starting an execution block with \fBredisxStartBlockAsync()\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to a \fBRedis\fP client
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or X_NULL if the client is NULL, or X_NO_SERVICE if not connected ot the client or if send() failed, or X_NO_INIT if the client was not initialized\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxStartBlockAsync()\fP 
.RE
.PP

.PP
References \fBredisxIgnoreReplyAsync()\fP, \fBTRUE\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxAddConnectHook (\fBRedis\fP * redis, void(*)(\fBRedis\fP *) setupCall)"
Adds a connect call hook, provided it is not already part of the setup routine\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIsetupCall\fP User-specified callback routine to be called after the \fBRedis\fP instance has been connected\&. It will be passed a pointer to the \fBRedis\fP instance, which triggered the call by having established connection\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful or else X_NULL if either of the arguments is NULL\&. 
.RE
.PP

.PP
References \fBx_error()\fP, \fBX_NULL\fP, \fBX_SUCCESS\fP, and \fBxvprintf\fP\&.
.SS "int redisxAddDisconnectHook (\fBRedis\fP * redis, void(*)(\fBRedis\fP *) cleanupCall)"
Adds a cleanup call, provided it is not already part of the cleanup routine, for when the specified \fBRedis\fP instance is disconnected\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIcleanupCall\fP User specified function to call when \fBRedis\fP is disconnected\&. It will be passed a pointer to the \fBRedis\fP instance, which triggered the call by having disconnected from the \fBRedis\fP server\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful or else X_NULL if either of the arguments is NULL\&. 
.RE
.PP

.PP
References \fBx_error()\fP, \fBX_NULL\fP, \fBX_SUCCESS\fP, and \fBxvprintf\fP\&.
.SS "int redisxAddSubscriber (\fBRedis\fP * redis, const char * channelStem, \fBRedisSubscriberCall\fP f)"
Add a targeted subscriber processing function to the list of functions that process \fBRedis\fP PUB/SUB responses\&. You will still have to subscribe the relevant PUB/SUB messages from redis separately, using \fBredisxSubscribe()\fP before any messages are delivered to this client\&. If the subscriber with the same callback function and channel stem is already added, this call simply return and will NOT create a duplicate enry\&. However, the same callback may be added multiple times with different channel stems (which pre-filter what messages each of the callbacks may get)\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIchannelStem\fP If NULL, the consumer will receive all \fBRedis\fP messages published to the given channel\&. Otherwise, the consumer will be notified only if the incoming channel begins with the specified stem\&. 
.br
\fIf\fP A function that consumes subscription messages\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxRemoveSubscribers()\fP 
.PP
\fBredisxSubscribe()\fP 
.RE
.PP

.PP
References \fBX_SUCCESS\fP, \fBx_warn()\fP, \fBxStringCopyOf()\fP, and \fBxvprintf\fP\&.
.SS "\fBRESP\fP * redisxArrayRequest (\fBRedis\fP * redis, const char ** args, const int * lengths, int n, int * status)"
Returns the result of the most generic type of \fBRedis\fP request with any number of arguments\&. This is not the highest throughput mode (that would be sending asynchronous pipeline request, and then asynchronously collecting the results such as with \fBredisxSendArrayRequestAsync()\fP / \fBredisxReadReplyAsync()\fP, because it requires separate network roundtrips for each and every request\&. But, it is simple and perfectly good method when one needs to retrieve only a few (<1000) variables per second\&.\&.\&.
.PP
This is the base interactive query, which is used by all sorts of other interactive transactions\&. It handles \fCMOVED\fP and \fCASK\fP redirections for \fBRedis\fP clusters automatically and transparently, so long as the target node is a known member of the cluster from before or immediately after the migration message was received\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIargs\fP An array of strings to send to \fBRedis\fP, corresponding to a single query\&. If you have an \fCchar **\fP array, you may need to cast to \fC(const char **)\fP to avoid compiler warnings\&. 
.br
\fIlengths\fP Array indicating the number of bytes to send from each string argument\&. Zero values can be used to determine the string length automatically using strlen(), and the length argument itself may be NULL to determine the lengths of all string arguments automatically\&. 
.br
\fIn\fP Number of string arguments\&. 
.br
\fIstatus\fP Pointer to the return error status\&. If not NULL, it will be populated with one of: 
.PP
.nf
                 X_SUCCESS       on success\&.
                 X_NO_INIT       if the Redis client library was not initialized via redisxInit()\&.
                 X_NULL          if the argument is NULL or n<1\&.
                 X_TIMEDOUT      if the reading of the response timed out\&.
                 X_NO_SERVICE    if not connected to Redis\&.
                 X_FAILURE       If there was a socket level error\&.

.fi
.PP
.RE
.PP
\fBReturns\fP
.RS 4
A freshly allocated \fBRESP\fP array containing the \fBRedis\fP response, or NULL if no valid response could be obtained\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxRequest()\fP 
.PP
\fBredisxSendArrayRequestAsync()\fP 
.PP
\fBredisxReadReplyAsync()\fP 
.RE
.PP

.PP
References \fBRedis::interactive\fP, \fBredisxArrayRequest()\fP, \fBredisxCheckValid()\fP, \fBredisxClearAttributesAsync()\fP, \fBredisxClusterAskMigrating()\fP, \fBredisxClusterGetRedirection()\fP, \fBredisxClusterIsMigrating()\fP, \fBredisxClusterIsRedirected()\fP, \fBredisxLockConnected()\fP, \fBredisxReadReplyAsync()\fP, \fBredisxSendArrayRequestAsync()\fP, \fBredisxUnlockClient()\fP, \fBx_error()\fP, \fBX_NULL\fP, \fBX_SUCCESS\fP, and \fBx_trace_null()\fP\&.
.SS "int redisxCheckDestroyRESP (\fBRESP\fP * resp, enum \fBresp_type\fP expectedType, int expectedSize)"
Like \fBredisxCheckRESP()\fP, but it also destroys the \fBRESP\fP in case of an error\&.
.PP
\fBParameters\fP
.RS 4
\fIresp\fP Pointer to the \fBRESP\fP structure from \fBRedis\fP\&. 
.br
\fIexpectedType\fP The \fBRESP\fP type expected (e\&.g\&. RESP_ARRAY) or 0 if not checking type\&. 
.br
\fIexpectedSize\fP The expected size of the \fBRESP\fP (array or bytes) or <=0 to skip checking
.RE
.PP
\fBReturns\fP
.RS 4
The return value of \fBredisxCheckRESP()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxCheckRESP()\fP 
.RE
.PP

.PP
References \fBredisxCheckRESP()\fP, and \fBredisxDestroyRESP()\fP\&.
.SS "int redisxCheckRESP (const \fBRESP\fP * resp, enum \fBresp_type\fP expectedType, int expectedSize)"
Checks a \fBRedis\fP \fBRESP\fP for NULL values or unexpected values\&.
.PP
\fBParameters\fP
.RS 4
\fIresp\fP Pointer to the \fBRESP\fP structure from \fBRedis\fP\&. 
.br
\fIexpectedType\fP The \fBRESP\fP type expected (e\&.g\&. RESP_ARRAY) or 0 if not checking type\&. 
.br
\fIexpectedSize\fP The expected size of the \fBRESP\fP (array or bytes) or <=0 to skip checking
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if the \fBRESP\fP passes the tests, or X_NULL if the \fBRESP\fP is NULL (garbled response)\&. REDIS_NULL if \fBRedis\fP returned (nil), REDIS_UNEXPECTED_TYPE if got a reply of a different type than expected REDIS_UNEXPECTED_ARRAY_SIZE if got a reply of different size than expected\&.
.RE
.PP
or the error returned in resp->n\&. 
.PP
References \fBRESP::n\fP, \fBREDIS_MIGRATING\fP, \fBREDIS_MOVED\fP, \fBREDIS_NULL\fP, \fBREDIS_UNEXPECTED_RESP\fP, \fBredisxClusterIsMigrating()\fP, \fBredisxClusterMoved()\fP, \fBRESP3_BOOLEAN\fP, \fBRESP3_NULL\fP, \fBRESP_INT\fP, \fBRESP::type\fP, \fBRESP::value\fP, \fBx_error()\fP, \fBX_FAILURE\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxCheckValid (const \fBRedis\fP * redis)"
Checks that a redis instance is valid\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP The \fBRedis\fP instance 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if the instance is valid, or X_NULL if the argument is NULL (errno = EINVAL), or else X_NO_INIT (errno = ENXIO) if the redis instance is not initialized\&. 
.RE
.PP

.PP
References \fBx_error()\fP, \fBX_NO_INIT\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxClearAttributesAsync (\fBRedisClient\fP * cl)"
Clears the attributes for the specified client\&. The caller should have an exclusive lock on the client's mutex prior to making this call\&.
.PP
Typically a user migh call this function prior to calling \fBredisxReadReplyAsync()\fP on the same client, to ensure that any attributes that are available after the read will be the ones that were sent with the last response from the server\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP The \fBRedis\fP client instance 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else X_NULL if the client is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxGetAttributesAsync()\fP 
.PP
\fBredisxReadReplyAsync()\fP 
.PP
redisxGetLockedConnected() 
.RE
.PP

.PP
References \fBX_SUCCESS\fP\&.
.SS "void redisxClearConnectHooks (\fBRedis\fP * redis)"
Removes all connect hooks, that is no user callbacks will be made when the specified \fBRedis\fP instance is connected\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.RE
.PP

.PP
References \fBX_SUCCESS\fP, and \fBxvprintf\fP\&.
.SS "void redisxClearDisconnectHooks (\fBRedis\fP * redis)"
Removes all disconnect hooks, that is no user-specified callbacks will be made when the specified \fBRedis\fP instance is disconnected\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.RE
.PP

.PP
References \fBX_SUCCESS\fP, and \fBxvprintf\fP\&.
.SS "int redisxClearSubscribers (\fBRedis\fP * redis)"
Stops the custom consumption of PUB/SUB messages from \fBRedis\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or X_NULL if the redis instance is NULL\&. 
.RE
.PP

.PP
References \fBxvprintf\fP\&.
.SS "\fBRESP\fP * redisxClusterAskMigrating (\fBRedis\fP * redis, const char ** args, const int * lengths, int n, int * status)"
Makes a redirected transaction using the ASKING directive to the specific client\&. This should be in response to an -ASK redirection error to obtain a key that is in a slot that is currently migrating\&. The requested \fBRedis\fP command arguments are sent prefixed with the 'ASKING' directive, as per the \fBRedis\fP Cluster specification\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Redirected \fBRedis\fP instance, e\&.g\&. from redisxClusterGetRedirect() 
.br
\fIargs\fP Original command arguments that were redirected 
.br
\fIlengths\fP Original argument byte lengths redirected (or NULL to use strlen() automatically)\&. 
.br
\fIn\fP Original number of arguments\&. 
.br
\fIstatus\fP Pointer to integer in which to return status: X_SUCCESS (0) if successful or else and error code <0\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The response to the \fCASKING\fP query from the redirected server\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxClusterAskMigratingAsync()\fP 
.PP
\fBredisxClusterIsMigrating()\fP 
.PP
redisxClusterGetRedirect() 
.PP
\fBredisxArrayRequest()\fP 
.RE
.PP

.PP
References \fBRedis::interactive\fP, \fBredisxCheckValid()\fP, \fBredisxClearAttributesAsync()\fP, \fBredisxClusterAskMigratingAsync()\fP, \fBredisxLockConnected()\fP, \fBredisxReadReplyAsync()\fP, \fBredisxUnlockClient()\fP, \fBX_SUCCESS\fP, and \fBx_trace_null()\fP\&.
.SS "int redisxClusterAskMigratingAsync (\fBRedisClient\fP * cl, const char ** args, const int * lengths, int n)"
Makes a redirected request using the ASKING directive to the specific client\&. This should be in response to an -ASK redirection error to obtain a key that is in a slot that is currently migrating\&. The requested \fBRedis\fP command arguments are sent prefixed with the 'ASKING' directive, as per the \fBRedis\fP Cluster specification\&.
.PP
This function should be called with exclusive access to the client\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Locked client on a redirected \fBRedis\fP instance, e\&.g\&. from redisxClusterGetRedirect() 
.br
\fIargs\fP Original command arguments that were redirected 
.br
\fIlengths\fP Original argument byte lengths redirected (or NULL to use strlen() automatically)\&. 
.br
\fIn\fP Original number of arguments\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful or else and error code <0\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxClusterAskMigrating()\fP 
.PP
\fBredisxClusterIsMigrating()\fP 
.PP
redisxClusterGetRedirect() 
.PP
\fBredisxArrayRequest()\fP 
.RE
.PP

.PP
References \fBredisxSendArrayRequestAsync()\fP, \fBx_error()\fP, \fBX_FAILURE\fP, \fBX_NO_SERVICE\fP, \fBX_NULL\fP, \fBX_SUCCESS\fP, and \fBxStringCopyOf()\fP\&.
.SS "int redisxClusterConnect (\fBRedisCluster\fP * cluster)"
Connects all shards of a \fBRedis\fP cluster\&. Shards normally get connected on demand\&. Thus, this function is only necessary if the user wants to ensure that all shards are connected before using the cluster\&.
.PP
Note, that if the cluster configuration changes while connected, the automatically reconfigured cluster will not automatically reconnect to the new shards during the reconfiguration\&. However, the new shards will still connect on demand when accessed via redisClusterGetShard()\&.
.PP
\fBParameters\fP
.RS 4
\fIcluster\fP Pointer to a \fBRedis\fP cluster configuration 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else a RedisX error code <0 (errno will also indicate the type of error)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxClusterInit()\fP 
.PP
\fBredisxClusterConnect()\fP 
.PP
\fBredisxClusterGetShard()\fP 
.RE
.PP

.PP
References \fBRedisCluster::priv\fP, \fBredisxConnect()\fP, \fBx_error()\fP, \fBX_NO_INIT\fP, \fBX_NULL\fP, \fBX_SUCCESS\fP, \fBx_trace()\fP, and \fBxvprintf\fP\&.
.SS "void redisxClusterDestroy (\fBRedisCluster\fP * cluster)"
Destroys a \fBRedis\fP cluster configuration, freeing up all resources used, but not before disconnecting from all shards that may be in a connected state\&.
.PP
\fBParameters\fP
.RS 4
\fIcluster\fP Pointer to a \fBRedis\fP cluster configuration\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxClusterInit()\fP 
.RE
.PP

.PP
References \fBRedisCluster::priv\fP, and \fBredisxClusterDisconnect()\fP\&.
.SS "int redisxClusterDisconnect (\fBRedisCluster\fP * cluster)"
Disconnects from all shards of a \fBRedis\fP cluster\&. Note, that a cluster can still be used even after it is disconnected, since each call to \fBredisxClusterGetShard()\fP will automatically reconnect the requested shard as needed\&.
.PP
\fBParameters\fP
.RS 4
\fIcluster\fP Pointer to a \fBRedis\fP cluster configuration 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else a RedisX error code <0 (errno will also indicate the type of error)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxClusterInit()\fP 
.PP
\fBredisxClusterConnect()\fP 
.RE
.PP

.PP
References \fBRedisCluster::priv\fP, \fBredisxDisconnect()\fP, \fBx_error()\fP, \fBX_NO_INIT\fP, \fBX_NULL\fP, \fBX_SUCCESS\fP, and \fBxvprintf\fP\&.
.SS "\fBRedis\fP * redisxClusterGetRedirection (\fBRedisCluster\fP * cluster, const \fBRESP\fP * redirect, \fBboolean\fP refresh)"
Parses a \fC-MOVED\fP or \fC-ASK\fP redirection response from a \fBRedis\fP cluster node, to obtain the shard from which the same keyword that caused the error can now be accessed\&.
.PP
\fBParameters\fP
.RS 4
\fIcluster\fP \fBRedis\fP cluster configuration 
.br
\fIredirect\fP the redirection response sent to a keyword query 
.br
\fIrefresh\fP whether it should refresh the cluster configuration and try again if the redirection target is not found in the current cluster configuration\&. 
.RE
.PP
\fBReturns\fP
.RS 4
the migrated server, from which the keyword should be queried now, or NULL if either pointer argument is NULL or if the \fBRESP\fP is not a redirection response (errno will be set to EINVAL), or if the redirected address is not part of a the cluster configuration (errno set to ENXIO if the cluster is not initialized, or else to EAGAIN)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxClusterMoved()\fP 
.PP
\fBredisxClusterIsMigrating()\fP 
.PP
\fBredisxClusterAskMigrating()\fP 
.RE
.PP

.PP
References \fBredisxClusterIsMigrating()\fP, \fBredisxClusterMoved()\fP, \fBRESP::value\fP, \fBx_error()\fP, \fBX_PARSE_ERROR\fP, and \fBxStringCopyOf()\fP\&.
.SS "\fBRedis\fP * redisxClusterGetShard (\fBRedisCluster\fP * cluster, const char * key)"
Returns the \fBRedis\fP server in a cluster which is to be used for queries relating to the specified \fBRedis\fP keyword\&. In \fBRedis\fP cluster configurations, the database is distributed in a way that each cluster node serves only a subset of the \fBRedis\fP keys\&. Thus, this function allows to identify the node that serves a given key\&. The function supports Redish hashtags according to the specification\&.
.PP
\fBParameters\fP
.RS 4
\fIcluster\fP Pointer to a \fBRedis\fP cluster configuration 
.br
\fIkey\fP The \fBRedis\fP keyword of interest\&. It may use hashtags (i\&.e\&., if the keyword contains a segment enclosed in {} brackets, then the hash will be calculated on the bracketed segment only\&. E\&.g\&. \fC{user:1000}\&.name\fP and \fC{user:1000}\&.address\fP will both return the same hash for \fCuser:1000\fP only\&. NULL and empty keys are allowed and will return the shard for slot 0\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A connected \fBRedis\fP server (cluster shard), which can be used for queries on the given keyword, or NULL if either input pointer is NULL (errno = EINVAL), or the cluster has not been initialized (errno = ENXIO), or if no node could be connected to serve queries for the given key (errno = EAGAIN)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxClusterInit()\fP 
.PP
\fBredisxClusterMoved()\fP 
.RE
.PP

.PP
References \fBRedisCluster::priv\fP, \fBrConnectAsync()\fP, \fBredisxIsConnected()\fP, \fBx_error()\fP, \fBX_NO_INIT\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "\fBRedisCluster\fP * redisxClusterInit (\fBRedis\fP * node)"
Initializes a \fBRedis\fP cluster configuration using a known cluster node\&. The call will connect to the specified node (if not already connected), and will query the cluster configuration from it\&. On return the input node's connection state remains what it was prior to the call\&.
.PP
The caller may try multiple nodes from a list of known cluster nodes, until a valid (non-NULL) configuration is returned\&.
.PP
The returned cluster will inherit configuration from the node, including user authentication, socket configuration, connection / disconnection hooks, and asynchronous processing functions\&. Thus, you may configure the node as usual prior to this call, knowing that the nodes in the cluster will be configured the same way also\&.
.PP
\fBParameters\fP
.RS 4
\fInode\fP A known cluster node (connected or not)\&. It's configuration will be used for all cluster nodes discovered also\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The \fBRedis\fP cluster configuration obtained from the node, or else NULL if there was an error (errno may indicate the type of error)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxClusterGetShard()\fP 
.PP
\fBredisxClusterDestroy()\fP 
.PP
\fBredisxClusterConnect()\fP 
.RE
.PP

.PP
References \fBRedisCluster::priv\fP, \fBredisxClusterDestroy()\fP, \fBredisxHasPipeline()\fP, and \fBx_trace_null()\fP\&.
.SS "\fBboolean\fP redisxClusterIsMigrating (const \fBRESP\fP * reply)"
Checks if the reply is an error indicating that the query is for a slot that is currently migrating to another shard (i\&.e\&., \fCASK\fP redirection)\&. You may need to use an \fCASKING\fP directive, e\&.g\&. via \fBredisxClusterAskMigrating()\fP on the node specified in the message to access the key\&.
.PP
\fBParameters\fP
.RS 4
\fIreply\fP The response obtained from the \fBRedis\fP shard / server\&. 
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) if the reply is an error indicating that the cluster has been reconfigured and the key has moved to another shard, or else FALSE (0)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxClusterMoved()\fP 
.PP
\fBredisxClusterIsRedirected()\fP 
.PP
\fBredisxClusterAskMigrating()\fP 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRESP::n\fP, \fBRESP_ERROR\fP, \fBRESP::type\fP, and \fBRESP::value\fP\&.
.SS "\fBboolean\fP redisxClusterIsRedirected (const \fBRESP\fP * reply)"
Checks if the reply is an error indicating that the query should be redirected to another node (i\&.e\&., \fCMOVED\fP or \fCASK\fP redirection)\&.
.PP
\fBParameters\fP
.RS 4
\fIreply\fP The response obtained from the \fBRedis\fP shard / server\&. 
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) if the reply is an error indicating that the query should be directed to another node, or else FALSE (0)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxClusterMoved()\fP 
.PP
\fBredisxClusterIsMigrating()\fP 
.RE
.PP

.PP
References \fBredisxClusterIsMigrating()\fP, and \fBredisxClusterMoved()\fP\&.
.SS "\fBboolean\fP redisxClusterMoved (const \fBRESP\fP * reply)"
Checks if the reply is an error indicating that the cluster has been reconfigured and the request can no longer be fulfilled on the given shard (i\&.e\&., \fCMOVED\fP redirection)\&. You might want to obtain the new shard using \fBredisxClusterGetShard()\fP again, and re-submit the request to the new shard\&.
.PP
\fBParameters\fP
.RS 4
\fIreply\fP The response obtained from the \fBRedis\fP shard / server\&. 
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) if the reply is an error indicating that the cluster has been reconfigured and the key has moved to another shard, or else FALSE (0)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxClusterIsMigrating()\fP 
.PP
\fBredisxClusterIsRedirected()\fP 
.PP
\fBredisxClusterGetShard()\fP 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRESP::n\fP, \fBRESP_ERROR\fP, \fBRESP::type\fP, and \fBRESP::value\fP\&.
.SS "int redisxConnect (\fBRedis\fP * redis, \fBboolean\fP usePipeline)"
Connects to a \fBRedis\fP server\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIusePipeline\fP TRUE (non-zero) if \fBRedis\fP should be connected with a pipeline client also, or FALSE (0) if only the interactive client is needed\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successfully connected to the \fBRedis\fP server\&. X_NO_INIT if library was not initialized via initRedis()\&. X_ALREADY_OPEN if already connected\&. X_NO_SERVICE if the connection failed\&. X_NULL if the redis argument is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxInit()\fP 
.PP
\fBredisxSetPort()\fP 
.PP
\fBredisxSetUser()\fP 
.PP
\fBredisxSetPassword()\fP 
.PP
\fBredisxSetTcpBuf()\fP 
.PP
\fBredisxSelectDB()\fP 
.PP
\fBredisxDisconnect()\fP 
.RE
.PP

.PP
References \fBrConnectAsync()\fP, and \fBX_SUCCESS\fP\&.
.SS "\fBRESP\fP * redisxCopyOfRESP (const \fBRESP\fP * resp)"
Creates an independent deep copy of the \fBRESP\fP, which shares no references with the original\&.
.PP
\fBParameters\fP
.RS 4
\fIresp\fP The original \fBRESP\fP data structure (it may be NULL)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
A copy of the original, with no shared references\&. 
.RE
.PP

.PP
References \fBRedisMap::key\fP, \fBRESP::n\fP, \fBredisxCopyOfRESP()\fP, \fBRESP3_ATTRIBUTE\fP, \fBRESP3_BIG_NUMBER\fP, \fBRESP3_BLOB_ERROR\fP, \fBRESP3_DOUBLE\fP, \fBRESP3_MAP\fP, \fBRESP3_PUSH\fP, \fBRESP3_SET\fP, \fBRESP3_VERBATIM_STRING\fP, \fBRESP_ARRAY\fP, \fBRESP_BULK_STRING\fP, \fBRESP_ERROR\fP, \fBRESP_SIMPLE_STRING\fP, \fBRESP::type\fP, \fBRESP::value\fP, and \fBRedisMap::value\fP\&.
.SS "void redisxDebugTraffic (\fBboolean\fP value)"
Enable or disable verbose reporting of all \fBRedis\fP bound traffic\&. It may be useful when debugging programs that use the redisx interface\&. Verbose reporting is DISABLED by default\&.
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP TRUE to enable verbose reporting, or FALSE to disable\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetVerbose()\fP 
.RE
.PP

.PP
References \fBFALSE\fP, and \fBTRUE\fP\&.
.SS "void redisxDestroy (\fBRedis\fP * redis)"
Destroys a \fBRedis\fP intance, disconnecting any clients that may be connected, and freeing all resources used by that \fBRedis\fP instance\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.RE
.PP

.PP
References \fBRedis::id\fP, \fBREDISX_CHANNELS\fP, \fBredisxClearSubscribers()\fP, \fBredisxDestroyRESP()\fP, \fBredisxDisconnect()\fP, and \fBredisxIsConnected()\fP\&.
.SS "void redisxDestroyEntries (\fBRedisEntry\fP * entries, int count)"
Destroy a \fBRedisEntry\fP array with dynamically allocate keys/values, such as returned e\&.g\&. by \fBredisxScanTable()\fP\&.
.PP
IMPORTANT:
.PP
You should not use this function to destroy \fBRedisEntry\fP[] arrays, which contain static string references (keys or values)\&. If the table contains only static references you can simply call free() on the table\&. Otherwise, you will have to first free only the dynamically sized string fields within before calling free() on the table itself\&.
.PP
\fBParameters\fP
.RS 4
\fIentries\fP Pointer to the entries array (or single entry data)\&. It may be NULL, in which case this call will return immediately\&. 
.br
\fIcount\fP The number of elements contained in the array
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxScanTable()\fP 
.PP
\fBredisxGetTable()\fP 
.RE
.PP

.PP
References \fBRedisEntry::key\fP, and \fBRedisEntry::value\fP\&.
.SS "void redisxDestroyKeys (char ** keys, int count)"
Destroy an array of keywords (i\&.e\&. an array of string pointers), such as returned e\&.g\&. by \fBredisxScanKeys()\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIkeys\fP An array of string pointers 
.br
\fIcount\fP The number of strings contained in the array\&. It may be NULL\&., in which case this call will return immediately\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxScanKeys()\fP 
.PP
\fBredisxGetKeys()\fP 
.RE
.PP

.SS "void redisxDestroyRESP (\fBRESP\fP * resp)"
Frees up the resources used by a \fBRESP\fP structure that was dynamically allocated\&. The call will segfault if the same \fBRESP\fP is destroyed twice or if the argument is a static allocation\&.
.PP
\fBParameters\fP
.RS 4
\fIresp\fP Pointer to the \fBRESP\fP structure to be destroyed, which may be NULL (no action taken)\&. 
.RE
.PP

.PP
References \fBRedisMap::key\fP, \fBRESP::n\fP, \fBredisxDestroyRESP()\fP, \fBRESP3_ATTRIBUTE\fP, \fBRESP3_MAP\fP, \fBRESP3_PUSH\fP, \fBRESP3_SET\fP, \fBRESP_ARRAY\fP, \fBRESP::type\fP, \fBRESP::value\fP, and \fBRedisMap::value\fP\&.
.SS "void redisxDisconnect (\fBRedis\fP * redis)"
Disconnect all clients from the \fBRedis\fP server\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.RE
.PP

.PP
References \fBrDisconnectAsync()\fP, \fBredisxCheckValid()\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxEndSubscription (\fBRedis\fP * redis)"
Unsubscribes from all channels, stops the subscription listener thread, and closes the subscription client connection\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful or else an error code (<0)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxUnsubscribe()\fP 
.RE
.PP

.PP
References \fBX_SUCCESS\fP\&.
.SS "int redisxError (const char * func, int errorCode)"
Prints a descriptive error message to stderr, and returns the error code\&.
.PP
\fBParameters\fP
.RS 4
\fIfunc\fP A string that describes the function or location where the error occurred\&. 
.br
\fIerrorCode\fP The error code that describes the failure\&.
.RE
.PP
\fBReturns\fP
.RS 4
the error code\&. 
.RE
.PP

.PP
References \fBMAX_DEBUG_ERROR_COUNT\fP, \fBREDIS_INCOMPLETE_TRANSFER\fP, \fBredisxErrorDescription()\fP, and \fBxDebug\fP\&.
.SS "const char * redisxErrorDescription (int code)"
Returns a string description for one of the RM error codes\&.
.PP
\fBParameters\fP
.RS 4
\fIcode\fP One of the error codes defined in 'rm\&.h' or in 'redisrm\&.h' (e\&.g\&. X_NO_PIPELINE)
.RE
.PP
\fBReturns\fP
.RS 4
A constant string with the error description\&. 
.RE
.PP

.PP
References \fBREDIS_ERROR\fP, \fBREDIS_INCOMPLETE_TRANSFER\fP, \fBREDIS_INVALID_CHANNEL\fP, \fBREDIS_NULL\fP, \fBREDIS_UNEXPECTED_ARRAY_SIZE\fP, \fBREDIS_UNEXPECTED_RESP\fP, and \fBxErrorDescription()\fP\&.
.SS "\fBRESP\fP * redisxExecBlockAsync (\fBRedisClient\fP * cl, int * pStatus)"
Finish and execute an atomic transaction block\&. It sends \fCEXEC\fP, skips through all \fCOK\fP and \fCQUEUED\fP acknowledgements, and returns the reply to the transaction block itself\&. This function should be called with an exclusive lock on a connected client\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to a \fBRedis\fP client 
.br
\fIpStatus\fP Pointer to int in which to return error status\&. or NULL if not required\&.
.RE
.PP
\fBReturns\fP
.RS 4
The array \fBRESP\fP returned by EXEC, or NULL if there was an error\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxStartBlockAsync()\fP 
.PP
\fBredisxAbortBlockAsync()\fP 
.PP
redisxGetLockedConnected() 
.RE
.PP

.PP
References \fBredisxDestroyRESP()\fP, \fBredisxReadReplyAsync()\fP, \fBredisxSkipReplyAsync()\fP, \fBRESP_ARRAY\fP, \fBRESP_ERROR\fP, \fBTRUE\fP, \fBRESP::type\fP, \fBx_error()\fP, \fBX_SUCCESS\fP, and \fBx_trace_null()\fP\&.
.SS "\fBRESP\fP * redisxGetAttributes (\fBRedis\fP * redis)"
Returns a copy of the attributes sent along with the last interative request\&. The user should destroy the returned \fBRESP\fP after using it by calling \fBredisxDestroyRESP()\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The attributes (if any) that were sent along with the last response on the interactive client\&.
.RE
.PP
\fBSee also\fP
.RS 4
redisxGetAttributeAsync() 
.PP
\fBredisxRequest()\fP 
.PP
\fBredisxArrayRequest()\fP 
.PP
\fBredisxDestroyRESP()\fP 
.RE
.PP

.PP
References \fBRedis::interactive\fP, \fBredisxCheckValid()\fP, \fBredisxCopyOfRESP()\fP, \fBredisxGetAttributesAsync()\fP, \fBredisxLockConnected()\fP, \fBredisxUnlockClient()\fP, \fBX_SUCCESS\fP, and \fBx_trace_null()\fP\&.
.SS "const \fBRESP\fP * redisxGetAttributesAsync (const \fBRedisClient\fP * cl)"
Returns the attributes (if any) that were last sent along a response to the client\&. This function should be called only if the caller has an exclusive lock on the client's mutex\&. Also, there are a few rules the caller should follow:
.PP
.PD 0
.IP "\(bu" 2
The caller should not block the client for long and return quickly\&. If it has blocking calls, or requires extensive processing, it should make a copy of the \fBRESP\fP first, and release the lock immediately after\&. 
.IP "\(bu" 2
The caller must not attempt to call free() on the returned \fBRESP\fP 
.PP
.PP
Normally the user would typically call this function right after a \fBredisxReadReplyAsync()\fP call, for which atributes are expected\&. The caller might also want to call redisxClearAttributeAsync() before attempting to read the response to ensure that the attributes returned are for the same reply from the server\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP The \fBRedis\fP client instance 
.RE
.PP
\fBReturns\fP
.RS 4
The attributes last received (possibly NULL)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxGetAttributes()\fP 
.PP
\fBredisxClearAttributesAsync()\fP 
.PP
\fBredisxReadReplyAsync()\fP 
.PP
redisxGetLockedConnected() 
.RE
.PP

.PP
References \fBx_error()\fP\&.
.SS "int redisxGetAvailable (\fBRedisClient\fP * cl)"
Returns the number of bytes of response available on the given \fBRedis\fP client connection\&. This is the synchronized version, which will obtain a exclusive lock on the client before determining the result\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP a locked and connected \fBRedis\fP client 
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes of response available on the client, or else an error code <0\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxGetAvailableAsync()\fP 
.RE
.PP

.PP
References \fBredisxGetAvailable()\fP, \fBredisxLockConnected()\fP, and \fBredisxUnlockClient()\fP\&.
.SS "int redisxGetAvailableAsync (\fBRedisClient\fP * cl)"
Returns the number of bytes of response available on the given \fBRedis\fP client connection\&. This version assumes the caller has exclusive access to the client\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP a locked and connected \fBRedis\fP client 
.RE
.PP
\fBReturns\fP
.RS 4
the number of bytes of response available on the client, or else an error code <0\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxGetAvailable()\fP 
.PP
redisxGetLockConnected() 
.PP
\fBredisxReadReplyAsync()\fP 
.RE
.PP

.PP
References \fBx_error()\fP, and \fBX_FAILURE\fP\&.
.SS "\fBRedisClient\fP * redisxGetClient (\fBRedis\fP * redis, enum \fBredisx_channel\fP channel)"
Returns the redis client for a given connection type in a \fBRedis\fP instance\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIchannel\fP REDISX_INTERACTIVE_CHANNEL, REDISX_PIPELINE_CHANNEL, or REDISX_SUBSCRIPTION_CHANNEL
.RE
.PP
\fBReturns\fP
.RS 4
Pointer to the matching \fBRedis\fP client, or NULL if redis is null (EINVAL) or not initialized (EAGAIN) or if the channel argument is invalid (ECHRNG)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxGetLockedConnectedClient()\fP 
.RE
.PP

.PP
References \fBREDISX_CHANNELS\fP, \fBredisxCheckValid()\fP, \fBx_error()\fP, \fBX_SUCCESS\fP, and \fBx_trace_null()\fP\&.
.SS "\fBRESP\fP * redisxGetHelloData (\fBRedis\fP * redis)"
Returns a copy of the \fBRESP\fP map that the \fBRedis\fP server has sent us as a response to HELLO on the last client connection, or NULL if HELLO was not used or available\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP The redis instance 
.RE
.PP
\fBReturns\fP
.RS 4
A copy of the response sent by HELLO on the last client connection, or NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetProtocol()\fP 
.PP
\fBredisxGetInfo()\fP 
.RE
.PP

.PP
References \fBredisxCopyOfRESP()\fP, and \fBx_trace_null()\fP\&.
.SS "\fBXLookupTable\fP * redisxGetInfo (\fBRedis\fP * redis, const char * parameter)"
Returns the result of an INFO query (with the optional parameter) as a lookup table of keywords and string values\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to \fBRedis\fP instance 
.br
\fIparameter\fP Optional parameter to pass with INFO, or NULL\&. 
.RE
.PP
\fBReturns\fP
.RS 4
a newly created lookup table with the string key/value pairs of the response from the \fBRedis\fP server, or NULL if there was an error\&. The caller should destroy the lookup table after using it\&.
.RE
.PP
\fBSee also\fP
.RS 4
redisxGetInfoAsync() 
.PP
\fBredisxGetHelloData()\fP 
.RE
.PP

.PP
References \fBrConsumeInfoReply()\fP, \fBredisxRequest()\fP, \fBX_SUCCESS\fP, and \fBx_trace_null()\fP\&.
.SS "char ** redisxGetKeys (\fBRedis\fP * redis, const char * table, int * n)"
Returns all the key names stored in a given hash table
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fItable\fP The hashtable from which to retrieve a value or NULL if to use the global table\&. 
.br
\fIn\fP Pointer to the integer in which the number of elements or an error (<0) is returned\&. It may return an error value from \fBredisxRequest()\fP, or:
.RE
.PP
REDIS_NULL If got a null or empty response from \fBRedis\fP UNEXPECTED_RESP If the response from \fBRedis\fP was not the expected array type
.PP
\fBReturns\fP
.RS 4
An array with pointers to key names from this table or NULL if there was an error (see parameter n for an error status from \fBredisx\&.h\fP / \fBxchange\&.h\fP)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxScanKeys()\fP 
.PP
\fBredisxDestroyKeys()\fP 
.RE
.PP

.PP
References \fBRESP::n\fP, \fBredisxCheckDestroyRESP()\fP, \fBredisxDestroyRESP()\fP, \fBredisxRequest()\fP, \fBRESP_ARRAY\fP, \fBRESP::value\fP, \fBx_error()\fP, \fBX_NULL\fP, and \fBx_trace_null()\fP\&.
.SS "\fBRedisMap\fP * redisxGetKeywordEntry (const \fBRESP\fP * map, const char * key)"
Retrieves a entry, by its string keyword, from a map-type \fBRESP\fP data structure\&.
.PP
\fBParameters\fP
.RS 4
\fImap\fP The map-type REST data structure containing a dictionary 
.br
\fIkey\fP The string keyword to match 
.RE
.PP
\fBReturns\fP
.RS 4
The matching map entry or NULL if the map contains no such entry\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBRESP3_MAP\fP 
.PP
\fBRESP3_ATTRIBUTE\fP
.PP
\fBredisxGetMapEntry()\fP 
.RE
.PP

.PP
References \fBRedisMap::key\fP, \fBRESP::n\fP, \fBredisxIsMapType()\fP, \fBredisxIsStringType()\fP, and \fBRESP::value\fP\&.
.SS "\fBRedisClient\fP * redisxGetLockedConnectedClient (\fBRedis\fP * redis, enum \fBredisx_channel\fP channel)"
Returns the redis client for a given connection type in a \fBRedis\fP instance, with the exclusive access lock if the client is valid and is connected, or else NULL\&. It is effectively the combination of \fC\fBredisxGetClient()\fP\fP followed by \fC\fBredisxLockConnected()\fP\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIchannel\fP REDISX_INTERACTIVE_CHANNEL, REDISX_PIPELINE_CHANNEL, or REDISX_SUBSCRIPTION_CHANNEL 
.RE
.PP
\fBReturns\fP
.RS 4
The locked client, if it is enabled, or NULL if the redis argument is NULL, the channel is invalid, or the requested client is not currently connected\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxGetClient()\fP 
.PP
\fBredisxUnlockClient()\fP 
.PP
\fBredisxLockConnected()\fP 
.RE
.PP

.PP
References \fBredisxGetClient()\fP, \fBredisxLockConnected()\fP, \fBX_SUCCESS\fP, and \fBx_trace_null()\fP\&.
.SS "\fBRedisMap\fP * redisxGetMapEntry (const \fBRESP\fP * map, const \fBRESP\fP * key)"
Retrieves a keyed entry from a map-type \fBRESP\fP data structure\&.
.PP
\fBParameters\fP
.RS 4
\fImap\fP The map-type REST data structure containing a dictionary 
.br
\fIkey\fP The \fBRESP\fP key to match 
.RE
.PP
\fBReturns\fP
.RS 4
The matching map entry or NULL if the map contains no such entry\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBRESP3_MAP\fP 
.PP
\fBRESP3_ATTRIBUTE\fP
.PP
\fBredisxGetKeywordEntry()\fP 
.RE
.PP

.PP
References \fBRedisMap::key\fP, \fBRESP::n\fP, \fBredisxIsMapType()\fP, \fBRESP::type\fP, and \fBRESP::value\fP\&.
.SS "enum \fBredisx_protocol\fP redisxGetProtocol (\fBRedis\fP * redis)"
Returns the actual protocol used with the \fBRedis\fP server\&. If HELLO was used during connection it will be the protocol that was confirmed in the response of HELLO (and which hopefully matches the protocol requested)\&. Otherwise, RedisX will default to RESP2\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP The \fBRedis\fP server instance 
.RE
.PP
\fBReturns\fP
.RS 4
REDISX_RESP2 or REDISX_RESP3, or else an error code, such as X_NULL (errno = EINVAL) if the argument is NULL, or X_NO_INIT (errno = ENXIO) if the \fBRedis\fP server instance was not initialized\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetProtocol()\fP 
.RE
.PP

.SS "int redisxGetScanCount (\fBRedis\fP * redis)"
Returns the COUNT parameter currently set to be used with \fBRedis\fP SCAN-type commands
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The current COUNT to use for SCAN-type commands, or <0 in case of an error\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxGetScanCount()\fP 
.PP
\fBredisxScanKeys()\fP 
.PP
\fBredisxScanTable()\fP 
.RE
.PP

.SS "char * redisxGetStringValue (\fBRedis\fP * redis, const char * table, const char * key, int * len)"
Retrieve a variable from \fBRedis\fP as a string (or byte array), through the interactive connection\&. This is not the highest throughput mode (that would be sending asynchronous pipeline request, and then asynchronously collecting the results such as with \fBredisxSendRequestAsync()\fP / \fBredisxReadReplyAsync()\fP), because it requires separate network roundtrips for each and every request\&. But, it is simple and perfectly good method when one needs to retrieve only a few (<1000) variables per second\&.\&.\&.
.PP
The call effectively implements a \fBRedis\fP GET (if the table argument is NULL) or HGET call\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fItable\fP Hashtable from which to retrieve a value or NULL if to use the global table\&. 
.br
\fIkey\fP Field name (i\&.e\&. variable name)\&. 
.br
\fIlen\fP (optional) pointer in which to return the length (>=0) of the value or else an error code (<0) defined in \fBxchange\&.h\fP / \fBredisx\&.h\fP
.RE
.PP
\fBReturns\fP
.RS 4
A freshly allocated \fBRESP\fP array containing the \fBRedis\fP response, or NULL if no valid response could be obtained\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxGetValue()\fP 
.RE
.PP

.PP
References \fBRESP::n\fP, \fBredisxCheckRESP()\fP, \fBredisxDestroyRESP()\fP, \fBredisxGetValue()\fP, \fBRESP_BULK_STRING\fP, \fBRESP::value\fP, \fBX_SUCCESS\fP, and \fBx_trace_null()\fP\&.
.SS "\fBRedisEntry\fP * redisxGetTable (\fBRedis\fP * redis, const char * table, int * n)"
Returns all the key/value pairs stored in a given hash table
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fItable\fP Hashtable from which to retrieve a value or NULL if to use the global table\&. 
.br
\fIn\fP Pointer to the integer in which the number of elements or an error (<0) is returned\&. It may return an error value from \fBredisxRequest()\fP, or:
.RE
.PP
REDIS_NULL If got a null or empty response from \fBRedis\fP UNEXPECTED_RESP If the response from \fBRedis\fP was not the expected array type
.PP
\fBReturns\fP
.RS 4
A table of all entries (key/value pairs) from this table or NULL if there was an error (see parameter n)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxScanTable()\fP 
.PP
redisxDEstroyEntries() 
.RE
.PP

.PP
References \fBRedisMap::key\fP, \fBRedisEntry::key\fP, \fBRESP::n\fP, \fBredisxCheckDestroyRESP()\fP, \fBredisxDestroyRESP()\fP, \fBredisxRequest()\fP, \fBRESP3_MAP\fP, \fBRESP_ARRAY\fP, \fBRESP::type\fP, \fBRESP::value\fP, \fBRedisMap::value\fP, \fBRedisEntry::value\fP, \fBx_error()\fP, \fBX_GROUP_INVALID\fP, and \fBx_trace_null()\fP\&.
.SS "int redisxGetTime (\fBRedis\fP * redis, struct timespec * t)"
Returns the current time on the \fBRedis\fP server instance\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIt\fP Pointer to a timespec structure in which to return the server time\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or X_NULL if either argument is NULL, or X_PARSE_ERROR if could not parse the response, or another error returned by \fBredisxCheckRESP()\fP\&. 
.RE
.PP

.PP
References \fBredisxCheckDestroyRESP()\fP, \fBredisxCheckRESP()\fP, \fBredisxDestroyRESP()\fP, \fBredisxRequest()\fP, \fBRESP_ARRAY\fP, \fBRESP_BULK_STRING\fP, \fBRESP::value\fP, \fBx_error()\fP, \fBX_NULL\fP, \fBX_PARSE_ERROR\fP, \fBX_SUCCESS\fP, and \fBx_trace()\fP\&.
.SS "\fBRESP\fP * redisxGetValue (\fBRedis\fP * redis, const char * table, const char * key, int * status)"
Retrieve a variable from \fBRedis\fP (as an undigested \fBRESP\fP), through the interactive connection\&. This is not the highest throughput mode (that would be sending asynchronous pipeline request, and then asynchronously collecting the results such as with \fBredisxSendRequestAsync()\fP / \fBredisxReadReplyAsync()\fP), because it requires separate network roundtrips for each and every request\&. But, it is simple and perfectly good method when one needs to retrieve only a few (<1000) variables per second\&.\&.\&.
.PP
The call effectively implements a \fBRedis\fP GET (if the table argument is NULL) or HGET call\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fItable\fP Hashtable from which to retrieve a value or NULL if to use the global table\&. 
.br
\fIkey\fP Field name (i\&.e\&. variable name)\&. 
.br
\fIstatus\fP (optional) pointer to the return error status, which is either X_SUCCESS on success or else the error code set by \fBredisxArrayRequest()\fP\&. It may be NULL if not required\&.
.RE
.PP
\fBReturns\fP
.RS 4
A freshly allocated \fBRESP\fP containing the \fBRedis\fP response, or NULL if no valid response could be obtained\&. Values are returned as RESP_BULK_STRING (count = 1), or else type RESP_ERROR or RESP_NULL if \fBRedis\fP responded with an error or null, respectively\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxGetStringValue()\fP 
.RE
.PP

.PP
References \fBredisxRequest()\fP, \fBx_error()\fP, \fBX_GROUP_INVALID\fP, \fBX_NAME_INVALID\fP, \fBX_SUCCESS\fP, and \fBx_trace_null()\fP\&.
.SS "\fBboolean\fP redisxHasComponents (const \fBRESP\fP * r)"
Checks if a \fBRESP\fP has subcomponents, such as arrays or maps (dictionaries)\&.
.PP
\fBParameters\fP
.RS 4
\fIr\fP Pointer to a \fBRESP\fP data structure 
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) if the data has sub-components, or else FALSE (0)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxIsArrayType()\fP 
.PP
\fBredisxIsMapType()\fP 
.PP
\fBRESP3_MAP\fP 
.PP
\fBRESP3_ATTRIBUTE\fP 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRESP::n\fP, \fBredisxIsArrayType()\fP, and \fBredisxIsMapType()\fP\&.
.SS "\fBboolean\fP redisxHasPipeline (\fBRedis\fP * redis)"
Checks if a \fBRedis\fP instance has the pipeline connection enabled\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&.
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) if the pipeline client is enabled on the \fBRedis\fP intance, or FALSE (0) otherwise\&. 
.RE
.PP

.PP
References \fBRedis::pipeline\fP, \fBredisxCheckValid()\fP, \fBredisxLockClient()\fP, and \fBredisxUnlockClient()\fP\&.
.SS "int redisxIgnoreReplyAsync (\fBRedisClient\fP * cl)"
Silently consumes a reply from the specified \fBRedis\fP channel\&. This function should be called with an exclusive lock on a connected client\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to a \fBRedis\fP channel\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS if a response was successfully consumed, or REDIS_NULL if a valid response could not be obtained\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxReadReplyAsync()\fP 
.PP
redisxGetLockedConnected() 
.RE
.PP

.PP
References \fBREDIS_NULL\fP, \fBredisxDestroyRESP()\fP, \fBredisxReadReplyAsync()\fP, \fBX_SUCCESS\fP, and \fBx_trace()\fP\&.
.SS "\fBRedis\fP * redisxInit (const char * server)"
Initializes the \fBRedis\fP client library, and sets the hostname or IP address for the \fBRedis\fP server\&.
.PP
\fBParameters\fP
.RS 4
\fIserver\fP Server host name or numeric IP address, e\&.g\&. '127\&.0\&.0\&.1'\&. The string will be copied, not referenced, for the internal configuration, such that the string passed may be destroyed freely after the call\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS or X_FAILURE if the IP address is invalid\&. X_NULL if the IP address is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxInitSentinel()\fP 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRedis::interactive\fP, \fBRedis::pipeline\fP, \fBREDISX_CHANNELS\fP, \fBREDISX_DEFAULT_TIMEOUT_MILLIS\fP, \fBREDISX_INTERACTIVE_CHANNEL\fP, \fBREDISX_PIPELINE_CHANNEL\fP, \fBREDISX_RESP2\fP, \fBREDISX_SUBSCRIPTION_CHANNEL\fP, \fBREDISX_TCP_BUF_SIZE\fP, \fBrSetServerAsync()\fP, \fBRedis::subscription\fP, \fBTRUE\fP, \fBx_error()\fP, \fBX_SUCCESS\fP, and \fBx_trace_null()\fP\&.
.SS "\fBRedis\fP * redisxInitSentinel (const char * serviceName, const \fBRedisServer\fP * serverList, int nServers)"
Initializes a \fBRedis\fP client with a Sentinel configuration of alternate servers, and the default sentinel node connection timeout\&.
.PP
\fBParameters\fP
.RS 4
\fIserviceName\fP The service name as registered in the Sentinel server configuration\&. The supplied name will be copied, not referenced, so that the value passed may be freely destroyed after the call\&. 
.br
\fIserverList\fP An set of Sentinel servers to use to dynamically find the current master\&. The list itself and its contents are not referenced\&. Instead a deep copy will be made of it, so the list that was pased can be freely destroyed after the call\&. 
.br
\fInServers\fP The number of servers in the list 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else an error code <0\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetSentinelTimeout()\fP 
.PP
\fBredisxInit()\fP 
.PP
\fBredisxConnect()\fP 
.RE
.PP

.PP
References \fBREDISX_DEFAULT_SENTINEL_TIMEOUT_MILLIS\fP, \fBredisxInit()\fP, \fBredisxValidateSentinel()\fP, \fBx_error()\fP, \fBX_SUCCESS\fP, \fBx_trace_null()\fP, and \fBxStringCopyOf()\fP\&.
.SS "\fBboolean\fP redisxIsArrayType (const \fBRESP\fP * r)"
Checks if a \fBRESP\fP holds an array of \fBRESP\fP pointers, and whose \fCvalue\fP can be cast to \fC(\fBRESP\fP **)\fP to use\&.
.PP
\fBParameters\fP
.RS 4
\fIr\fP Pointer to a \fBRESP\fP data structure 
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) if the data holds an array of \fC\fBRESP\fP *\fP pointers, or else FALSE (0)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxIsScalarType()\fP 
.PP
\fBredisxIsStringType()\fP 
.PP
\fBredisxIsMapType()\fP 
.PP
\fBRESP_ARRAY\fP 
.PP
\fBRESP3_SET\fP 
.PP
\fBRESP3_PUSH\fP 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRESP3_PUSH\fP, \fBRESP3_SET\fP, \fBRESP_ARRAY\fP, \fBTRUE\fP, and \fBRESP::type\fP\&.
.SS "\fBboolean\fP redisxIsConnected (\fBRedis\fP * redis)"
Checks if a \fBRedis\fP instance is connected\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&.
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) if the \fBRedis\fP instance is connected, or FALSE (0) otherwise\&. 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRedis::interactive\fP, \fBredisxCheckValid()\fP, and \fBX_SUCCESS\fP\&.
.SS "\fBboolean\fP redisxIsEqualRESP (const \fBRESP\fP * a, const \fBRESP\fP * b)"
Checks if two \fBRESP\fP are equal, that is they hold the same type of data, have the same 'n' value, and the values match byte-for-byte, or are both NULL\&.
.PP
\fBParameters\fP
.RS 4
\fIa\fP Ponter to a \fBRESP\fP data structure\&. 
.br
\fIb\fP Pointer to another \fBRESP\fP data structure\&. 
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) if the two \fBRESP\fP structures match, or else FALSE (0)\&. 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRESP::n\fP, \fBTRUE\fP, \fBRESP::type\fP, and \fBRESP::value\fP\&.
.SS "int redisxIsGlobPattern (const char * str)"
Checks if a given string is a glob-style pattern\&.
.PP
\fBParameters\fP
.RS 4
\fIstr\fP The string to check\&.
.RE
.PP
\fBReturns\fP
.RS 4
TRUE if it is a glob pattern (e\&.g\&. has '*', '?' or '['), otherwise FALSE\&. 
.RE
.PP

.PP
References \fBFALSE\fP, and \fBTRUE\fP\&.
.SS "\fBboolean\fP redisxIsMapType (const \fBRESP\fP * r)"
Checks if a \fBRESP\fP holds a dictionary, and whose \fCvalue\fP can be cast to \fC(\fBRedisMap\fP *)\fP to use\&.
.PP
\fBParameters\fP
.RS 4
\fIr\fP Pointer to a \fBRESP\fP data structure 
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) if the data holds a dictionary (a \fBRedisMap\fP array), or else FALSE (0)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxIsScalarType()\fP 
.PP
\fBredisxIsStringType()\fP 
.PP
\fBredisxIsMapType()\fP 
.PP
\fBRESP3_MAP\fP 
.PP
\fBRESP3_ATTRIBUTE\fP 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRESP3_ATTRIBUTE\fP, \fBRESP3_MAP\fP, \fBTRUE\fP, and \fBRESP::type\fP\&.
.SS "\fBboolean\fP redisxIsScalarType (const \fBRESP\fP * r)"
Checks if a \fBRESP\fP holds a scalar type value, such as an integer, a boolean or a double-precision value, or a \fInull\fP value\&.
.PP
\fBParameters\fP
.RS 4
\fIr\fP Pointer to a \fBRESP\fP data structure 
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) if the data holds a scalar-type value, or else FALSE (0)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxIsStringType()\fP 
.PP
\fBredisxIsArrayType()\fP 
.PP
\fBredisxIsMapType()\fP 
.PP
\fBRESP_INT\fP 
.PP
\fBRESP3_BOOLEAN\fP 
.PP
\fBRESP3_DOUBLE\fP 
.PP
\fBRESP3_NULL\fP 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRESP3_BOOLEAN\fP, \fBRESP3_DOUBLE\fP, \fBRESP3_NULL\fP, \fBRESP_INT\fP, \fBTRUE\fP, and \fBRESP::type\fP\&.
.SS "\fBboolean\fP redisxIsStringType (const \fBRESP\fP * r)"
Checks if a \fBRESP\fP holds a string type value, whose \fCvalue\fP can be cast to \fC(char *)\fP to use\&.
.PP
\fBParameters\fP
.RS 4
\fIr\fP Pointer to a \fBRESP\fP data structure 
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) if the data holds a string type value, or else FALSE (0)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxIsScalarType()\fP 
.PP
\fBredisxIsArrayType()\fP 
.PP
\fBredisxIsMapType()\fP 
.PP
\fBRESP_SIMPLE_STRING\fP 
.PP
\fBRESP_ERROR\fP 
.PP
\fBRESP_BULK_STRING\fP 
.PP
\fBRESP3_BLOB_ERROR\fP 
.PP
\fBRESP3_VERBATIM_STRING\fP 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRESP3_BIG_NUMBER\fP, \fBRESP3_BLOB_ERROR\fP, \fBRESP3_VERBATIM_STRING\fP, \fBRESP_BULK_STRING\fP, \fBRESP_ERROR\fP, \fBRESP_SIMPLE_STRING\fP, \fBTRUE\fP, and \fBRESP::type\fP\&.
.SS "\fBboolean\fP redisxIsVerbose ()"
Checks id verbose reporting is enabled\&.
.PP
\fBReturns\fP
.RS 4
TRUE if verbose reporting is enabled, otherwise FALSE\&. 
.RE
.PP

.PP
References \fBxIsVerbose()\fP\&.
.SS "int redisxLoadScript (\fBRedis\fP * redis, const char * script, char ** sha1)"
Loads a LUA script into \fBRedis\fP, returning its SHA1 hash to use as it's call ID\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIscript\fP String containing the full LUA script\&. 
.br
\fIsha1\fP Buffer into which SHA1 key returned by \fBRedis\fP to use as call ID\&. (It must be at least 41 bytes, and will be string terminated)\&. By default it will return an empty string\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if the script has been successfully loaded into \fBRedis\fP, or X_NULL if the \fBRedis\fP instance is NULL X_NAME_INVALID if the script is NULL or empty\&. REDIS_UNEXPECTED_RESP if received a \fBRedis\fP reponse of the wrong type, or an error (<0) returned by \fBredisxRequest()\fP\&. 
.RE
.PP

.PP
References \fBredisxCheckDestroyRESP()\fP, \fBredisxDestroyRESP()\fP, \fBredisxRequest()\fP, \fBRESP_BULK_STRING\fP, \fBRESP::value\fP, \fBx_error()\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxLockClient (\fBRedisClient\fP * cl)"
Get exclusive write access to the specified \fBRedis\fP channel\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to the \fBRedis\fP client instance\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS if the exclusive lock for the channel was successfully obtained, or X_FAILURE if pthread_mutex_lock() returned an error, or X_NULL if the client is NULL, or X_NO_INIT if the client was not initialized\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxLockConnected()\fP 
.PP
\fBredisxUnlockClient()\fP 
.RE
.PP

.PP
References \fBx_error()\fP, \fBX_FAILURE\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxLockConnected (\fBRedisClient\fP * cl)"
Lock a channel, but only if it has been enabled for communication\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to the \fBRedis\fP client instance
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if an excusive lock to the channel has been granted, or X_FAILURE if pthread_mutex_lock() returned an error, or X_NULL if the client is NULL, or X_NO_INIT if the client was not initialized\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxLockClient()\fP 
.PP
\fBredisxUnlockClient()\fP 
.PP
\fBredisxGetLockedConnectedClient()\fP 
.RE
.PP

.PP
References \fBredisxLockClient()\fP, \fBredisxUnlockClient()\fP, \fBx_error()\fP, \fBX_NO_SERVICE\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxMultiSet (\fBRedis\fP * redis, const char * table, const \fBRedisEntry\fP * entries, int n, \fBboolean\fP confirm)"
Sets multiple key/value pairs in a given hash table\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fItable\fP Hashtable from which to retrieve a value\&. 
.br
\fIentries\fP Pointer to an array of key/value pairs\&. 
.br
\fIn\fP Number of entries\&. 
.br
\fIconfirm\fP Whether we should get a confirmation from the server (requires a round-trip)\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) on success or an error code (<0) from \fBredisx\&.h\fP / \fBxchange\&.h\fP\&. 
.RE
.PP

.PP
References \fBRedis::interactive\fP, \fBREDIS_UNEXPECTED_RESP\fP, \fBredisxArrayRequest()\fP, \fBredisxCheckValid()\fP, \fBredisxDestroyRESP()\fP, \fBredisxMultiSetAsync()\fP, \fBRESP::value\fP, \fBx_error()\fP, \fBX_FAILURE\fP, \fBX_SUCCESS\fP, and \fBx_trace()\fP\&.
.SS "int redisxMultiSetAsync (\fBRedisClient\fP * cl, const char * table, const \fBRedisEntry\fP * entries, int n, \fBboolean\fP confirm)"
Sets multiple key/value pairs in a given hash table\&. This function should be called with exclusive access to the client\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP A \fBRedis\fP client to which we have exclusive access\&. 
.br
\fItable\fP Hashtable from which to retrieve a value\&. 
.br
\fIentries\fP Pointer to an array of key/value pairs\&. 
.br
\fIn\fP Number of entries\&. 
.br
\fIconfirm\fP Whether we should get a confirmation from the server (requires a round-trip)\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) on success or an error code (<0) from \fBredisx\&.h\fP / \fBxchange\&.h\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxMultiSet()\fP 
.PP
\fBredisxLockClient()\fP 
.RE
.PP

.PP
References \fBredisxSendArrayRequestAsync()\fP, \fBredisxSkipReplyAsync()\fP, \fBX_FAILURE\fP, \fBX_SUCCESS\fP, and \fBx_trace()\fP\&.
.SS "int redisxNotify (\fBRedis\fP * redis, const char * channel, const char * message)"
Sends a regular string terminated \fBRedis\fP PUB/SUB message on the specified channel\&. Same as \fBredisxPublish()\fP with the length argument set to the length of the string message\&. \fBRedis\fP must be connected before attempting to send messages\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIchannel\fP \fBRedis\fP PUB/SUB channel on which to notify 
.br
\fImessage\fP Message to send\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS if the message was successfullt sent\&. X_NO_INIT if the \fBRedis\fP library was not initialized via initRedis()\&. X_NO_SERVICE if there was a connection problem\&. PARSE_ERROR if the \fBRedis\fP response could not be confirmed\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxPublish()\fP 
.PP
\fBredisxPublishAsync()\fP 
.PP
\fBredisxSubscribe()\fP 
.RE
.PP

.PP
References \fBredisxPublish()\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxPing (\fBRedis\fP * redis, const char * message)"
Pings the \fBRedis\fP server (see the \fBRedis\fP \fCPING\fP command), and checks the response\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fImessage\fP Optional message , or NULL for \fCPING\fP without an argument\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else an error code (<0) from \fBredisx\&.h\fP / \fBxchange\&.h\fP\&. 
.RE
.PP

.PP
References \fBREDIS_UNEXPECTED_RESP\fP, \fBredisxCheckDestroyRESP()\fP, \fBredisxDestroyRESP()\fP, \fBredisxRequest()\fP, \fBRESP_BULK_STRING\fP, \fBRESP_SIMPLE_STRING\fP, \fBRESP::value\fP, \fBx_error()\fP, and \fBX_SUCCESS\fP\&.
.SS "void redisxPrintDelimited (const \fBRESP\fP * resp, const char * delim, const char * groupPrefix)"
Prints a \fBRESP\fP in raw form using delimiters only\&.
.PP
\fBParameters\fP
.RS 4
\fIresp\fP Pointer to a \fBRESP\fP (it may be NULL) 
.br
\fIdelim\fP Delimiter between elements 
.br
\fIgroupPrefix\fP Prefix in front of arrays and maps
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxPrintRESP()\fP 
.PP
\fBredisxPrintJSON()\fP 
.RE
.PP

.PP
References \fBRESP::n\fP, \fBredisxPrintDelimited()\fP, \fBRESP3_ATTRIBUTE\fP, \fBRESP3_BIG_NUMBER\fP, \fBRESP3_BLOB_ERROR\fP, \fBRESP3_DOUBLE\fP, \fBRESP3_MAP\fP, \fBRESP3_NULL\fP, \fBRESP3_PUSH\fP, \fBRESP3_SET\fP, \fBRESP3_VERBATIM_STRING\fP, \fBRESP_ARRAY\fP, \fBRESP_BULK_STRING\fP, \fBRESP_ERROR\fP, \fBRESP_INT\fP, \fBRESP_SIMPLE_STRING\fP, \fBRESP::type\fP, and \fBRESP::value\fP\&.
.SS "int redisxPrintJSON (const char * name, const \fBRESP\fP * resp)"
Prints a \fBRESP\fP as a JSON fragmen to the standard output with the specified name
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name/ID to assign to the \fBRESP\fP 
.br
\fIresp\fP The \fBRESP\fP data to print 
.RE
.PP
\fBReturns\fP
.RS 4
0
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxPrintRESP()\fP 
.PP
\fBredisxPrintDelimited()\fP 
.PP
\fBredisxRESP2JSON()\fP 
.RE
.PP

.PP
References \fBredisxRESP2JSON()\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxPrintRESP (const \fBRESP\fP * resp)"
Prints a \fBRESP\fP to the standard output, in a format that is similar to the one used by the standard redis-cli tool\&.
.PP
\fBParameters\fP
.RS 4
\fIresp\fP Pointer to a \fBRESP\fP data structure\&. (It may be NULL)\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful or else X_FAILURE if there was an error\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxPrintJSON()\fP 
.PP
\fBredisxPrintDelimited()\fP 
.RE
.PP

.PP
References \fBX_FAILURE\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxPublish (\fBRedis\fP * redis, const char * channel, const char * data, int length)"
Sends a generic \fBRedis\fP PUB/SUB message on the specified channel\&. \fBRedis\fP must be connected before attempting to send messages\&. It will send the message over the pipeline client if it is avaiable, or else over the interactive client\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIchannel\fP \fBRedis\fP PUB/SUB channel on which to notify 
.br
\fIdata\fP Data to send\&. 
.br
\fIlength\fP Bytes of data to send, or 0 to determine automatically with strlen()\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS if the message was successfullt sent\&. X_NO_INIT if the \fBRedis\fP library was not initialized via initRedis()\&. X_NO_SERVICE if there was a connection problem\&. PARSE_ERROR if the \fBRedis\fP response could not be confirmed\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxNotify()\fP 
.PP
\fBredisxPublishAsync()\fP 
.PP
\fBredisxSubscribe()\fP 
.RE
.PP

.PP
References \fBRedis::id\fP, \fBRedis::interactive\fP, \fBredisxCheckValid()\fP, \fBredisxLockConnected()\fP, \fBredisxPublishAsync()\fP, \fBredisxUnlockClient()\fP, \fBX_SUCCESS\fP, and \fBxvprintf\fP\&.
.SS "int redisxPublishAsync (\fBRedis\fP * redis, const char * channel, const char * data, int length)"
Sends a \fBRedis\fP notification asynchronously using the \fBRedis\fP 'PUBLISH' command\&. The caller should have an exclusive lock on the interactive \fBRedis\fP channel before calling this\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIchannel\fP \fBRedis\fP PUB/SUB channel on which to notify 
.br
\fIdata\fP Message body data\&. 
.br
\fIlength\fP Bytes of message data to send, ot 0 to determine automatically with strlen()\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else X_NULL if the redis instance is NULL X_NAME_INVALID if the PUB/SUB channel is null or empty or an error code (<0) returned by \fBredisxSendArrayRequestAsync()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxPublish()\fP 
.PP
\fBredisxNotify()\fP 
.RE
.PP

.PP
References \fBRedis::interactive\fP, \fBredisxCheckValid()\fP, \fBredisxSendArrayRequestAsync()\fP, \fBredisxSkipReplyAsync()\fP, \fBx_error()\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "\fBRESP\fP * redisxReadReplyAsync (\fBRedisClient\fP * cl, int * pStatus)"
Reads a response from \fBRedis\fP and returns it\&. It should be used with an exclusive lock on a connected client, to collect responses for requests sent previously\&. It is up to the caller to keep track of what request the response is for\&. The responses arrive in the same order (and same nummber) as the requests that were sent out\&.
.PP
To follow cluster MOVED or ASK redirections, the caller should check the reponse for redirections (e\&.g\&. via redisxIsRedirected()) and then act accordingly to re-submit the corresponding request, as is or with an ASKING directive to follow the redirection\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to a \fBRedis\fP channel 
.br
\fIpStatus\fP Pointer to int in which to return an error status, or NULL if not required\&.
.RE
.PP
\fBReturns\fP
.RS 4
The \fBRESP\fP structure for the reponse received from \fBRedis\fP, or NULL if an error was encountered (errno will be set to describe the error, which may either be an errno produced by recv() or EBADMSG if the message was corrupted and/or unparseable\&. If the error is irrecoverable i\&.e\&., other than a timeout, the client will be disabled\&.)
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxIgnoreReplyAsync()\fP 
.PP
\fBredisxSetReplyTimeout()\fP 
.PP
\fBredisxGetAvailableAsync()\fP 
.PP
\fBredisxSendRequestAsync()\fP 
.PP
\fBredisxSendArrayRequestAsync()\fP 
.PP
redisxGetLockedConnected() 
.PP
\fBredisxCheckRESP()\fP 
.PP
redisxIsRedirected() 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRedisMap::key\fP, \fBRESP::n\fP, \fBrCloseClientAsync()\fP, \fBREDIS_INCOMPLETE_TRANSFER\fP, \fBREDIS_SIMPLE_STRING_SIZE\fP, \fBREDIS_UNEXPECTED_RESP\fP, \fBredisxAppendRESP()\fP, \fBredisxClusterMoved()\fP, \fBredisxDestroyRESP()\fP, \fBredisxHasComponents()\fP, \fBredisxReadReplyAsync()\fP, \fBRESP3_ATTRIBUTE\fP, \fBRESP3_BIG_NUMBER\fP, \fBRESP3_BLOB_ERROR\fP, \fBRESP3_BOOLEAN\fP, \fBRESP3_CONTINUED\fP, \fBRESP3_DOUBLE\fP, \fBRESP3_MAP\fP, \fBRESP3_NULL\fP, \fBRESP3_PUSH\fP, \fBRESP3_SET\fP, \fBRESP3_VERBATIM_STRING\fP, \fBRESP_ARRAY\fP, \fBRESP_BULK_STRING\fP, \fBRESP_ERROR\fP, \fBRESP_INT\fP, \fBRESP_SIMPLE_STRING\fP, \fBTRUE\fP, \fBRESP::type\fP, \fBRESP::value\fP, \fBRedisMap::value\fP, \fBx_error()\fP, \fBX_FAILURE\fP, \fBX_NO_INIT\fP, \fBX_NO_SERVICE\fP, \fBX_PARSE_ERROR\fP, \fBX_SUCCESS\fP, \fBx_trace_null()\fP, \fBxParseDouble()\fP, and \fBxStringCopyOf()\fP\&.
.SS "int redisxReconnect (\fBRedis\fP * redis, \fBboolean\fP usePipeline)"
Disconnects from \fBRedis\fP, and then connects again\&.\&.\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIusePipeline\fP Whether to reconnect in pipelined mode\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful X_NULL if the \fBRedis\fP instance is NULL
.RE
.PP
or else an error (<0) as would be returned by \fBredisxConnect()\fP\&. 
.PP
References \fBX_SUCCESS\fP\&.
.SS "int redisxRemoveConnectHook (\fBRedis\fP * redis, void(*)(\fBRedis\fP *) setupCall)"
Removes a connect call hook\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIsetupCall\fP User-specified callback routine to be called after the \fBRedis\fP instance has been connected\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful or else X_NULL if either of the arguments is NULL\&. 
.RE
.PP

.PP
References \fBx_error()\fP, \fBX_NULL\fP, \fBX_SUCCESS\fP, and \fBxvprintf\fP\&.
.SS "int redisxRemoveDisconnectHook (\fBRedis\fP * redis, void(*)(\fBRedis\fP *) cleanupCall)"
Removes a cleanup call hook for when the \fBRedis\fP instance is disconnected\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIcleanupCall\fP User specified function to call when \fBRedis\fP is disconnected\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful or else X_NULL if the argument is NULL\&. 
.RE
.PP

.PP
References \fBx_error()\fP, \fBX_NULL\fP, \fBX_SUCCESS\fP, and \fBxvprintf\fP\&.
.SS "int redisxRemoveSubscribers (\fBRedis\fP * redis, \fBRedisSubscriberCall\fP f)"
Removes all instances of a subscribe consumer function from the current list of consumers\&. This calls only deactivates the specified processing callback function(s), without stopping the delivery of associated messages\&. To stop \fBRedis\fP sending messages that are no longer being processed, you should also call \fBredisxUnsubscribe()\fP as appropriate\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIf\fP The consumer function to remove from the list of active subscribers\&.
.RE
.PP
\fBReturns\fP
.RS 4
The number of instances of f() that have been removed from the list of subscribers\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxAddSubscriber()\fP 
.PP
\fBredisxClearSubscribers()\fP 
.PP
redisxUnsubscrive() 
.RE
.PP

.PP
References \fBx_error()\fP, \fBX_NULL\fP, and \fBxvprintf\fP\&.
.SS "\fBRESP\fP * redisxRequest (\fBRedis\fP * redis, const char * command, const char * arg1, const char * arg2, const char * arg3, int * status)"
Returns the result of a \fBRedis\fP command with up to 3 regularly terminated string arguments\&. This is not the highest throughput mode (that would be sending asynchronous pipeline request, and then asynchronously collecting the results such as with \fBredisxSendRequestAsync()\fP / \fBredisxReadReplyAsync()\fP, because it requires separate network roundtrips for each and every request\&. But, it is simple and perfectly good method when one needs to retrieve only a few (<1000) variables per second\&.\&.\&.
.PP
To make \fBRedis\fP calls with binary (non-string) data, you can use \fBredisxArrayRequest()\fP instead, where you can set the number of bytes for each argument explicitly\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIcommand\fP \fBRedis\fP command, e\&.g\&. 'HGET' 
.br
\fIarg1\fP First terminated string argument or NULL\&. 
.br
\fIarg2\fP Second terminated string argument or NULL\&. 
.br
\fIarg3\fP Third terminated string argument or NULL\&. 
.br
\fIstatus\fP Pointer to the return error status, which is either X_SUCCESS on success or else the error code set by \fBredisxArrayRequest()\fP\&.
.RE
.PP
\fBReturns\fP
.RS 4
A freshly allocated \fBRESP\fP array containing the \fBRedis\fP response, or NULL if no valid response could be obtained or status is not X_SUCCESS\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxArrayRequest()\fP 
.PP
\fBredisxSendRequestAsync()\fP 
.PP
\fBredisxReadReplyAsync()\fP 
.RE
.PP

.PP
References \fBredisxArrayRequest()\fP, \fBredisxDestroyRESP()\fP, \fBX_SUCCESS\fP, and \fBx_trace_null()\fP\&.
.SS "char * redisxRESP2JSON (const char * name, const \fBRESP\fP * resp)"
Converts a \fBRESP\fP to the xchange representation as an appropriate \fBXField\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name to assign to the field 
.br
\fIresp\fP The \fBRESP\fP data to convert 
.RE
.PP
\fBReturns\fP
.RS 4
An \fBXField\fP with the data from the \fBRESP\fP, or NULL if there was an error (errno will be set to indicate the type of error)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxRESP2XField()\fP 
.PP
\fBredisxPrintJSON()\fP 
.RE
.PP

.PP
References \fBredisxRESP2XField()\fP, and \fBxjsonFieldToString()\fP\&.
.SS "\fBXField\fP * redisxRESP2XField (const char * name, const \fBRESP\fP * resp)"
Converts a \fBRESP\fP to the xchange representation as an appropriate \fBXField\fP\&.
.PP
.PD 0
.IP "\(bu" 2
RESP3_NULL values are converted to NULL\&. 
.IP "\(bu" 2
Scalar values are converted to an \fBXField\fP with the equivalent type\&. 
.IP "\(bu" 2
Homogenerous arrays are converted to a field with a 1D array of corresponding xchange type\&. 
.IP "\(bu" 2
Heterogeneous arrays are converted to a field with a 1D array of X_FIELD type (containing an array of fields)\&. 
.IP "\(bu" 2
Maps with string keywords are converted to an X_STRUCT\&. 
.IP "\(bu" 2
Maps with non-string keywords are added under a sub-structure named '\&.non-string-keys' as indexed structures with separate 'key' and 'value' fields\&. 
.IP "\(bu" 2
The original \fBRESP\fP type (single character) is preserved as a 0-terminated string in \fBXField\&.subtype\fP field\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIname\fP The name to assign to the field 
.br
\fIresp\fP The \fBRESP\fP data to convert 
.RE
.PP
\fBReturns\fP
.RS 4
An \fBXField\fP with the data from the \fBRESP\fP, or NULL if there was an error (errno will be set to indicate the type of error)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxRESP2JSON()\fP 
.RE
.PP

.PP
References \fBRESP::n\fP, \fBRESP3_ATTRIBUTE\fP, \fBRESP3_BIG_NUMBER\fP, \fBRESP3_BLOB_ERROR\fP, \fBRESP3_BOOLEAN\fP, \fBRESP3_DOUBLE\fP, \fBRESP3_MAP\fP, \fBRESP3_NULL\fP, \fBRESP3_PUSH\fP, \fBRESP3_SET\fP, \fBRESP3_VERBATIM_STRING\fP, \fBRESP_ARRAY\fP, \fBRESP_BULK_STRING\fP, \fBRESP_ERROR\fP, \fBRESP_INT\fP, \fBRESP_SIMPLE_STRING\fP, \fBRESP::type\fP, \fBRESP::value\fP, \fBX_UNKNOWN\fP, \fBxCreateBooleanField()\fP, \fBxCreateDoubleField()\fP, \fBxCreateIntField()\fP, \fBxCreateScalarField()\fP, and \fBxCreateStringField()\fP\&.
.SS "\fBRESP\fP * redisxRunScript (\fBRedis\fP * redis, const char * sha1, const char ** keys, const char ** params, int * status)"
Runs a LUA script that has been loaded into the \fBRedis\fP database, returning the response received, or NULL if there was an error\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP The \fBRedis\fP instance 
.br
\fIsha1\fP The SHA1 sum of the script that was previously loaded into the \fBRedis\fP DB\&. 
.br
\fIkeys\fP A NULL-terminated array of \fBRedis\fP keywords, or NULL if the script does not take any keyword argument\&. 
.br
\fIparams\fP A NULL-terminated array of additional parameters to pass onto the script, or NULL if the script does not take any parameters\&. 
.br
\fIstatus\fP Pointer to int in which to return status, or NULL if not required\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The response received from the script or the EVALSHA request, or NULL if there was an error\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxRunScriptAsync()\fP 
.PP
\fBredisxLoadScript()\fP 
.RE
.PP

.PP
References \fBredisxArrayRequest()\fP, \fBredisxCheckValid()\fP, \fBx_error()\fP, \fBX_NULL\fP, \fBX_SUCCESS\fP, and \fBx_trace_null()\fP\&.
.SS "char ** redisxScanKeys (\fBRedis\fP * redis, const char * pattern, int * n)"
Returns an alphabetical list of the \fBRedis\fP keys using the \fBRedis\fP SCAN command\&. Because it uses the scan command, it is guaranteed to not hog the database for excessive periods, and hence it is preferable to redisxGetKeys(table=NULL)\&.
.PP
Some data may be returned even if there was an error, and the caller is responsible for cleaning up the returned srotage elements\&.
.PP
The caller may adjust the amount of work performed in each scan call via the \fBredisxSetScanCount()\fP function, prior to calling this\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIpattern\fP keyword pattern to match, or NULL for all keys\&. 
.br
\fIn\fP Pointer to the integer in which the number of elements (>=0), or else an error code (<0), such as:
.RE
.PP
X_NULL If one of the arguments is NULL REDIS_NULL If got a null or empty response from \fBRedis\fP UNEXPECTED_RESP If the response from \fBRedis\fP was not the expected array type lt 
.PP
\fBReturns\fP
.RS 4
An array with pointers to key names from this table or NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxGetKeys()\fP 
.PP
\fBredisxSetScanCount()\fP 
.PP
\fBredisxDestroyKeys()\fP 
.RE
.PP

.PP
References \fBRESP::n\fP, \fBredisxArrayRequest()\fP, \fBredisxCheckRESP()\fP, \fBredisxDestroyKeys()\fP, \fBredisxDestroyRESP()\fP, \fBredisxGetScanCount()\fP, \fBRESP_ARRAY\fP, \fBRESP_BULK_STRING\fP, \fBSCAN_INITIAL_STORE_CAPACITY\fP, \fBRESP::value\fP, \fBx_error()\fP, \fBX_SUCCESS\fP, \fBx_trace_null()\fP, \fBxStringCopyOf()\fP, and \fBxvprintf\fP\&.
.SS "\fBRedisEntry\fP * redisxScanTable (\fBRedis\fP * redis, const char * table, const char * pattern, int * n)"
Returns an alphabetical list of the \fBRedis\fP hash table data using the \fBRedis\fP HSCAN command\&. Because it uses the scan command, it is guaranteed to not hog the database for excessive periods, and hence it is preferable to \fBredisxGetTable()\fP\&.
.PP
Some data may be returned even if there was an error, and the caller is responsible for cleaning up the returned srotage elements\&.
.PP
The caller may adjust the amount of work performed in each scan call via the \fBredisxSetScanCount()\fP function, prior to calling this\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fItable\fP Name of \fBRedis\fP hash table to scan data from 
.br
\fIpattern\fP keyword pattern to match, or NULL for all keys\&. 
.br
\fIn\fP Pointer to the integer in which the number of elements (>=0) or else an error code (<0), such as:
.RE
.PP
X_NULL if one of the arguments is NULL X_GROUP_INVALID if the table name is empty REDIS_NULL if got a null or empty response from \fBRedis\fP UNEXPECTED_RESP if the response from \fBRedis\fP was not the expected array type
.PP
\fBReturns\fP
.RS 4
A \fBRedisEntry\fP[] array or NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxGetKeys()\fP 
.PP
\fBredisxSetScanCount()\fP 
.PP
\fBredisxDestroyEntries()\fP 
.RE
.PP

.PP
References \fBRedisEntry::key\fP, \fBRedisEntry::length\fP, \fBRESP::n\fP, \fBredisxArrayRequest()\fP, \fBredisxCheckRESP()\fP, \fBredisxDestroyEntries()\fP, \fBredisxDestroyRESP()\fP, \fBredisxGetScanCount()\fP, \fBRESP_ARRAY\fP, \fBRESP_BULK_STRING\fP, \fBSCAN_INITIAL_STORE_CAPACITY\fP, \fBRESP::value\fP, \fBRedisEntry::value\fP, \fBx_error()\fP, \fBX_GROUP_INVALID\fP, \fBX_NULL\fP, \fBX_SUCCESS\fP, \fBx_trace_null()\fP, \fBxStringCopyOf()\fP, and \fBxvprintf\fP\&.
.SS "int redisxSelectDB (\fBRedis\fP * redis, int idx)"
Switches to another database index on the \fBRedis\fP server\&. Note that you cannot change the database on an active PUB/SUB channel, hence the call will return X_INCOMPLETE if attempted\&. You should instead switch DB when there are no active subscriptions\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIidx\fP zero-based database index 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or X_NULL if the redis argument is NULL, X_INCOMPLETE if there is an active subscription channel that cannot be switched or one of the channels could not confirm the switch, or else another error code (<0) from \fBredisx\&.h\fP / \fBxchange\&.h\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSelectDB()\fP 
.PP
\fBredisxLockConnected()\fP 
.RE
.PP

.PP
References \fBREDIS_INVALID_CHANNEL\fP, \fBREDISX_CHANNELS\fP, \fBREDISX_PIPELINE_CHANNEL\fP, \fBREDISX_SUBSCRIPTION_CHANNEL\fP, \fBredisxAddConnectHook()\fP, \fBredisxGetClient()\fP, \fBredisxIsConnected()\fP, \fBredisxLockConnected()\fP, \fBredisxRemoveConnectHook()\fP, \fBredisxUnlockClient()\fP, \fBX_INCOMPLETE\fP, \fBX_SUCCESS\fP, and \fBx_trace()\fP\&.
.SS "int redisxSendArrayRequestAsync (\fBRedisClient\fP * cl, const char ** args, const int * lengths, int n)"
Send a \fBRedis\fP request with an arbitrary number of arguments\&. This function should be called with an exclusive lock on a connected client\&.
.PP
Unlike its interactive counterpart, \fBredisxArrayRequest()\fP, this method does not follow cluster MOVED or ASK redirections automatically\&. It cannot, since it returns without waiting for a response\&. To implement redirections, the caller must keep track of the asynchronous requests sent, and check for redirections when processing responses via \fBredisxReadReplyAsync()\fP\&. If the response is a redirection, then the caller can decide if and how to re-submit the request to follow the redirection\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to the \fBRedis\fP client\&. 
.br
\fIargs\fP The array of string arguments to send\&. If you have an \fCchar **\fP array, you may need to cast to \fC(const char **)\fP to avoid compiler warnings\&. 
.br
\fIlengths\fP Array indicating the number of bytes to send from each string argument\&. Zero or negative values can be used to determine the string length automatically using strlen(), and the length argument itself may be NULL to determine the lengths of all string arguments automatically\&. 
.br
\fIn\fP The number of arguments to send\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) on success or X_NULL if the client is NULL, or X_NO_SERVICE if not connected to the client or if send() failed, or X_NO_INIT if the client was not initialized\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSendRequestAsync()\fP 
.PP
\fBredisxArrayRequest()\fP 
.PP
\fBredisxReadReplyAsync()\fP 
.PP
redisxGetLockedConnected() 
.PP
\fBredisxSkipReplyAsync()\fP 
.RE
.PP

.PP
References \fBFALSE\fP, \fBREDISX_CMDBUF_SIZE\fP, \fBTRUE\fP, \fBx_error()\fP, \fBX_NO_SERVICE\fP, \fBX_SUCCESS\fP, and \fBxvprintf\fP\&.
.SS "int redisxSendRequestAsync (\fBRedisClient\fP * cl, const char * command, const char * arg1, const char * arg2, const char * arg3)"
Send a command (with up to 3 arguments) to the \fBRedis\fP server\&. The caller must have an exclusive lock on the client for this version\&. The arguments supplied will be used up to the first non-NULL value\&.
.PP
Unlike its interactive counterpart, \fBredisxRequest()\fP, this method does not follow cluster MOVED or ASK redirections automatically\&. It cannot, since it returns without waiting for a response\&. To implement redirections, the caller must keep track of the asynchronous requests sent, and check for redirections when processing responses via \fBredisxReadReplyAsync()\fP\&. If the response is a redirection, then the caller can decide if and how to re-submit the request to follow the redirection\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to the \fBRedis\fP client instance\&. 
.br
\fIcommand\fP \fBRedis\fP command string\&. 
.br
\fIarg1\fP Optional first string argument or NULL\&. 
.br
\fIarg2\fP Optional second string argument or NULL\&. 
.br
\fIarg3\fP Optional third string argument or NULL\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) on success or X_NULL if the client is NULL, or else X_NO_SERVICE if not connected to the client or if send() failed
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSendArrayRequestAsync()\fP 
.PP
\fBredisxRequest()\fP 
.PP
\fBredisxReadReplyAsync()\fP 
.PP
redisxGetLockedConnected() 
.PP
\fBredisxSkipReplyAsync()\fP 
.RE
.PP

.PP
References \fBredisxSendArrayRequestAsync()\fP, \fBx_error()\fP, \fBX_NAME_INVALID\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetDHCipherParams (\fBRedis\fP * redis, const char * dh_params_file)"
Sets parameters for DH-based cyphers when using a TLS encrypted connection to \fBRedis\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP A \fBRedis\fP instance\&. 
.br
\fIdh_params_file\fP Path to the DH-based cypher parameters file (in PEM format; we don't support the old DER format), or NULL for no params\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else an error code <0\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetTLS()\fP 
.PP
\fBredisxSetTLSCiphers()\fP 
.RE
.PP

.PP
References \fBx_error()\fP, \fBX_FAILURE\fP, \fBX_SUCCESS\fP, and \fBxStringCopyOf()\fP\&.
.SS "int redisxSetHostname (\fBRedis\fP * redis, const char * host)"
Changes the host name for the \fBRedis\fP server, prior to calling \fC\fBredisxConnect()\fP\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIhost\fP New host name or IP address to use\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else X_NULL if the redis instance or the host name is NULL, or X_NO_INIT if the redis instance is not initialized, X_ALREADY_OPEN if the redis instance is currently in a connected state, or X_FAILURE if \fBRedis\fP was initialized in Sentinel configuration\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetPort()\fP 
.PP
\fBredisxConnect()\fP 
.RE
.PP

.PP
References \fBredisxIsConnected()\fP, \fBrSetServerAsync()\fP, \fBX_ALREADY_OPEN\fP, \fBx_error()\fP, \fBX_FAILURE\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetMutualTLS (\fBRedis\fP * redis, const char * cert_file, const char * key_file)"
Set a TLS certificate and private key for mutual TLS\&. You will still need to call \fBredisxSetTLS()\fP also to create a complete TLS configuration\&. \fBRedis\fP normally uses mutual TLS, which requires both the client and the server to authenticate themselves\&. For this you need the server's TLS certificate and private key also\&. It is possible to configure \fBRedis\fP servers to verify one way only with a CA certificate, in which case you don't need to call this to configure the client\&.
.PP
To disable mutual TLS, set both file name arguments to NULL\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP A \fBRedis\fP instance\&. 
.br
\fIcert_file\fP Path to the server's certificate file\&. 
.br
\fIkey_file\fP Path to the server'sprivate key file\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else an error code <0\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetTLS()\fP 
.RE
.PP

.PP
References \fBx_error()\fP, \fBX_FAILURE\fP, \fBX_NULL\fP, \fBX_SUCCESS\fP, and \fBxStringCopyOf()\fP\&.
.SS "int redisxSetPassword (\fBRedis\fP * redis, const char * passwd)"
Sets the password to use for authenticating on the \fBRedis\fP server after connection\&. See the AUTH \fBRedis\fP command for more explanation\&. Naturally, you need to call this prior to connecting your \fBRedis\fP instance to have the desired effect\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to the \fBRedis\fP instance for which to set credentials 
.br
\fIpasswd\fP the password to use for authenticating on the server, or NULL to clear a previously configured password\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, X_NULL if the redis argument is NULL, or X_ALREADY_OPEN if called after \fBRedis\fP was already connected\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetUser()\fP 
.RE
.PP

.PP
References \fBredisxIsConnected()\fP, \fBX_ALREADY_OPEN\fP, \fBx_error()\fP, \fBX_SUCCESS\fP, and \fBxStringCopyOf()\fP\&.
.SS "int redisxSetPipelineConsumer (\fBRedis\fP * redis, \fBRedisPipelineProcessor\fP f)"
Sets the function processing valid pipeline responses\&. The implementation should follow a simple set of rules:
.PP
.PD 0
.IP "\(bu" 2
the implementation should not destroy the \fBRESP\fP data\&. The \fBRESP\fP will be destroyed automatically after the call returns\&. However, the call may retain any data from the \fBRESP\fP itself, provided the data is de-referenced from the \fBRESP\fP before return\&.
.IP "\(bu" 2

.IP "\(bu" 2
The implementation should not block (aside from maybe a quick mutex unlock) and return quickly, so as to not block the client for long periods 
.IP "\(bu" 2
If extensive processing or blocking calls are required to process the message, it is best to simply place a copy of the \fBRESP\fP on a queue and then return quickly, and then process the message asynchronously in a background thread\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIf\fP The function that processes a single argument of type \fBRESP\fP pointer\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or X_NULL if the \fBRedis\fP instance is NULL\&. 
.RE
.PP

.PP
References \fBX_SUCCESS\fP\&.
.SS "int redisxSetPort (\fBRedis\fP * redis, int port)"
Sets a non-standard TCP port number to use for the \fBRedis\fP server, prior to calling \fC\fBredisxConnect()\fP\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIport\fP The TCP port number to use\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else X_NULL if the redis instance is NULL, or X_NO_INIT if the redis instance is not initialized, X_ALREADY_OPEN if the \fBRedis\fP instance is lready connected to a server, or X_FAILURE if \fBRedis\fP was initialized in Sentinel configuration\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetHostname()\fP 
.PP
\fBredisxConnect()\fP 
.RE
.PP

.PP
References \fBredisxIsConnected()\fP, \fBX_ALREADY_OPEN\fP, \fBx_error()\fP, \fBX_FAILURE\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetProtocol (\fBRedis\fP * redis, enum \fBredisx_protocol\fP protocol)"
Sets the \fBRESP\fP prorocol version to use for future client connections\&. The protocol is set with the HELLO command, which was introduced in \fBRedis\fP 6\&.0\&.0 only\&. For older \fBRedis\fP server instances, the protocol will default to RESP2\&. Calling this function will enable using HELLO to handshake with the server\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP The \fBRedis\fP server instance 
.br
\fIprotocol\fP REDISX_RESP2 or REDISX_RESP3\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or X_NULL if the redis argument in NULL, X_NO_INIT if the redis instance was not initialized\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxGetProtocol()\fP 
.PP
redisxGetHelloReply() 
.RE
.PP

.PP
References \fBTRUE\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetPushProcessor (\fBRedis\fP * redis, \fBRedisPushProcessor\fP func, void * arg)"
Sets a user-defined function to process push messages for a specific \fBRedis\fP instance\&. The function's implementation must follow a simple set of rules:
.PP
.PD 0
.IP "\(bu" 2
the implementation should not destroy the \fBRESP\fP data\&. The \fBRESP\fP will be destroyed automatically after the call returns\&. However, the call may retain any data from the \fBRESP\fP itself, provided the data is de-referenced from the \fBRESP\fP before return\&.
.IP "\(bu" 2

.IP "\(bu" 2
The call will have exclusive access to the client\&. As such it should not try to obtain a lock or release the lock itself\&. 
.IP "\(bu" 2
The implementation should not block (aside from maybe a quick mutex unlock) and return quickly, so as to not block the client for long periods 
.IP "\(bu" 2
If extensive processing or blocking calls are required to process the message, it is best to simply place a copy of the \fBRESP\fP on a queue and then return quickly, and then process the message asynchronously in a background thread\&. 
.IP "\(bu" 2
The client on which the push is originated will be locked, thus the implementation should avoid getting explusive access to the client 
.PP
.PP
\fBParameters\fP
.RS 4
\fIredis\fP \fBRedis\fP instance 
.br
\fIfunc\fP Function to use for processing push messages from the given \fBRedis\fP instance, or NULL to ignore push messages\&. 
.br
\fIarg\fP (optional) User-defined pointer argument to pass along to the processing function\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else X_NULL (errno set to EINVAL) if the client argument is NULL, or X_NO_INIT (errno set to EAGAIN) if redis is uninitialized\&. 
.RE
.PP

.PP
References \fBX_SUCCESS\fP\&.
.SS "int redisxSetReplyTimeout (\fBRedis\fP * redis, int timeoutMillis)"
Set a timeout for getting replies on the interactive client\&. This does not affect the pipeline and subscription clients, which do not have a timeout (appropriately for asynchronous processing)
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fItimeoutMillis\fP [ms] timeout for interactive responses, or <0 for indefinite\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetSocketTimeout()\fP 
.RE
.PP

.PP
References \fBRedis::interactive\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetScanCount (\fBRedis\fP * redis, int count)"
Sets the COUNT parameter to use with \fBRedis\fP SCAN type commands\&. COUNT specifies how much work \fBRedis\fP should do in a single scan iteration\&. 0 (or negative) values can be used to scan with defaults (without the COUNT option), which is usually equivalent to COUNT=10\&. When scanning large datasets, it may take many scan calls to go through all the data\&. When networking has limited bandwidth, or large latencies it may be desirable to do more work per call on the server side to reduce traffic\&. However, the cost of larger COUNT values is that it may increase server latencies for other queries\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIcount\fP The new COUNT to use for SCAN-type commands or <0 to use default\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxGetScanCount()\fP 
.PP
\fBredisxScanKeys()\fP 
.PP
\fBredisxScanTable()\fP 
.RE
.PP

.PP
References \fBX_SUCCESS\fP\&.
.SS "int redisxSetSentinelTimeout (\fBRedis\fP * redis, int millis)"
Changes the connection timeout for Sentinel server instances in the discovery phase\&. This is different from the timeout that is used for the master server, once it is discovered\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP The \fBRedis\fP instance, which was initialized for Sentinel via \fBredisxInitSentinel()\fP\&. 
.br
\fImillis\fP [ms] The new connection timeout or <=0 to use the default value\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successfully set sentinel connection timeout, or else X_NULL if the redis instance is NULL, or X_NO_INIT if the redis instance is not initialized for Sentinel\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetSocketTimeout()\fP 
.PP
\fBredisxInitSentinel()\fP 
.RE
.PP

.PP
References \fBREDISX_DEFAULT_SENTINEL_TIMEOUT_MILLIS\fP, \fBx_error()\fP, \fBX_NO_INIT\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetSocketConfigurator (\fBRedis\fP * redis, \fBRedisSocketConfigurator\fP func)"
Sets a user-defined callback for additioan custom configuring of client sockets
.PP
\fBParameters\fP
.RS 4
\fIredis\fP The \fBRedis\fP server instance 
.br
\fIfunc\fP The user-defined callback function, which performs the additional socket configuration 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or or X_NULL (errno = EINVAL) if the redis argument in NULL, X_NO_INIT (errno = ENXIO) if the redis instance was not initialized\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetSocketErrorHandler()\fP 
.RE
.PP

.PP
References \fBTRUE\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetSocketErrorHandler (\fBRedis\fP * redis, \fBRedisErrorHandler\fP f)"
Sets the user-specific error handler to call if a socket level trasmit error occurs\&. It replaces any prior handlers set earlier\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP The \fBRedis\fP instance to configure\&. 
.br
\fIf\fP The error handler function, which is called with the pointer to the redis instance that had the errror, the redis channel index (e\&.g\&. REDIS_INTERACTIVE_CHANNEL) and the operation (e\&.g\&. 'send' or 'read') that failed\&. Note, that the call may be made with the affected \fBRedis\fP channel being in a locked state\&. As such the handler should not directly attempt to change the connection state of the \fBRedis\fP instance\&. Any calls that require exlusive access to the affected channel should instead be spawn off into a separate thread, which can obtain the necessary lock when it is released\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS if the handler was successfully configured, or X_NULL if the \fBRedis\fP instance is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetSocketConfigurator()\fP 
.RE
.PP

.PP
References \fBX_SUCCESS\fP\&.
.SS "int redisxSetSocketTimeout (\fBRedis\fP * redis, int millis)"
Sets a socket timeout for future client connections on a \fBRedis\fP instance\&. Effectively this is a timeout for send() only\&. The timeout for interatvice replies is controlled separately via redisxSetReplyTimoeut()\&.
.PP
If not set (or set to zero or a negative value), then the timeout will not be configured for sockets, and the system default timeout values will apply\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP The \fBRedis\fP instance 
.br
\fImillis\fP [ms] The desired socket read/write timeout, or <0 for socket default\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else X_NULL if the redis instance is NULL, or X_NO_INIT if the redis instance is not initialized\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetReplyTimeout()\fP 
.RE
.PP

.PP
References \fBREDISX_DEFAULT_TIMEOUT_MILLIS\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetTcpBuf (\fBRedis\fP * redis, int size)"
Set the size of the TCP/IP buffers (send and receive) for future client connections\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIsize\fP (bytes) requested buffer size, or <= 0 to use default value 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else X_NULL if the redis instance is NULL, or X_NO_INIT if the redis instance is not initialized, or X_FAILURE if \fBRedis\fP was initialized in Sentinel configuration\&. 
.RE
.PP

.PP
References \fBX_SUCCESS\fP\&.
.SS "int redisxSetTLS (\fBRedis\fP * redis, const char * ca_path, const char * ca_file)"
Configures a TLS-encrypted connection to \fBRedis\fP with the specified CA certificate file\&. Normally you will want to set up mutual TLS with \fBredisxSetMutualTLS()\fP also, unless the server is not requiring mutual authentication\&. Additionally, you might also want to set parameters for DH-based cyphers if needed using redisxSetDHCypherParams()\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP A \fBRedis\fP instance\&. 
.br
\fIca_path\fP Directory containing CA certificates\&. It may be NULL to use the default locations\&. 
.br
\fIca_file\fP CA certificate file relative to specified directory\&. It may be NULL to use default certificate\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else an error code <0\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetMutualTLS()\fP 
.PP
\fBredisxSetDHCipherParams()\fP 
.PP
\fBredisxSetTLSCiphers()\fP 
.PP
\fBredisxSetTLSCipherSuites()\fP 
.PP
\fBredisxSetTLSServerName()\fP 
.PP
\fBredisxSetTLSVerify()\fP 
.RE
.PP

.PP
References \fBTRUE\fP, \fBx_error()\fP, \fBX_FAILURE\fP, \fBX_SUCCESS\fP, and \fBxStringCopyOf()\fP\&.
.SS "int redisxSetTLSCiphers (\fBRedis\fP * redis, const char * cipher_list)"
Sets the TLS ciphers to try (TLSv1\&.2 and earlier)\&. This function will return an error (-1) if RedisX is built against OpenSSL >= 1\&.1\&.1, for which \fC\fBredisxSetTLSCipherSuites()\fP\fP should be used instead\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP A \fBRedis\fP instance\&. 
.br
\fIcipher_list\fP a colon (:) separated list of ciphers, or NULL for default ciphers\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else an error code <0\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetTLSCipherSuites()\fP 
.PP
\fBredisxSetTLS()\fP 
.PP
\fBredisxSetDHCipherParams()\fP
.RE
.PP
\fBDeprecated\fP
.RS 4
For OpenSSL >= 1\&.1\&.1, \fC\fBredisxSetTLSCipherSuites()\fP\fP should be used instead\&. 
.RE
.PP

.PP
References \fBx_error()\fP, \fBX_FAILURE\fP, \fBX_SUCCESS\fP, and \fBxStringCopyOf()\fP\&.
.SS "int redisxSetTLSCipherSuites (\fBRedis\fP * redis, const char * list)"
Sets the TLS ciphers suites to try (TLSv1\&.3 and later)\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP A \fBRedis\fP instance\&. 
.br
\fIlist\fP a colon (:) separated list of cipher suites, or NULL for default cipher suites\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else an error code <0\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetTLSCiphers()\fP 
.PP
\fBredisxSetTLS()\fP 
.PP
\fBredisxSetDHCipherParams()\fP 
.RE
.PP

.PP
References \fBx_error()\fP, \fBX_FAILURE\fP, \fBX_SUCCESS\fP, and \fBxStringCopyOf()\fP\&.
.SS "int redisxSetTLSServerName (\fBRedis\fP * redis, const char * host)"
Sets the Server name for TLS Server Name Indication (SNI), an optional extra later of security\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP A \fBRedis\fP instance\&. 
.br
\fIhost\fP server name to use for SNI\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0)
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetTLS()\fP 
.RE
.PP

.PP
References \fBx_error()\fP, \fBX_FAILURE\fP, \fBX_SUCCESS\fP, and \fBxStringCopyOf()\fP\&.
.SS "int redisxSetTLSVerify (\fBRedis\fP * redis, \fBboolean\fP value)"
Sets whether to verify the the certificate\&. Certificates are verified by default\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP A \fBRedis\fP instance\&. 
.br
\fIvalue\fP TRUE (non-zero) to verify certificates, or else FALSE (0) 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0)
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetTLS()\fP 
.RE
.PP

.PP
References \fBx_error()\fP, \fBX_FAILURE\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetUser (\fBRedis\fP * redis, const char * username)"
Sets the user name to use for authenticating on the \fBRedis\fP server after connection\&. See the \fCAUTH\fP \fBRedis\fP command for more explanation\&. Naturally, you need to call this prior to connecting your \fBRedis\fP instance to have the desired effect\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to the \fBRedis\fP instance for which to set credentials 
.br
\fIusername\fP the password to use for authenticating on the server, or NULL to clear a previously configured password\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, X_NULL if the redis argument is NULL, or X_ALREADY_OPEN if called after \fBRedis\fP was already connected\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetPassword()\fP 
.RE
.PP

.PP
References \fBredisxIsConnected()\fP, \fBX_ALREADY_OPEN\fP, \fBx_error()\fP, \fBX_SUCCESS\fP, and \fBxStringCopyOf()\fP\&.
.SS "int redisxSetValue (\fBRedis\fP * redis, const char * table, const char * key, const char * value, \fBboolean\fP confirm)"
Sets a global or hashtable value on \fBRedis\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fItable\fP Hash table identifier or NULL if setting a global value\&. 
.br
\fIkey\fP \fBRedis\fP field name (i\&.e\&. variable name)\&. 
.br
\fIvalue\fP A proper 0-terminated string value to store\&. 
.br
\fIconfirm\fP Whether we should get a confirmation from the server (requires a round-trip)\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if the variable was succesfully set, or: X_NO_INIT X_NAME_INVALID X_NULL X_NO_SERVICE X_FAILURE 
.RE
.PP

.PP
References \fBFALSE\fP, \fBRedis::interactive\fP, \fBredisxCheckRESP()\fP, \fBredisxDestroyRESP()\fP, \fBredisxLockConnected()\fP, \fBredisxRequest()\fP, \fBredisxSetValueAsync()\fP, \fBredisxUnlockClient()\fP, \fBRESP_INT\fP, \fBx_error()\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetValueAsync (\fBRedisClient\fP * cl, const char * table, const char * key, const char * value, \fBboolean\fP confirm)"
Sends a request for setting a table value, using the \fBRedis\fP 'SET' or 'HSET' command\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to a \fBRedis\fP channel\&. 
.br
\fItable\fP Hashtable from which to retrieve a value or NULL if to use the global table\&. 
.br
\fIkey\fP Field name (i\&.e\&. variable name)\&. 
.br
\fIvalue\fP The string value to set (assumes normal string termination)\&.' 
.br
\fIconfirm\fP Whether confirmation is requested from \fBRedis\fP to acknowledge\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or X_NULL if the client or value is NULL X_NAME_INVALID if key is invalid, or an error (<0) returned by \fBredisxSendRequestAsync()\fP\&. 
.RE
.PP

.PP
References \fBredisxSendRequestAsync()\fP, \fBredisxSkipReplyAsync()\fP, \fBx_error()\fP, \fBX_NAME_INVALID\fP, \fBX_NULL\fP, \fBX_SUCCESS\fP, and \fBxvprintf\fP\&.
.SS "void redisxSetVerbose (\fBboolean\fP value)"
Enable or disable verbose reporting of all \fBRedis\fP operations (and possibly some details of them)\&. Reporting is done on the standard output (stdout)\&. It may be useful when debugging programs that use the redisx interface\&. Verbose reporting is DISABLED by default\&.
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP TRUE to enable verbose reporting, or FALSE to disable\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxDebugTraffic()\fP 
.RE
.PP

.PP
References \fBxSetVerbose()\fP\&.
.SS "int redisxSkipReplyAsync (\fBRedisClient\fP * cl)"
Instructs \fBRedis\fP to skip sending a reply for the next command\&. This function should be called with an exclusive lock on a connected client, and just before redisxSendRequest() or \fBredisxSendArrayRequestAsync()\fP\&.
.PP
Sends \fCCLIENT REPLY SKIP\fP
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to the \fBRedis\fP client to use\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) on success or X_NULL if the client is NULL, or else X_NO_SERVICE if not connected to the \fBRedis\fP server on the requested channel, or if send() failed, or else X_NO_INIT if the client was not initialized\&.
.RE
.PP
\fBSee also\fP
.RS 4
redixSendRequestAsync() 
.PP
\fBredisxSendArrayRequestAsync()\fP 
.PP
redisxGetLockedConnected() 
.RE
.PP

.PP
References \fBTRUE\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSplitText (\fBRESP\fP * resp, char ** text)"
Splits the string value of a \fBRESP\fP into two components, by terminating the first component with a null byte and optionally returning the remaining part and length in the output parameters\&. Only RESP_ERROR RESP_BLOB_ERROR and RESP_VERBATIM_STRING types can be split this way\&. All others will return REDIS_UNEXPECTED_RESP\&.
.PP
\fBParameters\fP
.RS 4
\fIresp\fP The input \fBRESP\fP\&. 
.br
\fItext\fP (optional) pointer in which to return the start of the remnant text component\&. 
.RE
.PP
\fBReturns\fP
.RS 4
n the length of the remnant text (<=0), or else X_NULL if the input \fBRESP\fP was NULL, or REDIS_UNEXPEXCTED_RESP if the input \fBRESP\fP does not contain a two-component string value\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBRESP_ERROR\fP 
.PP
\fBRESP3_BLOB_ERROR\fP 
.PP
\fBRESP3_VERBATIM_STRING\fP 
.RE
.PP

.PP
References \fBRESP::n\fP, \fBREDIS_UNEXPECTED_RESP\fP, \fBRESP3_BLOB_ERROR\fP, \fBRESP3_VERBATIM_STRING\fP, \fBRESP_ERROR\fP, \fBRESP::type\fP, \fBRESP::value\fP, \fBx_error()\fP, \fBX_NULL\fP, and \fBX_PARSE_ERROR\fP\&.
.SS "int redisxStartBlockAsync (\fBRedisClient\fP * cl)"
Starts an atomic \fBRedis\fP transaction block, by sending \fCMULTI\fP on the specified client connection\&. This function should be called with an exclusive lock on a connected client\&.
.PP
\fBRedis\fP transaction blocks behave just like scripts (in fact they are effectively improptu scripts themselves)\&. As such the rules of \fBRedis\fP scripting apply, such as you cannot call LUA from within a transaction block (which is a real pity\&.\&.\&.)
.PP
Once you start a transaction block you may ignore all acknowledgedments such as \fCOK\fP and \fCQUEUED\fP responses that \fBRedis\fP sends back\&. These will be 'processed' in bulk by redisEndBlockAsync(), at the end of the transaction block\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to a \fBRedis\fP client\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or X_NULL if the \fBRedis\fP client is NULL, or X_NO_SERVICE if not connected to the client server or if send() failed, or X_NO_INIT if the client was not initialized\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxExecBlockAsync()\fP 
.PP
\fBredisxAbortBlockAsync()\fP 
.PP
redisxGetLockedConnected() 
.RE
.PP

.PP
References \fBTRUE\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSubscribe (\fBRedis\fP * redis, const char * pattern)"
Subscribe to a specific \fBRedis\fP channel\&. The call will also start the subscription listener thread to processing incoming subscription messages\&. Subscribing only enabled the delivery of the messages to this client without any actions on these messages\&. In order to process the messages for your subscriptons, you will also want to call \fBredisxAddSubscriber()\fP to add your custom processor function(s)\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIpattern\fP The Channel pattern to subscribe to, e\&.g\&. 'acc1', or 'acc*'\&.\&.\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS if successfully subscribed to the \fBRedis\fP distribution channel\&. X_NO_SERVICE if there is no active connection to the \fBRedis\fP server\&. X_NULL if the channel argument is NULL
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxAddSubscriber()\fP 
.PP
\fBredisxUnsubscribe()\fP 
.PP
\fBredisxNotify()\fP 
.PP
\fBredisxPublish()\fP 
.PP
\fBredisxPublishAsync()\fP 
.RE
.PP

.PP
References \fBredisxIsGlobPattern()\fP, \fBredisxLockConnected()\fP, \fBredisxSendRequestAsync()\fP, \fBredisxUnlockClient()\fP, \fBRedis::subscription\fP, \fBx_error()\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxUnlockClient (\fBRedisClient\fP * cl)"
Relinquish exclusive write access to the specified \fBRedis\fP channel
.PP
\fBParameters\fP
.RS 4
\fIcl\fP Pointer to the \fBRedis\fP client instance
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS if the exclusive lock for the channel was successfully obtained, or X_FAILURE if pthread_mutex_lock() returned an error, or X_NULL if the client is NULL, or X_NO_INIT if the client was not initialized\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxLockClient()\fP 
.PP
\fBredisxLockConnected()\fP 
.RE
.PP

.PP
References \fBx_error()\fP, \fBX_FAILURE\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxUnsubscribe (\fBRedis\fP * redis, const char * pattern)"
Unsubscribe from one or all \fBRedis\fP PUB/SUB channel(s)\&. If there are no active subscriptions when \fBRedis\fP confirms the unsubscrive command, the subscription listener thread will also conclude automatically\&. Unsubscribing will stop delivery of mesasages for the affected channels but any associated processing callbacks remain registered, until redisxRemovesubscribers() is called to deactive them as appropriate\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIpattern\fP The channel pattern, or NULL to unsubscribe all channels and patterns\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS if successfully subscribed to the \fBRedis\fP distribution channel\&. X_NO_SERVICE if there is no active connection to the \fBRedis\fP server\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSubscribe()\fP 
.PP
redisxEndSubscribe() 
.PP
\fBredisxRemoveSubscribers()\fP 
.RE
.PP

.PP
References \fBredisxCheckValid()\fP, \fBredisxIsGlobPattern()\fP, \fBredisxLockConnected()\fP, \fBredisxSendRequestAsync()\fP, \fBredisxUnlockClient()\fP, \fBRedis::subscription\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxValidateSentinel (const char * serviceName, const \fBRedisServer\fP * serverList, int nServers)"
Validates a Sentinel configuration\&.
.PP
\fBParameters\fP
.RS 4
\fIserviceName\fP The service name as registered in the Sentinel server configuration\&. 
.br
\fIserverList\fP An set of Sentinel servers to use to dynamically find the current master\&. 
.br
\fInServers\fP The number of servers in the list 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or X_NAME_INVALID if the serviceName is NULL or empty, or X_NULL if the serverList is NULL, or X_SIZE_INVALID if nServers is 0 or negative, or else X_GROUP_INVALID if the first server has a NULL or empty host name\&. 
.RE
.PP

.PP
References \fBx_error()\fP, \fBX_GROUP_INVALID\fP, \fBX_NAME_INVALID\fP, \fBX_NULL\fP, \fBX_SIZE_INVALID\fP, and \fBX_SUCCESS\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for RedisX from the source code\&.
