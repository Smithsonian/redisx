.TH "src/redisx.c" 3 "Version v0.9" "RedisX" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/redisx.c \- A \fBRedis\fP client library that compiles on older and newer platforms alike, such as LynxOS 3\&.1\&.0 PowerPCs\&. It is quite full featured, supporting multiple \fBRedis\fP instances, pipelining, user-specified connect and disconnect hooks, multiple user-specified subscription listeners, and user-specified pipeline processors\&.  

.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBXLookupTable\fP * \fBrConsumeInfoReply\fP (\fBRESP\fP *reply)"
.br
.ti -1c
.RI "\fBRESP\fP * \fBredisxArrayRequest\fP (\fBRedis\fP *redis, const char **args, const int *lengths, int n, int *status)"
.br
.ti -1c
.RI "int \fBredisxCheckValid\fP (const \fBRedis\fP *redis)"
.br
.ti -1c
.RI "void \fBredisxDebugTraffic\fP (\fBboolean\fP value)"
.br
.ti -1c
.RI "int \fBredisxError\fP (const char *func, int errorCode)"
.br
.ti -1c
.RI "const char * \fBredisxErrorDescription\fP (int code)"
.br
.ti -1c
.RI "\fBRESP\fP * \fBredisxGetAttributes\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "\fBRESP\fP * \fBredisxGetHelloData\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "\fBXLookupTable\fP * \fBredisxGetInfo\fP (\fBRedis\fP *redis, const char *parameter)"
.br
.ti -1c
.RI "enum \fBredisx_protocol\fP \fBredisxGetProtocol\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "int \fBredisxGetTime\fP (\fBRedis\fP *redis, struct timespec *t)"
.br
.ti -1c
.RI "\fBboolean\fP \fBredisxHasPipeline\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "int \fBredisxIsGlobPattern\fP (const char *str)"
.br
.ti -1c
.RI "\fBboolean\fP \fBredisxIsVerbose\fP ()"
.br
.ti -1c
.RI "int \fBredisxPing\fP (\fBRedis\fP *redis, const char *message)"
.br
.ti -1c
.RI "\fBRESP\fP * \fBredisxRequest\fP (\fBRedis\fP *redis, const char *command, const char *arg1, const char *arg2, const char *arg3, int *status)"
.br
.ti -1c
.RI "int \fBredisxSelectDB\fP (\fBRedis\fP *redis, int idx)"
.br
.ti -1c
.RI "int \fBredisxSetPassword\fP (\fBRedis\fP *redis, const char *passwd)"
.br
.ti -1c
.RI "int \fBredisxSetPipelineConsumer\fP (\fBRedis\fP *redis, \fBRedisPipelineProcessor\fP f)"
.br
.ti -1c
.RI "int \fBredisxSetProtocol\fP (\fBRedis\fP *redis, enum \fBredisx_protocol\fP protocol)"
.br
.ti -1c
.RI "int \fBredisxSetPushProcessor\fP (\fBRedis\fP *redis, \fBRedisPushProcessor\fP func, void *arg)"
.br
.ti -1c
.RI "int \fBredisxSetReplyTimeout\fP (\fBRedis\fP *redis, int timeoutMillis)"
.br
.ti -1c
.RI "int \fBredisxSetSocketConfigurator\fP (\fBRedis\fP *redis, \fBRedisSocketConfigurator\fP func)"
.br
.ti -1c
.RI "int \fBredisxSetSocketErrorHandler\fP (\fBRedis\fP *redis, \fBRedisErrorHandler\fP f)"
.br
.ti -1c
.RI "int \fBredisxSetUser\fP (\fBRedis\fP *redis, const char *username)"
.br
.ti -1c
.RI "void \fBredisxSetVerbose\fP (\fBboolean\fP value)"
.br
.in -1c
.SH "Detailed Description"
.PP 
A \fBRedis\fP client library that compiles on older and newer platforms alike, such as LynxOS 3\&.1\&.0 PowerPCs\&. It is quite full featured, supporting multiple \fBRedis\fP instances, pipelining, user-specified connect and disconnect hooks, multiple user-specified subscription listeners, and user-specified pipeline processors\&. 


.PP
\fBDate\fP
.RS 4
May 4, 2018 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "\fBXLookupTable\fP * rConsumeInfoReply (\fBRESP\fP * reply)"
Extract key/value pairs from the bulk string response to an \fCINFO\fP query\&.
.PP
\fBParameters\fP
.RS 4
\fIreply\fP The response to an \fCINFO\fP query 
.RE
.PP
\fBReturns\fP
.RS 4
An allocated lookup table containing the key/value pairs extracted 
.RE
.PP

.PP
References \fBFALSE\fP, \fBredisxCheckDestroyRESP()\fP, \fBredisxDestroyRESP()\fP, \fBRESP_BULK_STRING\fP, \fBRESP::value\fP, \fBx_trace_null()\fP, \fBxCreateLookup()\fP, \fBxCreateStringField()\fP, \fBxCreateStruct()\fP, and \fBxSetField()\fP\&.
.SS "\fBRESP\fP * redisxArrayRequest (\fBRedis\fP * redis, const char ** args, const int * lengths, int n, int * status)"
Returns the result of the most generic type of \fBRedis\fP request with any number of arguments\&. This is not the highest throughput mode (that would be sending asynchronous pipeline request, and then asynchronously collecting the results such as with \fBredisxSendArrayRequestAsync()\fP / \fBredisxReadReplyAsync()\fP, because it requires separate network roundtrips for each and every request\&. But, it is simple and perfectly good method when one needs to retrieve only a few (<1000) variables per second\&.\&.\&.
.PP
This is the base interactive query, which is used by all sorts of other interactive transactions\&. It handles \fCMOVED\fP and \fCASK\fP redirections for \fBRedis\fP clusters automatically and transparently, so long as the target node is a known member of the cluster from before or immediately after the migration message was received\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIargs\fP An array of strings to send to \fBRedis\fP, corresponding to a single query\&. If you have an \fCchar **\fP array, you may need to cast to \fC(const char **)\fP to avoid compiler warnings\&. 
.br
\fIlengths\fP Array indicating the number of bytes to send from each string argument\&. Zero values can be used to determine the string length automatically using strlen(), and the length argument itself may be NULL to determine the lengths of all string arguments automatically\&. 
.br
\fIn\fP Number of string arguments\&. 
.br
\fIstatus\fP Pointer to the return error status\&. If not NULL, it will be populated with one of: 
.PP
.nf
                 X_SUCCESS       on success\&.
                 X_NO_INIT       if the Redis client library was not initialized via redisxInit()\&.
                 X_NULL          if the argument is NULL or n<1\&.
                 X_TIMEDOUT      if the reading of the response timed out\&.
                 X_NO_SERVICE    if not connected to Redis\&.
                 X_FAILURE       If there was a socket level error\&.

.fi
.PP
.RE
.PP
\fBReturns\fP
.RS 4
A freshly allocated \fBRESP\fP array containing the \fBRedis\fP response, or NULL if no valid response could be obtained\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxRequest()\fP 
.PP
\fBredisxSendArrayRequestAsync()\fP 
.PP
\fBredisxReadReplyAsync()\fP 
.RE
.PP

.PP
References \fBRedis::interactive\fP, \fBredisxArrayRequest()\fP, \fBredisxCheckValid()\fP, \fBredisxClearAttributesAsync()\fP, \fBredisxClusterAskMigrating()\fP, \fBredisxClusterGetRedirection()\fP, \fBredisxClusterIsMigrating()\fP, \fBredisxClusterIsRedirected()\fP, \fBredisxLockConnected()\fP, \fBredisxReadReplyAsync()\fP, \fBredisxSendArrayRequestAsync()\fP, \fBredisxUnlockClient()\fP, \fBx_error()\fP, \fBX_NULL\fP, \fBX_SUCCESS\fP, and \fBx_trace_null()\fP\&.
.SS "int redisxCheckValid (const \fBRedis\fP * redis)"
Checks that a redis instance is valid\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP The \fBRedis\fP instance 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if the instance is valid, or X_NULL if the argument is NULL (errno = EINVAL), or else X_NO_INIT (errno = ENXIO) if the redis instance is not initialized\&. 
.RE
.PP

.PP
References \fBx_error()\fP, \fBX_NO_INIT\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "void redisxDebugTraffic (\fBboolean\fP value)"
Enable or disable verbose reporting of all \fBRedis\fP bound traffic\&. It may be useful when debugging programs that use the redisx interface\&. Verbose reporting is DISABLED by default\&.
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP TRUE to enable verbose reporting, or FALSE to disable\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetVerbose()\fP 
.RE
.PP

.PP
References \fBFALSE\fP, and \fBTRUE\fP\&.
.SS "int redisxError (const char * func, int errorCode)"
Prints a descriptive error message to stderr, and returns the error code\&.
.PP
\fBParameters\fP
.RS 4
\fIfunc\fP A string that describes the function or location where the error occurred\&. 
.br
\fIerrorCode\fP The error code that describes the failure\&.
.RE
.PP
\fBReturns\fP
.RS 4
the error code\&. 
.RE
.PP

.PP
References \fBMAX_DEBUG_ERROR_COUNT\fP, \fBREDIS_INCOMPLETE_TRANSFER\fP, \fBredisxErrorDescription()\fP, and \fBxDebug\fP\&.
.SS "const char * redisxErrorDescription (int code)"
Returns a string description for one of the RM error codes\&.
.PP
\fBParameters\fP
.RS 4
\fIcode\fP One of the error codes defined in 'rm\&.h' or in 'redisrm\&.h' (e\&.g\&. X_NO_PIPELINE)
.RE
.PP
\fBReturns\fP
.RS 4
A constant string with the error description\&. 
.RE
.PP

.PP
References \fBREDIS_ERROR\fP, \fBREDIS_INCOMPLETE_TRANSFER\fP, \fBREDIS_INVALID_CHANNEL\fP, \fBREDIS_NULL\fP, \fBREDIS_UNEXPECTED_ARRAY_SIZE\fP, \fBREDIS_UNEXPECTED_RESP\fP, and \fBxErrorDescription()\fP\&.
.SS "\fBRESP\fP * redisxGetAttributes (\fBRedis\fP * redis)"
Returns a copy of the attributes sent along with the last interative request\&. The user should destroy the returned \fBRESP\fP after using it by calling \fBredisxDestroyRESP()\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The attributes (if any) that were sent along with the last response on the interactive client\&.
.RE
.PP
\fBSee also\fP
.RS 4
redisxGetAttributeAsync() 
.PP
\fBredisxRequest()\fP 
.PP
\fBredisxArrayRequest()\fP 
.PP
\fBredisxDestroyRESP()\fP 
.RE
.PP

.PP
References \fBRedis::interactive\fP, \fBredisxCheckValid()\fP, \fBredisxCopyOfRESP()\fP, \fBredisxGetAttributesAsync()\fP, \fBredisxLockConnected()\fP, \fBredisxUnlockClient()\fP, \fBX_SUCCESS\fP, and \fBx_trace_null()\fP\&.
.SS "\fBRESP\fP * redisxGetHelloData (\fBRedis\fP * redis)"
Returns a copy of the \fBRESP\fP map that the \fBRedis\fP server has sent us as a response to HELLO on the last client connection, or NULL if HELLO was not used or available\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP The redis instance 
.RE
.PP
\fBReturns\fP
.RS 4
A copy of the response sent by HELLO on the last client connection, or NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetProtocol()\fP 
.PP
\fBredisxGetInfo()\fP 
.RE
.PP

.PP
References \fBredisxCopyOfRESP()\fP, and \fBx_trace_null()\fP\&.
.SS "\fBXLookupTable\fP * redisxGetInfo (\fBRedis\fP * redis, const char * parameter)"
Returns the result of an INFO query (with the optional parameter) as a lookup table of keywords and string values\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to \fBRedis\fP instance 
.br
\fIparameter\fP Optional parameter to pass with INFO, or NULL\&. 
.RE
.PP
\fBReturns\fP
.RS 4
a newly created lookup table with the string key/value pairs of the response from the \fBRedis\fP server, or NULL if there was an error\&. The caller should destroy the lookup table after using it\&.
.RE
.PP
\fBSee also\fP
.RS 4
redisxGetInfoAsync() 
.PP
\fBredisxGetHelloData()\fP 
.RE
.PP

.PP
References \fBrConsumeInfoReply()\fP, \fBredisxDestroyRESP()\fP, \fBredisxRequest()\fP, \fBX_SUCCESS\fP, and \fBx_trace_null()\fP\&.
.SS "enum \fBredisx_protocol\fP redisxGetProtocol (\fBRedis\fP * redis)"
Returns the actual protocol used with the \fBRedis\fP server\&. If HELLO was used during connection it will be the protocol that was confirmed in the response of HELLO (and which hopefully matches the protocol requested)\&. Otherwise, RedisX will default to RESP2\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP The \fBRedis\fP server instance 
.RE
.PP
\fBReturns\fP
.RS 4
REDISX_RESP2 or REDISX_RESP3, or else an error code, such as X_NULL (errno = EINVAL) if the argument is NULL, or X_NO_INIT (errno = ENXIO) if the \fBRedis\fP server instance was not initialized\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetProtocol()\fP 
.RE
.PP

.SS "int redisxGetTime (\fBRedis\fP * redis, struct timespec * t)"
Returns the current time on the \fBRedis\fP server instance\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIt\fP Pointer to a timespec structure in which to return the server time\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or X_NULL if either argument is NULL, or X_PARSE_ERROR if could not parse the response, or another error returned by \fBredisxCheckRESP()\fP\&. 
.RE
.PP

.PP
References \fBredisxCheckDestroyRESP()\fP, \fBredisxCheckRESP()\fP, \fBredisxDestroyRESP()\fP, \fBredisxRequest()\fP, \fBRESP_ARRAY\fP, \fBRESP_BULK_STRING\fP, \fBRESP::value\fP, \fBx_error()\fP, \fBX_NULL\fP, \fBX_PARSE_ERROR\fP, \fBX_SUCCESS\fP, and \fBx_trace()\fP\&.
.SS "\fBboolean\fP redisxHasPipeline (\fBRedis\fP * redis)"
Checks if a \fBRedis\fP instance has the pipeline connection enabled\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&.
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) if the pipeline client is enabled on the \fBRedis\fP intance, or FALSE (0) otherwise\&. 
.RE
.PP

.PP
References \fBRedis::pipeline\fP, \fBredisxCheckValid()\fP, \fBredisxLockClient()\fP, and \fBredisxUnlockClient()\fP\&.
.SS "int redisxIsGlobPattern (const char * str)"
Checks if a given string is a glob-style pattern\&.
.PP
\fBParameters\fP
.RS 4
\fIstr\fP The string to check\&.
.RE
.PP
\fBReturns\fP
.RS 4
TRUE if it is a glob pattern (e\&.g\&. has '*', '?' or '['), otherwise FALSE\&. 
.RE
.PP

.PP
References \fBFALSE\fP, and \fBTRUE\fP\&.
.SS "\fBboolean\fP redisxIsVerbose ()"
Checks id verbose reporting is enabled\&.
.PP
\fBReturns\fP
.RS 4
TRUE if verbose reporting is enabled, otherwise FALSE\&. 
.RE
.PP

.PP
References \fBxIsVerbose()\fP\&.
.SS "int redisxPing (\fBRedis\fP * redis, const char * message)"
Pings the \fBRedis\fP server (see the \fBRedis\fP \fCPING\fP command), and checks the response\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fImessage\fP Optional message , or NULL for \fCPING\fP without an argument\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else an error code (<0) from \fBredisx\&.h\fP / \fBxchange\&.h\fP\&. 
.RE
.PP

.PP
References \fBREDIS_UNEXPECTED_RESP\fP, \fBredisxCheckDestroyRESP()\fP, \fBredisxDestroyRESP()\fP, \fBredisxRequest()\fP, \fBRESP_BULK_STRING\fP, \fBRESP_SIMPLE_STRING\fP, \fBRESP::value\fP, \fBx_error()\fP, and \fBX_SUCCESS\fP\&.
.SS "\fBRESP\fP * redisxRequest (\fBRedis\fP * redis, const char * command, const char * arg1, const char * arg2, const char * arg3, int * status)"
Returns the result of a \fBRedis\fP command with up to 3 regularly terminated string arguments\&. This is not the highest throughput mode (that would be sending asynchronous pipeline request, and then asynchronously collecting the results such as with \fBredisxSendRequestAsync()\fP / \fBredisxReadReplyAsync()\fP, because it requires separate network roundtrips for each and every request\&. But, it is simple and perfectly good method when one needs to retrieve only a few (<1000) variables per second\&.\&.\&.
.PP
To make \fBRedis\fP calls with binary (non-string) data, you can use \fBredisxArrayRequest()\fP instead, where you can set the number of bytes for each argument explicitly\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIcommand\fP \fBRedis\fP command, e\&.g\&. 'HGET' 
.br
\fIarg1\fP First terminated string argument or NULL\&. 
.br
\fIarg2\fP Second terminated string argument or NULL\&. 
.br
\fIarg3\fP Third terminated string argument or NULL\&. 
.br
\fIstatus\fP Pointer to the return error status, which is either X_SUCCESS on success or else the error code set by \fBredisxArrayRequest()\fP\&.
.RE
.PP
\fBReturns\fP
.RS 4
A freshly allocated \fBRESP\fP array containing the \fBRedis\fP response, or NULL if no valid response could be obtained or status is not X_SUCCESS\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxArrayRequest()\fP 
.PP
\fBredisxSendRequestAsync()\fP 
.PP
\fBredisxReadReplyAsync()\fP 
.RE
.PP

.PP
References \fBredisxArrayRequest()\fP, \fBredisxDestroyRESP()\fP, \fBX_SUCCESS\fP, and \fBx_trace_null()\fP\&.
.SS "int redisxSelectDB (\fBRedis\fP * redis, int idx)"
Switches to another database index on the \fBRedis\fP server\&. Note that you cannot change the database on an active PUB/SUB channel, hence the call will return X_INCOMPLETE if attempted\&. You should instead switch DB when there are no active subscriptions\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIidx\fP zero-based database index 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or X_NULL if the redis argument is NULL, X_INCOMPLETE if there is an active subscription channel that cannot be switched or one of the channels could not confirm the switch, or else another error code (<0) from \fBredisx\&.h\fP / \fBxchange\&.h\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSelectDB()\fP 
.PP
\fBredisxLockConnected()\fP 
.RE
.PP

.PP
References \fBREDIS_INVALID_CHANNEL\fP, \fBREDISX_CHANNELS\fP, \fBREDISX_PIPELINE_CHANNEL\fP, \fBREDISX_SUBSCRIPTION_CHANNEL\fP, \fBredisxAddConnectHook()\fP, \fBredisxGetClient()\fP, \fBredisxIsConnected()\fP, \fBredisxLockConnected()\fP, \fBredisxRemoveConnectHook()\fP, \fBredisxUnlockClient()\fP, \fBX_INCOMPLETE\fP, \fBX_SUCCESS\fP, and \fBx_trace()\fP\&.
.SS "int redisxSetPassword (\fBRedis\fP * redis, const char * passwd)"
Sets the password to use for authenticating on the \fBRedis\fP server after connection\&. See the AUTH \fBRedis\fP command for more explanation\&. Naturally, you need to call this prior to connecting your \fBRedis\fP instance to have the desired effect\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to the \fBRedis\fP instance for which to set credentials 
.br
\fIpasswd\fP the password to use for authenticating on the server, or NULL to clear a previously configured password\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, X_NULL if the redis argument is NULL, or X_ALREADY_OPEN if called after \fBRedis\fP was already connected\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetUser()\fP 
.RE
.PP

.PP
References \fBredisxIsConnected()\fP, \fBX_ALREADY_OPEN\fP, \fBx_error()\fP, \fBX_SUCCESS\fP, and \fBxStringCopyOf()\fP\&.
.SS "int redisxSetPipelineConsumer (\fBRedis\fP * redis, \fBRedisPipelineProcessor\fP f)"
Sets the function processing valid pipeline responses\&. The implementation should follow a simple set of rules:
.PP
.PD 0
.IP "\(bu" 2
the implementation should not destroy the \fBRESP\fP data\&. The \fBRESP\fP will be destroyed automatically after the call returns\&. However, the call may retain any data from the \fBRESP\fP itself, provided the data is de-referenced from the \fBRESP\fP before return\&.
.IP "\(bu" 2

.IP "\(bu" 2
The implementation should not block (aside from maybe a quick mutex unlock) and return quickly, so as to not block the client for long periods 
.IP "\(bu" 2
If extensive processing or blocking calls are required to process the message, it is best to simply place a copy of the \fBRESP\fP on a queue and then return quickly, and then process the message asynchronously in a background thread\&. 
.PP
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIf\fP The function that processes a single argument of type \fBRESP\fP pointer\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or X_NULL if the \fBRedis\fP instance is NULL\&. 
.RE
.PP

.PP
References \fBX_SUCCESS\fP\&.
.SS "int redisxSetProtocol (\fBRedis\fP * redis, enum \fBredisx_protocol\fP protocol)"
Sets the \fBRESP\fP prorocol version to use for future client connections\&. The protocol is set with the HELLO command, which was introduced in \fBRedis\fP 6\&.0\&.0 only\&. For older \fBRedis\fP server instances, the protocol will default to RESP2\&. Calling this function will enable using HELLO to handshake with the server\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP The \fBRedis\fP server instance 
.br
\fIprotocol\fP REDISX_RESP2 or REDISX_RESP3\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or X_NULL if the redis argument in NULL, X_NO_INIT if the redis instance was not initialized\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxGetProtocol()\fP 
.PP
redisxGetHelloReply() 
.RE
.PP

.PP
References \fBTRUE\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetPushProcessor (\fBRedis\fP * redis, \fBRedisPushProcessor\fP func, void * arg)"
Sets a user-defined function to process push messages for a specific \fBRedis\fP instance\&. The function's implementation must follow a simple set of rules:
.PP
.PD 0
.IP "\(bu" 2
the implementation should not destroy the \fBRESP\fP data\&. The \fBRESP\fP will be destroyed automatically after the call returns\&. However, the call may retain any data from the \fBRESP\fP itself, provided the data is de-referenced from the \fBRESP\fP before return\&.
.IP "\(bu" 2

.IP "\(bu" 2
The call will have exclusive access to the client\&. As such it should not try to obtain a lock or release the lock itself\&. 
.IP "\(bu" 2
The implementation should not block (aside from maybe a quick mutex unlock) and return quickly, so as to not block the client for long periods 
.IP "\(bu" 2
If extensive processing or blocking calls are required to process the message, it is best to simply place a copy of the \fBRESP\fP on a queue and then return quickly, and then process the message asynchronously in a background thread\&. 
.IP "\(bu" 2
The client on which the push is originated will be locked, thus the implementation should avoid getting explusive access to the client 
.PP
.PP
\fBParameters\fP
.RS 4
\fIredis\fP \fBRedis\fP instance 
.br
\fIfunc\fP Function to use for processing push messages from the given \fBRedis\fP instance, or NULL to ignore push messages\&. 
.br
\fIarg\fP (optional) User-defined pointer argument to pass along to the processing function\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else X_NULL (errno set to EINVAL) if the client argument is NULL, or X_NO_INIT (errno set to EAGAIN) if redis is uninitialized\&. 
.RE
.PP

.PP
References \fBX_SUCCESS\fP\&.
.SS "int redisxSetReplyTimeout (\fBRedis\fP * redis, int timeoutMillis)"
Set a timeout for getting replies on the interactive client\&. This does not affect the pipeline and subscription clients, which do not have a timeout (appropriately for asynchronous processing)
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fItimeoutMillis\fP [ms] timeout for interactive responses, or <0 for indefinite\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetSocketTimeout()\fP 
.RE
.PP

.PP
References \fBRedis::interactive\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetSocketConfigurator (\fBRedis\fP * redis, \fBRedisSocketConfigurator\fP func)"
Sets a user-defined callback for additioan custom configuring of client sockets
.PP
\fBParameters\fP
.RS 4
\fIredis\fP The \fBRedis\fP server instance 
.br
\fIfunc\fP The user-defined callback function, which performs the additional socket configuration 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or or X_NULL (errno = EINVAL) if the redis argument in NULL, X_NO_INIT (errno = ENXIO) if the redis instance was not initialized\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetSocketErrorHandler()\fP 
.RE
.PP

.PP
References \fBTRUE\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetSocketErrorHandler (\fBRedis\fP * redis, \fBRedisErrorHandler\fP f)"
Sets the user-specific error handler to call if a socket level trasmit error occurs\&. It replaces any prior handlers set earlier\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP The \fBRedis\fP instance to configure\&. 
.br
\fIf\fP The error handler function, which is called with the pointer to the redis instance that had the errror, the redis channel index (e\&.g\&. REDIS_INTERACTIVE_CHANNEL) and the operation (e\&.g\&. 'send' or 'read') that failed\&. Note, that the call may be made with the affected \fBRedis\fP channel being in a locked state\&. As such the handler should not directly attempt to change the connection state of the \fBRedis\fP instance\&. Any calls that require exlusive access to the affected channel should instead be spawn off into a separate thread, which can obtain the necessary lock when it is released\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS if the handler was successfully configured, or X_NULL if the \fBRedis\fP instance is NULL\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetSocketConfigurator()\fP 
.RE
.PP

.PP
References \fBX_SUCCESS\fP\&.
.SS "int redisxSetUser (\fBRedis\fP * redis, const char * username)"
Sets the user name to use for authenticating on the \fBRedis\fP server after connection\&. See the \fCAUTH\fP \fBRedis\fP command for more explanation\&. Naturally, you need to call this prior to connecting your \fBRedis\fP instance to have the desired effect\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to the \fBRedis\fP instance for which to set credentials 
.br
\fIusername\fP the password to use for authenticating on the server, or NULL to clear a previously configured password\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, X_NULL if the redis argument is NULL, or X_ALREADY_OPEN if called after \fBRedis\fP was already connected\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetPassword()\fP 
.RE
.PP

.PP
References \fBredisxIsConnected()\fP, \fBX_ALREADY_OPEN\fP, \fBx_error()\fP, \fBX_SUCCESS\fP, and \fBxStringCopyOf()\fP\&.
.SS "void redisxSetVerbose (\fBboolean\fP value)"
Enable or disable verbose reporting of all \fBRedis\fP operations (and possibly some details of them)\&. Reporting is done on the standard output (stdout)\&. It may be useful when debugging programs that use the redisx interface\&. Verbose reporting is DISABLED by default\&.
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP TRUE to enable verbose reporting, or FALSE to disable\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxDebugTraffic()\fP 
.RE
.PP

.PP
References \fBxSetVerbose()\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for RedisX from the source code\&.
