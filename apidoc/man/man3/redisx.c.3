.TH "src/redisx.c" 3 "Version v0.9" "RedisX" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/redisx.c \- A \fBRedis\fP client library that compiles on older and newer platforms alike, such as LynxOS 3\&.1\&.0 PowerPCs\&. It is quite full featured, supporting multiple \fBRedis\fP instances, pipelining, user-specified connect and disconnect hooks, multiple user-specified subscription listeners, and user-specified pipeline processors\&.  

.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBRESP\fP * \fBredisxArrayRequest\fP (\fBRedis\fP *redis, char *args[], int lengths[], int n, int *status)"
.br
.ti -1c
.RI "int \fBredisxCheckDestroyRESP\fP (\fBRESP\fP *resp, char expectedType, int expectedSize)"
.br
.ti -1c
.RI "int \fBredisxCheckRESP\fP (const \fBRESP\fP *resp, char expectedType, int expectedSize)"
.br
.ti -1c
.RI "void \fBredisxDestroyRESP\fP (\fBRESP\fP *resp)"
.br
.ti -1c
.RI "int \fBredisxError\fP (const char *func, int errorCode)"
.br
.ti -1c
.RI "const char * \fBredisxErrorDescription\fP (int code)"
.br
.ti -1c
.RI "int \fBredisxGetTime\fP (\fBRedis\fP *redis, struct timespec *t)"
.br
.ti -1c
.RI "\fBboolean\fP \fBredisxHasPipeline\fP (\fBRedis\fP *redis)"
.br
.ti -1c
.RI "\fBboolean\fP \fBredisxIsVerbose\fP ()"
.br
.ti -1c
.RI "int \fBredisxLoadScript\fP (\fBRedis\fP *redis, const char *script, char **sha1)"
.br
.ti -1c
.RI "int \fBredisxPing\fP (\fBRedis\fP *redis, const char *message)"
.br
.ti -1c
.RI "\fBRESP\fP * \fBredisxRequest\fP (\fBRedis\fP *redis, const char *command, const char *arg1, const char *arg2, const char *arg3, int *status)"
.br
.ti -1c
.RI "int \fBredisxResetClient\fP (\fBRedisClient\fP *cl)"
.br
.ti -1c
.RI "int \fBredisxSelectDB\fP (\fBRedis\fP *redis, int idx)"
.br
.ti -1c
.RI "int \fBredisxSetPassword\fP (\fBRedis\fP *redis, const char *passwd)"
.br
.ti -1c
.RI "int \fBredisxSetPipelineConsumer\fP (\fBRedis\fP *redis, void(*f)(\fBRESP\fP *))"
.br
.ti -1c
.RI "int \fBredisxSetTransmitErrorHandler\fP (\fBRedis\fP *redis, \fBRedisErrorHandler\fP f)"
.br
.ti -1c
.RI "int \fBredisxSetUser\fP (\fBRedis\fP *redis, const char *username)"
.br
.ti -1c
.RI "void \fBredisxSetVerbose\fP (\fBboolean\fP value)"
.br
.in -1c
.SH "Detailed Description"
.PP 
A \fBRedis\fP client library that compiles on older and newer platforms alike, such as LynxOS 3\&.1\&.0 PowerPCs\&. It is quite full featured, supporting multiple \fBRedis\fP instances, pipelining, user-specified connect and disconnect hooks, multiple user-specified subscription listeners, and user-specified pipeline processors\&. 


.PP
\fBDate\fP
.RS 4
May 4, 2018 
.RE
.PP
\fBAuthor\fP
.RS 4
Attila Kovacs
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "\fBRESP\fP * redisxArrayRequest (\fBRedis\fP * redis, char * args[], int lengths[], int n, int * status)"
Returns the result of the most generic type of \fBRedis\fP request with any number of arguments\&. This is not the highest throughput mode (that would be sending asynchronous pipeline request, and then asynchronously collecting the results such as with \fBredisxSendArrayRequestAsync()\fP / \fBredisxReadReplyAsync()\fP, because it requires separate network roundtrips for each and every request\&. But, it is simple and perfectly good method when one needs to retrieve only a few (<1000) variables per second\&.\&.\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIargs\fP An array of strings to send to \fBRedis\fP, corresponding to a single query\&. 
.br
\fIlengths\fP Array indicating the number of bytes to send from each string argument\&. Zero values can be used to determine the string length automatically using strlen(), and the length argument itself may be NULL to determine the lengths of all string arguments automatically\&. 
.br
\fIn\fP Number of string arguments\&. 
.br
\fIstatus\fP Pointer to the return error status, which is either 
.PP
.nf
                 X_SUCCESS       on success\&.
                 X_NO_INIT       if the Redis client librarywas not initialized via initRedis\&.
                 X_NULL          if the argument is NULL or n<1\&.
                 X_NO_SERVICE    if not connected to Redis\&.
                 X_FAILURE       If there was a socket level error\&.

.fi
.PP
.RE
.PP
\fBReturns\fP
.RS 4
A freshly allocated \fBRESP\fP array containing the \fBRedis\fP response, or NULL if no valid response could be obtained\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxRequest()\fP 
.PP
\fBredisxSendArrayRequestAsync()\fP 
.PP
\fBredisxReadReplyAsync()\fP 
.RE
.PP

.PP
References \fBRedis::interactive\fP, \fBredisxError()\fP, \fBredisxLockEnabled()\fP, \fBredisxReadReplyAsync()\fP, \fBredisxSendArrayRequestAsync()\fP, \fBredisxUnlockClient()\fP, \fBX_NULL\fP, \fBX_SUCCESS\fP, and \fBxvprintf\fP\&.
.SS "int redisxCheckDestroyRESP (\fBRESP\fP * resp, char expectedType, int expectedSize)"
Like \fBredisxCheckRESP()\fP, but it also destroys the \fBRESP\fP in case of an error\&.
.PP
\fBParameters\fP
.RS 4
\fIresp\fP Pointer to the \fBRESP\fP structure from \fBRedis\fP\&. 
.br
\fIexpectedType\fP The \fBRESP\fP type expected (e\&.g\&. RESP_ARRAY) or 0 if not checking type\&. 
.br
\fIexpectedSize\fP The expected size of the \fBRESP\fP (array or bytes) or <=0 to skip checking
.RE
.PP
\fBReturns\fP
.RS 4
The return value of \fBredisxCheckRESP()\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxCheckRESP()\fP 
.RE
.PP

.PP
References \fBredisxCheckRESP()\fP, and \fBredisxDestroyRESP()\fP\&.
.SS "int redisxCheckRESP (const \fBRESP\fP * resp, char expectedType, int expectedSize)"
Checks a \fBRedis\fP \fBRESP\fP for NULL values or unexpected values\&.
.PP
\fBParameters\fP
.RS 4
\fIresp\fP Pointer to the \fBRESP\fP structure from \fBRedis\fP\&. 
.br
\fIexpectedType\fP The \fBRESP\fP type expected (e\&.g\&. RESP_ARRAY) or 0 if not checking type\&. 
.br
\fIexpectedSize\fP The expected size of the \fBRESP\fP (array or bytes) or <=0 to skip checking
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if the \fBRESP\fP passes the tests, or X_PARSE_ERROR if the \fBRESP\fP is NULL (garbled response)\&. REDIS_NULL if \fBRedis\fP returned (nil), REDIS_UNEXPECTED_TYPE if got a reply of a different type than expected REDIS_UNEXPECTED_ARRAY_SIZE if got a reply of different size than expected\&.
.RE
.PP
or the error returned in resp->n\&. 
.PP
References \fBRESP::n\fP, \fBREDIS_NULL\fP, \fBREDIS_UNEXPECTED_ARRAY_SIZE\fP, \fBREDIS_UNEXPECTED_RESP\fP, \fBRESP_INT\fP, \fBRESP::type\fP, \fBRESP::value\fP, \fBX_PARSE_ERROR\fP, and \fBX_SUCCESS\fP\&.
.SS "void redisxDestroyRESP (\fBRESP\fP * resp)"
Frees up the resources used by a \fBRESP\fP structure that was dynamically allocated\&. The call will segfault if the same \fBRESP\fP is destroyed twice or if the argument is a static allocation\&.
.PP
\fBParameters\fP
.RS 4
\fIresp\fP Pointer to the \fBRESP\fP structure to be destroyed, which may be NULL (no action taken)\&. 
.RE
.PP

.PP
References \fBRESP::n\fP, \fBredisxDestroyRESP()\fP, \fBRESP_ARRAY\fP, \fBRESP::type\fP, and \fBRESP::value\fP\&.
.SS "int redisxError (const char * func, int errorCode)"
Prints a descriptive error message to stderr, and returns the error code\&.
.PP
\fBParameters\fP
.RS 4
\fIfunc\fP A string that describes the function or location where the error occurred\&. 
.br
\fIerrorCode\fP The error code that describes the failure\&.
.RE
.PP
\fBReturns\fP
.RS 4
the error code\&. 
.RE
.PP

.PP
References \fBMAX_DEBUG_ERROR_COUNT\fP, \fBREDIS_INCOMPLETE_TRANSFER\fP, \fBredisxErrorDescription()\fP, and \fBxDebug\fP\&.
.SS "const char * redisxErrorDescription (int code)"
Returns a string description for one of the RM error codes\&.
.PP
\fBParameters\fP
.RS 4
\fIcode\fP One of the error codes defined in 'rm\&.h' or in 'redisrm\&.h' (e\&.g\&. X_NO_PIPELINE)
.RE
.PP
\fBReturns\fP
.RS 4
A constant string with the error description\&. 
.RE
.PP

.PP
References \fBREDIS_ERROR\fP, \fBREDIS_INCOMPLETE_TRANSFER\fP, \fBREDIS_INVALID_CHANNEL\fP, \fBREDIS_NULL\fP, \fBREDIS_UNEXPECTED_ARRAY_SIZE\fP, \fBREDIS_UNEXPECTED_RESP\fP, and \fBxErrorDescription()\fP\&.
.SS "int redisxGetTime (\fBRedis\fP * redis, struct timespec * t)"
Returns the current time on the \fBRedis\fP server instance\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIt\fP Pointer to a timespec structure in which to return the server time\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or X_NULL if either argument is NULL, or X_PARSE_ERROR if could not parse the response, or another error returned by \fBredisxCheckRESP()\fP\&. 
.RE
.PP

.PP
References \fBredisxCheckDestroyRESP()\fP, \fBredisxCheckRESP()\fP, \fBredisxDestroyRESP()\fP, \fBredisxError()\fP, \fBredisxRequest()\fP, \fBRESP_ARRAY\fP, \fBRESP_BULK_STRING\fP, \fBRESP::value\fP, \fBX_NULL\fP, \fBX_PARSE_ERROR\fP, and \fBX_SUCCESS\fP\&.
.SS "\fBboolean\fP redisxHasPipeline (\fBRedis\fP * redis)"
Checks if a \fBRedis\fP instance has the pipeline connection enabled\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&.
.RE
.PP
\fBReturns\fP
.RS 4
TRUE (1) if the pipeline client is enabled on the \fBRedis\fP intance, or FALSE (0) otherwise\&. 
.RE
.PP

.PP
References \fBFALSE\fP, and \fBRedis::pipeline\fP\&.
.SS "\fBboolean\fP redisxIsVerbose ()"
Checks id verbose reporting is enabled\&.
.PP
\fBReturns\fP
.RS 4
TRUE if verbose reporting is enabled, otherwise FALSE\&. 
.RE
.PP

.PP
References \fBxIsVerbose()\fP\&.
.SS "int redisxLoadScript (\fBRedis\fP * redis, const char * script, char ** sha1)"
Loads a LUA script into \fBRedis\fP, returning it's SHA1 hash to use as it's call ID\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIscript\fP String containing the full LUA script\&. 
.br
\fIsha1\fP Buffer into which SHA1 key returned by \fBRedis\fP to use as call ID\&. (It must be at least 41 bytes, and will be string terminated)\&. By default it will return an empty string\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if the script has been successfully loaded into \fBRedis\fP, or X_NULL if the \fBRedis\fP instance is NULL X_NAME_INVALID if the script is NULL or empty\&. REDIS_UNEXPECTED_RESP if received a \fBRedis\fP reponse of the wrong type,
.RE
.PP
ot an error returned by \fBredisxRequest()\fP\&. 
.PP
References \fBredisxCheckDestroyRESP()\fP, \fBredisxDestroyRESP()\fP, \fBredisxError()\fP, \fBredisxRequest()\fP, \fBRESP_BULK_STRING\fP, \fBRESP::value\fP, \fBX_NAME_INVALID\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxPing (\fBRedis\fP * redis, const char * message)"
Pings the \fBRedis\fP server (see the \fBRedis\fP \fCPING\fP command), and check the response\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fImessage\fP Optional message , or NULL for \fCPING\fP without an argument\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else an error code (<0) from \fBredisx\&.h\fP / \fBxchange\&.h\fP\&. 
.RE
.PP

.PP
References \fBREDIS_UNEXPECTED_RESP\fP, \fBredisxCheckRESP()\fP, \fBredisxDestroyRESP()\fP, \fBredisxError()\fP, \fBredisxRequest()\fP, \fBRESP_BULK_STRING\fP, \fBRESP_SIMPLE_STRING\fP, \fBRESP::value\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "\fBRESP\fP * redisxRequest (\fBRedis\fP * redis, const char * command, const char * arg1, const char * arg2, const char * arg3, int * status)"
Returns the result of a \fBRedis\fP command with up to 3 regularly terminated string arguments\&. This is not the highest throughput mode (that would be sending asynchronous pipeline request, and then asynchronously collecting the results such as with \fBredisxSendRequestAsync()\fP / \fBredisxReadReplyAsync()\fP, because it requires separate network roundtrips for each and every request\&. But, it is simple and perfectly good method when one needs to retrieve only a few (<1000) variables per second\&.\&.\&.
.PP
To make \fBRedis\fP calls with binary (non-string) data, you can use \fBredisxArrayRequest()\fP instead, where you can set the number of bytes for each argument explicitly\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIcommand\fP \fBRedis\fP command, e\&.g\&. 'HGET' 
.br
\fIarg1\fP First terminated string argument or NULL\&. 
.br
\fIarg2\fP Second terminated string argument or NULL\&. 
.br
\fIarg3\fP Third terminated string argument or NULL\&. 
.br
\fIstatus\fP Pointer to the return error status, which is either X_SUCCESS on success or else the error code set by \fBredisxArrayRequest()\fP\&.
.RE
.PP
\fBReturns\fP
.RS 4
A freshly allocated \fBRESP\fP array containing the \fBRedis\fP response, or NULL if no valid response could be obtained\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxArrayRequest()\fP 
.PP
\fBredisxSendRequestAsync()\fP 
.PP
\fBredisxReadReplyAsync()\fP 
.RE
.PP

.PP
References \fBredisxArrayRequest()\fP\&.
.SS "int redisxResetClient (\fBRedisClient\fP * cl)"
Sends a \fCRESET\fP request to the specified \fBRedis\fP client\&. The server will perform a reset as if the client disconnected and reconnected again\&.
.PP
\fBParameters\fP
.RS 4
\fIcl\fP The \fBRedis\fP client 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or else an error code (<0) from \fBredisx\&.h\fP / \fBxchange\&.h\fP\&. 
.RE
.PP

.PP
References \fBREDIS_UNEXPECTED_RESP\fP, \fBredisxCheckRESP()\fP, \fBredisxDestroyRESP()\fP, \fBredisxError()\fP, \fBredisxLockEnabled()\fP, \fBredisxReadReplyAsync()\fP, \fBredisxSendRequestAsync()\fP, \fBredisxUnlockClient()\fP, \fBRESP_SIMPLE_STRING\fP, \fBRESP::value\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSelectDB (\fBRedis\fP * redis, int idx)"
Switches to another database index on the \fBRedis\fP server\&. Note that you cannot change the database on an active PUB/SUB channel, hence the call will return X_INCOMPLETE if attempted\&. You should instead switch DB when there are no active subscriptions\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIidx\fP zero-based database index 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or X_NULL if the redis argument is NULL, X_INCOMPLETE if there is an active subscription channel that cannot be switched or one of the channels could not confirm the switch, or else another error code (<0) from \fBredisx\&.h\fP / \fBxchange\&.h\fP\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSelectDB()\fP 
.PP
\fBredisxLockEnabled()\fP 
.RE
.PP

.PP
References \fBPIPELINE_CHANNEL\fP, \fBREDIS_INVALID_CHANNEL\fP, \fBREDISX_CHANNELS\fP, \fBredisxAddConnectHook()\fP, \fBredisxError()\fP, \fBredisxGetClient()\fP, \fBredisxIsConnected()\fP, \fBredisxLockEnabled()\fP, \fBredisxRemoveConnectHook()\fP, \fBredisxUnlockClient()\fP, \fBSUBSCRIPTION_CHANNEL\fP, \fBX_INCOMPLETE\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetPassword (\fBRedis\fP * redis, const char * passwd)"
Sets the password to use for authenticating on the \fBRedis\fP server after connection\&. See the AUTH \fBRedis\fP command for more explanation\&. Naturally, you need to call this prior to connecting your \fBRedis\fP instance to have the desired effect\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to the \fBRedis\fP instance for which to set credentials 
.br
\fIpasswd\fP the password to use for authenticating on the server, or NULL to clear a previously configured password\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, X_NULL if the redis argument is NULL, or X_ALREADY_OPEN if called after \fBRedis\fP was already connected\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetUser()\fP 
.RE
.PP

.PP
References \fBredisxError()\fP, \fBredisxIsConnected()\fP, \fBX_ALREADY_OPEN\fP, \fBX_NULL\fP, \fBX_SUCCESS\fP, and \fBxStringCopyOf()\fP\&.
.SS "int redisxSetPipelineConsumer (\fBRedis\fP * redis, void(*)(\fBRESP\fP *) f)"
Sets the function processing valid pipeline responses\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to a \fBRedis\fP instance\&. 
.br
\fIf\fP T he function that processes a single argument of type \fBRESP\fP pointer\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, or X_NULL if the \fBRedis\fP instance is NULL\&. 
.RE
.PP

.PP
References \fBredisxError()\fP, \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetTransmitErrorHandler (\fBRedis\fP * redis, \fBRedisErrorHandler\fP f)"
Sets the user-specific error handler to call if a socket level trasmit error occurs\&. It replaces any prior handlers set earlier\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP The \fBRedis\fP instance to configure\&. 
.br
\fIf\fP The error handler function, which is called with the pointer to the redis instance that had the errror, the redis channel index (e\&.g\&. REDIS_INTERACTIVE_CHANNEL) and the operation (e\&.g\&. 'send' or 'read') that failed\&. Note, that the call may be made with the affected \fBRedis\fP channel being in a locked state\&. As such the handler should not directly attempt to change the connection state of the \fBRedis\fP instance\&. Any calls that require exlusive access to the affected channel should instead be spawn off into a separate thread, which can obtain the necessary lock when it is released\&.
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS if the handler was successfully configured, or X_NULL if the \fBRedis\fP instance is NULL\&. 
.RE
.PP

.PP
References \fBX_NULL\fP, and \fBX_SUCCESS\fP\&.
.SS "int redisxSetUser (\fBRedis\fP * redis, const char * username)"
Sets the user name to use for authenticating on the \fBRedis\fP server after connection\&. See the \fCAUTH\fP \fBRedis\fP command for more explanation\&. Naturally, you need to call this prior to connecting your \fBRedis\fP instance to have the desired effect\&.
.PP
\fBParameters\fP
.RS 4
\fIredis\fP Pointer to the \fBRedis\fP instance for which to set credentials 
.br
\fIusername\fP the password to use for authenticating on the server, or NULL to clear a previously configured password\&. 
.RE
.PP
\fBReturns\fP
.RS 4
X_SUCCESS (0) if successful, X_NULL if the redis argument is NULL, or X_ALREADY_OPEN if called after \fBRedis\fP was already connected\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBredisxSetPassword()\fP 
.RE
.PP

.PP
References \fBredisxError()\fP, \fBredisxIsConnected()\fP, \fBX_ALREADY_OPEN\fP, \fBX_NULL\fP, \fBX_SUCCESS\fP, and \fBxStringCopyOf()\fP\&.
.SS "void redisxSetVerbose (\fBboolean\fP value)"
Enable or disable verbose reporting of all \fBRedis\fP operations (and possibly some details of them)\&. Reporting is done on the standard output (stdout)\&. It may be useful when debugging programs that use the redisx interface\&. Verbose reporting is DISABLED by default\&.
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP TRUE to enable verbose reporting, or FALSE to disable\&. 
.RE
.PP

.PP
References \fBxSetVerbose()\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for RedisX from the source code\&.
