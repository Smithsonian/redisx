<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta charset="utf-8"/>
<meta name="description" content="A light-weight Redis client library for C/C++"/>
<meta name="keywords" content="Redis client library, C, C++, C90, software library, open source"/>
<meta name="author" content="Attila Kovacs"/>
<meta name="copyright" content="(C)2024 Attila Kovacs" />
<meta name="robots" content="index,follow"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2L0MEN3Z8Q"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-2L0MEN3Z8Q');
</script>
<link rel="shortcut icon" type="image/x-icon" href="/redisx/resources/favicon.ico" />
<link rel="icon" type="image/png" sizes="192x192" href="/redisx/resources/android-chrome-192x192.png" />
<link rel="icon" type="image/png" sizes="512x512" href="/redisx/resources/android-chrome-512x512.png" />
<link rel="apple-touch-icon" type="image/png" href="/redisx/resources/apple-touch-icon.png" />
<title>RedisX: RedisX</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="smithsonian-logo-55x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">RedisX<span id="projectnumber">&#160;v0.9</span>
   </div>
   <div id="projectbrief">A simple, light-weight Redis database client</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">RedisX </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README-orig"></a> A simple, light-weight C/C++ <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> client library.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Table of Contents</h2>
<ul>
<li><a class="el" href="index.html#introduction">Introduction</a></li>
<li><a class="el" href="index.html#prerequisites">Prerequisites</a></li>
<li><a class="el" href="index.html#building-redisx">Building RedisX</a></li>
<li><a class="el" href="index.html#managing-redis-server-connections">Managing Redis server connections</a></li>
<li><a class="el" href="index.html#simple-redis-queries">Simple Redis queries</a></li>
<li><a class="el" href="index.html#publish-subscribe-support">Publish/subscribe (PUB/SUB) support</a></li>
<li><a class="el" href="index.html#advanced-queries">Advanced queries</a></li>
<li><a class="el" href="index.html#atomic-transaction-blocks-and-lua-scripts">Atomic execution blocks and LUA scripts</a></li>
<li><a class="el" href="index.html#error-handling">Error handling</a></li>
<li><a class="el" href="index.html#debug-support">Debug support</a></li>
<li><a class="el" href="index.html#future-plans">Future plans</a></li>
</ul>
<p><a class="anchor" id="introduction"></a> </p>
<h2><a class="anchor" id="autotoc_md4"></a>
Introduction</h2>
<p><b>RedisX</b> is a light-weight <a href="https://redis.io">Redis</a> client for C/C++. As such, it should also work with <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> forks / clones like <a href="https://dragonfly.io">Dragonfly</a> or <a href="https://valkey.io">Valkey</a>. It supports both interactive and pipelined <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> queries, managing and processing subscriptions, atomic execution blocks, and LUA scripts loading. It can be used with multiple <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> servers simultaneously also.</p>
<p>While there are other C/C++ <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> clients available, this one is C90 compatible, and hence can be used on older platforms also. It is also small and fast, but still capable and versatile.</p>
<p>Rather than providing high-level support for every possible <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> command (which would probably be impossible given the pace new commands are being introduced all the time), it provides a basic framework for synchronous and asynchronous queries, with some higher-level functions for managing key/value storage types (including hash tables), and PUB/SUB. Future releases may add further higher-level functionality based on demand for such features.</p>
<p>The <b>RedisX</b> library was created, and is maintained, by Attila Kov√°cs at the Center for Astrophysics | Harvard &amp; Smithsonian, and it is available through the <a href="https://github.com/Smithsonian/redisx">Smithsonian/redisx</a> repository on GitHub.</p>
<p>There are no official releases of <b>RedisX</b> yet. An initial 1.0.0 release is expected in late 2024 or early 2025. Before then the API may undergo slight changes and tweaks. Use the repository as is at your own risk for now.</p>
<p>Some related links:</p>
<ul>
<li><a href="https://smithsonian.github.io/redisx/apidoc/html/files.html">API documentation</a></li>
<li><a href="https://smithsonian.github.io/redisx">Project page</a> on github.io</li>
<li><a href="https://smithsonian.github.io/redisx">xchange</a> library dependency</li>
</ul>
<hr  />
<p><a class="anchor" id="prerequisites"></a> </p>
<h2><a class="anchor" id="autotoc_md6"></a>
Prerequisites</h2>
<p>The <a href="https://github.com/Smithsonian/xchange">Smithsonian/xchange</a> library is both a build and a runtime dependency of RedisX.</p>
<hr  />
<p><a class="anchor" id="building-redisx"></a> </p>
<h2><a class="anchor" id="autotoc_md8"></a>
Building RedisX</h2>
<p>The <b>RedisX</b> library can be built either as a shared (<code>libredisx.so[.1]</code>) and as a static (<code>libredisx.a</code>) library, depending on what suits your needs best.</p>
<p>You can configure the build, either by editing <code>config.mk</code> or else by defining the relevant environment variables prior to invoking <code>make</code>. The following build variables can be configured:</p>
<ul>
<li><code>XCHANGE</code>: the root of the location where the <a href="https://github.com/Smithsonian/xchange">Smithsonian/xchange</a> library is installed. It expects to find <code><a class="elRef" href="../../xchange/apidoc/html/xchange_8h.html">xchange.h</a></code> under <code>$(XCHANGE)/include</code> and <code>libxchange.so</code> under <code>$(XCHANGE)/lib</code> or else in the default <code>LD_LIBRARY_PATH</code>.</li>
<li><code>CC</code>: The C compiler to use (default: <code>gcc</code>).</li>
<li><code>CPPFLAGS</code>: C pre-processor flags, such as externally defined compiler constants.</li>
<li><code>CFLAGS</code>: Flags to pass onto the C compiler (default: <code>-Os -Wall</code>). Note, <code>-Iinclude</code> will be added automatically.</li>
<li><code>LDFLAGS</code>: Linker flags (default is <code>-lm</code>). Note, <code>-lxchange</code> will be added automatically.</li>
<li><code>BUILD_MODE</code>: You can set it to <code>debug</code> to enable debugging features: it will initialize the global <code>xDebug</code> variable to <code>TRUE</code>) and add <code>-g</code> to <code>CFLAGS</code>.</li>
<li><code>CHECKEXTRA</code>: Extra options to pass to <code>cppcheck</code> for the <code>make check</code> target</li>
</ul>
<p>After configuring, you can simply run <code>make</code>, which will build the <code>shared</code> (<code>lib/libredisx.so[.1]</code>) and <code>static</code> (<code>lib/libredisx.a</code>) libraries, local HTML documentation (provided <code>doxygen</code> is available), and performs static analysis via the <code>check</code> target. Or, you may build just the components you are interested in, by specifying the desired <code>make</code> target(s). (You can use <code>make help</code> to get a summary of the available <code>make</code> targets).</p>
<hr  />
<p><a class="anchor" id="managing-redis-server-connections"></a> </p>
<h2><a class="anchor" id="autotoc_md10"></a>
Managing Redis server connections</h2>
<ul>
<li><a class="el" href="index.html#initializing">Initializing</a></li>
<li><a class="el" href="index.html#connecting">Connecting</a></li>
<li><a class="el" href="index.html#disconnecting">Disconnecting</a></li>
<li><a class="el" href="index.html#connection-hooks">Connection hooks</a></li>
</ul>
<p>The library maintains up to three separate connections (channels) for each separate <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server instance used: (1) an interactive client for sequential round-trip transactions, (2) a pipeline client for bulk queries and asynchronous background processing, and (3) a subscription client for PUB/SUB requests and notifications. The interactive client is always connected, the pipeline client is connected only if explicitly requested at the time of establishing the server connection, while the subscription client is connected only as needed.</p>
<p><a class="anchor" id="initializing"></a> </p>
<h3><a class="anchor" id="autotoc_md11"></a>
Initializing</h3>
<p>The first step is to create a <code><a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a></code> object, with the server name or IP address.</p>
<div class="fragment"><div class="line"><span class="comment">// Configure the redis server to connect to &quot;redis.mydomain.com&quot;.</span></div>
<div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = <a class="code hl_function" href="redisx-net_8c.html#a5c78c2189a76a077231016564a0cecd5">redisxInit</a>(<span class="stringliteral">&quot;redis.mydomain.com&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (redis == NULL) {</div>
<div class="line">  <span class="comment">// Abort: something did not got to plan...</span></div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="ttc" id="aredisx-net_8c_html_a5c78c2189a76a077231016564a0cecd5"><div class="ttname"><a href="redisx-net_8c.html#a5c78c2189a76a077231016564a0cecd5">redisxInit</a></div><div class="ttdeci">Redis * redisxInit(const char *server)</div><div class="ttdef"><b>Definition</b> redisx-net.c:600</div></div>
<div class="ttc" id="astructRedis_html"><div class="ttname"><a href="structRedis.html">Redis</a></div><div class="ttdoc">Structure that represents a Redis database instance, with one or more RedisClient connections.</div><div class="ttdef"><b>Definition</b> redisx.h:159</div></div>
</div><!-- fragment --><p>Before connecting to the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server, you may configure optional settings, such as the TCP port number to use (if not the default 6379), and the database authentication (if any):</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (optional) configure a non-standard port number</span></div>
<div class="line">redisxSetPort(&amp;redis, 7089);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (optional) Configure the database user (since Redis 6.0, using ACL)</span></div>
<div class="line"><a class="code hl_function" href="redisx_8c.html#a3beff3a9e373a0f1de626a8e64da98cf">redisxSetUser</a>(&amp;redis, <span class="stringliteral">&quot;johndoe&quot;</span>); </div>
<div class="line"> </div>
<div class="line"><span class="comment">// (optional) Configure the database password...</span></div>
<div class="line"><a class="code hl_function" href="redisx_8c.html#a0e9eda38aa6f084ac151cbebe2886c2f">redisxSetPassword</a>(&amp;redis, mySecretPasswordString);</div>
<div class="ttc" id="aredisx_8c_html_a0e9eda38aa6f084ac151cbebe2886c2f"><div class="ttname"><a href="redisx_8c.html#a0e9eda38aa6f084ac151cbebe2886c2f">redisxSetPassword</a></div><div class="ttdeci">int redisxSetPassword(Redis *redis, const char *passwd)</div><div class="ttdef"><b>Definition</b> redisx.c:125</div></div>
<div class="ttc" id="aredisx_8c_html_a3beff3a9e373a0f1de626a8e64da98cf"><div class="ttname"><a href="redisx_8c.html#a3beff3a9e373a0f1de626a8e64da98cf">redisxSetUser</a></div><div class="ttdeci">int redisxSetUser(Redis *redis, const char *username)</div><div class="ttdef"><b>Definition</b> redisx.c:99</div></div>
</div><!-- fragment --><p>You might also tweak the send/receive buffer sizes to use for clients, if you find the socket defaults sub-optimal for you application:</p>
<div class="fragment"><div class="line"><span class="comment">// (optional) Set the TCP send/rcv buffer sizes to use if not default values.</span></div>
<div class="line"><span class="comment">//            This setting applies to all new connections after...</span></div>
<div class="line"><a class="code hl_function" href="redisx-net_8c.html#a83fce113d042490e77efdc574e64d76f">redisxSetTcpBuf</a>(65536);</div>
<div class="ttc" id="aredisx-net_8c_html_a83fce113d042490e77efdc574e64d76f"><div class="ttname"><a href="redisx-net_8c.html#a83fce113d042490e77efdc574e64d76f">redisxSetTcpBuf</a></div><div class="ttdeci">void redisxSetTcpBuf(int size)</div><div class="ttdef"><b>Definition</b> redisx-net.c:690</div></div>
</div><!-- fragment --><p>Optionally you can select the database index to use now (or later, after connecting), if not the default (index 0):</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Select the database index 2</span></div>
<div class="line">redisxSelectDB(redis); </div>
</div><!-- fragment --><p>Note, that you can switch the database index any time, with the caveat that it's not possible to change it for the subscription client when there are active subscriptions.</p>
<p><a class="anchor" id="connecting"></a> </p>
<h3><a class="anchor" id="autotoc_md12"></a>
Connecting</h3>
<p>Once configured, you can connect to the server as:</p>
<div class="fragment"><div class="line"><span class="comment">// Connect to Redis, including a 2nd dedicated client for pipelined requests</span></div>
<div class="line"><span class="keywordtype">int</span> status = <a class="code hl_function" href="redisx-net_8c.html#ad71822356ffd40ed4b1c71d065f48809">redisxConnect</a>(&amp;redis, TRUE);</div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">   <span class="comment">// Abort: we could not connect for some reason...</span></div>
<div class="line">   ...</div>
<div class="line">   <span class="comment">// Clean up...</span></div>
<div class="line">   <a class="code hl_function" href="redisx-net_8c.html#ac54dd4c46d8615db4da02702c18f062b">redisxDestroy</a>(&amp;redis);</div>
<div class="line">   ...</div>
<div class="line">}</div>
<div class="ttc" id="aredisx-net_8c_html_ac54dd4c46d8615db4da02702c18f062b"><div class="ttname"><a href="redisx-net_8c.html#ac54dd4c46d8615db4da02702c18f062b">redisxDestroy</a></div><div class="ttdeci">void redisxDestroy(Redis *redis)</div><div class="ttdef"><b>Definition</b> redisx-net.c:660</div></div>
<div class="ttc" id="aredisx-net_8c_html_ad71822356ffd40ed4b1c71d065f48809"><div class="ttname"><a href="redisx-net_8c.html#ad71822356ffd40ed4b1c71d065f48809">redisxConnect</a></div><div class="ttdeci">int redisxConnect(Redis *redis, boolean usePipeline)</div><div class="ttdef"><b>Definition</b> redisx-net.c:737</div></div>
</div><!-- fragment --><p>The above will establish both an interactive connection and a pipelined connection client, for processing both synchronous and asynchronous requests (and responses).</p>
<p><a class="anchor" id="disconnecting"></a> </p>
<h3><a class="anchor" id="autotoc_md13"></a>
Disconnecting</h3>
<p>When you are done with a specific <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server, you should disconnect from it:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line">redisxDisconnect(redis);</div>
</div><!-- fragment --><p><a class="anchor" id="connection-hooks"></a> </p>
<h3><a class="anchor" id="autotoc_md14"></a>
Connection hooks</h3>
<p>The user of the <b>RedisX</b> library might want to know when connections to the server are established, or when disconnections happen, and may want to perform some configuration or clean-up accordingly. For this reason, the library provides support for connection 'hooks' &ndash; that is custom functions that are called in the even of connecting to or disconnecting from a <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server.</p>
<p>Here is an example of a connection hook, which simply prints a message about the connection to the console.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> my_connect_hook(<a class="code hl_struct" href="structRedis.html">Redis</a> *redis) {</div>
<div class="line">   printf(<span class="stringliteral">&quot;Connected to Redis server: %s\n&quot;</span>, redis-&gt;<a class="code hl_variable" href="structRedis.html#aecb3b0d045ada529257a2fbf8f829599">id</a>);</div>
<div class="line">}</div>
<div class="ttc" id="astructRedis_html_aecb3b0d045ada529257a2fbf8f829599"><div class="ttname"><a href="structRedis.html#aecb3b0d045ada529257a2fbf8f829599">Redis::id</a></div><div class="ttdeci">char * id</div><div class="ttdoc">The string ID of the Redis server. Default is IP, e.g. &quot;127.0.0.1&quot;.</div><div class="ttdef"><b>Definition</b> redisx.h:160</div></div>
</div><!-- fragment --><p>And, it can be added to a <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> instance, between the <code><a class="el" href="redisx-net_8c.html#a5c78c2189a76a077231016564a0cecd5">redisxInit()</a></code> and the <code><a class="el" href="redisx-net_8c.html#ad71822356ffd40ed4b1c71d065f48809">redisxConnect()</a></code> calls.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line">redisxAddConnectHook(redis, my_connect_hook);</div>
</div><!-- fragment --><p>The same goes for disconnect hooks, using <code><a class="el" href="redisx-hooks_8c.html#a84029a60375dd995580a8690f6813f9a">redisxAddDisconnectHook()</a></code> instead.</p>
<hr  />
<p><a class="anchor" id="simple-redis-queries"></a> </p>
<h2><a class="anchor" id="autotoc_md16"></a>
Simple Redis queries</h2>
<ul>
<li><a class="el" href="index.html#resp-data-type">RESP data type</a></li>
<li><a class="el" href="index.html#interactive-transactions">Interactive transactions</a></li>
<li><a class="el" href="index.html#pipelined-transactions">Pipelined transactions</a></li>
</ul>
<p><a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> queries are sent as strings, according the the specification of the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> protocol. All responses sent back by the server using the <a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> protocol. Specifically, <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> uses version 2.0 of the <a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> protocol (a.k.a. RESP2) by default, with optional support for the newer RESP3 introduced in <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> version 6.0. The RedisX library currently processes the standard RESP2 replies only. RESP3 support to the library may be added in the future (stay tuned...)</p>
<p><a class="anchor" id="resp-data-type"></a> </p>
<h3><a class="anchor" id="autotoc_md17"></a>
RESP data type</h3>
<p>All responses coming from the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server are represented by a dynamically allocated <code><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a></code> type (defined in <code><a class="el" href="redisx_8h.html">redisx.h</a></code>) structure. Each <code><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a></code> has a type (e.g. <code>RESP_SIMPLE_STRING</code>), an integer value <code>n</code>, and a <code>value</code> pointer to further data. If the type is <code>RESP_INT</code>, then <code>n</code> represents the actual return value (and the <code>value</code> pointer is not used). For string type values <code>n</code> is the number of characters in the string <code>value</code> (not including termination), while for <code>RESP_ARRAY</code> types the <code>value</code> is a pointer to an embedded <code><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a></code> array and <code>n</code> is the number of elements in that.</p>
<p>You may check the integrity of a <code><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a></code> using <code><a class="el" href="redisx_8c.html#a2d3ffb89129ab04483e3966835a5ff71">redisxCheckRESP()</a></code>. Since <code><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a></code> data is dynamically allocated, the user is responsible for discarding them once they are no longer needed, e.g. by calling <code><a class="el" href="redisx_8c.html#aa4e23a7454f7055711915ec430599011">redisxDestroyRESP()</a></code>. The two steps may be combined to automatically discard invalid or unexpected <code><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a></code> data in a single step by calling <code><a class="el" href="redisx_8c.html#a67b8bd13975dd286600f20dc80bdb462">redisxCheckDestroyRESP()</a></code>.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRESP.html">RESP</a> *r = ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Let&#39;s say we expect &#39;r&#39; to contain of an embedded RESP array of 3 elements... </span></div>
<div class="line">int status = <a class="code hl_function" href="redisx_8c.html#a67b8bd13975dd286600f20dc80bdb462">redisxCheckDestroyRESP</a>(r, <a class="code hl_define" href="redisx_8h.html#ae140df45d32af33e2334fb677213e887">RESP_ARRAY</a>, 3);</div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">   <span class="comment">// Oops, &#39;r&#39; was either NULL, or does not contain a RESP array with 3 elements...</span></div>
<div class="line">   ...</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> {</div>
<div class="line">   <span class="comment">// Process the expected response...</span></div>
<div class="line">   ...</div>
<div class="line">   <a class="code hl_function" href="redisx_8c.html#aa4e23a7454f7055711915ec430599011">redisxDestroyRESP</a>(r);</div>
<div class="line">}</div>
<div class="ttc" id="aredisx_8c_html_a67b8bd13975dd286600f20dc80bdb462"><div class="ttname"><a href="redisx_8c.html#a67b8bd13975dd286600f20dc80bdb462">redisxCheckDestroyRESP</a></div><div class="ttdeci">int redisxCheckDestroyRESP(RESP *resp, char expectedType, int expectedSize)</div><div class="ttdef"><b>Definition</b> redisx.c:486</div></div>
<div class="ttc" id="aredisx_8c_html_aa4e23a7454f7055711915ec430599011"><div class="ttname"><a href="redisx_8c.html#aa4e23a7454f7055711915ec430599011">redisxDestroyRESP</a></div><div class="ttdeci">void redisxDestroyRESP(RESP *resp)</div><div class="ttdef"><b>Definition</b> redisx.c:436</div></div>
<div class="ttc" id="aredisx_8h_html_ae140df45d32af33e2334fb677213e887"><div class="ttname"><a href="redisx_8h.html#ae140df45d32af33e2334fb677213e887">RESP_ARRAY</a></div><div class="ttdeci">#define RESP_ARRAY</div><div class="ttdoc">RESP array type.</div><div class="ttdef"><b>Definition</b> redisx.h:88</div></div>
<div class="ttc" id="astructRESP_html"><div class="ttname"><a href="structRESP.html">RESP</a></div><div class="ttdoc">Structure that represents a Redis response (RESP format).</div><div class="ttdef"><b>Definition</b> redisx.h:123</div></div>
</div><!-- fragment --><p>Before destroying a <a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> structure, the caller may want to de-reference values within it if they are to be used as is (without making copies), e.g.:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRESP.html">RESP</a> *r = ...</div>
<div class="line">char *stringValue = NULL;   <span class="comment">// to be extracted from &#39;r&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Let&#39;s say we expect &#39;r&#39; to contain of a simple string response (of whatever length)</span></div>
<div class="line"><span class="keywordtype">int</span> status = <a class="code hl_function" href="redisx_8c.html#a67b8bd13975dd286600f20dc80bdb462">redisxCheckDestroyRESP</a>(r, <a class="code hl_define" href="redisx_8h.html#ab2bc8d02a9fa90910d487412704b99f3">RESP_SIMPLE_STRING</a>, 0);</div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Oops, &#39;r&#39; was either NULL, or it was not a simple string type</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> {</div>
<div class="line">  <span class="comment">// Set &#39;stringValue&#39; and dereference the value field in the RESP so it&#39;s not </span></div>
<div class="line">  <span class="comment">// destroyed with the RESP itself.</span></div>
<div class="line">  stringValue = r-&gt;<a class="code hl_variable" href="structRESP.html#a0f61d63b009d0880a89c843bd50d8d76">value</a>;</div>
<div class="line">  r-&gt;<a class="code hl_variable" href="structRESP.html#a0f61d63b009d0880a89c843bd50d8d76">value</a> = NULL;</div>
<div class="line">   </div>
<div class="line">  <a class="code hl_function" href="redisx_8c.html#aa4e23a7454f7055711915ec430599011">redisxDestroyRESP</a>(r);     <span class="comment">// The &#39;stringValue&#39; is still a valid pointer after! </span></div>
<div class="line">}</div>
<div class="ttc" id="aredisx_8h_html_ab2bc8d02a9fa90910d487412704b99f3"><div class="ttname"><a href="redisx_8h.html#ab2bc8d02a9fa90910d487412704b99f3">RESP_SIMPLE_STRING</a></div><div class="ttdeci">#define RESP_SIMPLE_STRING</div><div class="ttdoc">RESP simple string type.</div><div class="ttdef"><b>Definition</b> redisx.h:90</div></div>
<div class="ttc" id="astructRESP_html_a0f61d63b009d0880a89c843bd50d8d76"><div class="ttname"><a href="structRESP.html#a0f61d63b009d0880a89c843bd50d8d76">RESP::value</a></div><div class="ttdeci">void * value</div><div class="ttdoc">Pointer to text (char *) content to an array of components (RESP**)...</div><div class="ttdef"><b>Definition</b> redisx.h:127</div></div>
</div><!-- fragment --><p><a class="anchor" id="interactive-transactions"></a> </p>
<h3><a class="anchor" id="autotoc_md18"></a>
Interactive transactions</h3>
<p>The simplest way for running a few <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> queries is to do it in interactive mode:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line">RESP *resp;</div>
<div class="line"><span class="keywordtype">int</span> status;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send &quot;HGET my_table my_key&quot; request</span></div>
<div class="line">resp = <a class="code hl_function" href="redisx_8c.html#a09092bd97eead5c5fa73fa0d9241018c">redisxRequest</a>(redis, <span class="stringliteral">&quot;HGET&quot;</span>, <span class="stringliteral">&quot;my_table&quot;</span>, <span class="stringliteral">&quot;my_key&quot;</span>, NULL, &amp;status);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check return status...</span></div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Oops something went wrong...</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="ttc" id="aredisx_8c_html_a09092bd97eead5c5fa73fa0d9241018c"><div class="ttname"><a href="redisx_8c.html#a09092bd97eead5c5fa73fa0d9241018c">redisxRequest</a></div><div class="ttdeci">RESP * redisxRequest(Redis *redis, const char *command, const char *arg1, const char *arg2, const char *arg3, int *status)</div><div class="ttdef"><b>Definition</b> redisx.c:581</div></div>
</div><!-- fragment --><p>The <code><a class="el" href="redisx_8c.html#a09092bd97eead5c5fa73fa0d9241018c">redisxRequest()</a></code> sends a command with up to three arguments. If the command takes fewer than 3 parameters, then the remaining ones must be set to <code>NULL</code>. This function thus offers a simple interface for running most basic sequential queries. In cases where 3 parameters are nut sufficient, you may use <code><a class="el" href="redisx_8c.html#a13ae33bc25ee03621b23541236ef5f82">redisxArrayRequest()</a></code> instead, e.g.:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">char *args[] = { <span class="stringliteral">&quot;my_table&quot;</span>, <span class="stringliteral">&quot;my_key&quot;</span> };  <span class="comment">// parameters as an array...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send &quot;HGET my_table my_key&quot; request with an array of 2 parameters...</span></div>
<div class="line">resp = <a class="code hl_function" href="redisx_8c.html#a09092bd97eead5c5fa73fa0d9241018c">redisxRequest</a>(redis, <span class="stringliteral">&quot;HGET&quot;</span>, args, NULL, 2, &amp;status);</div>
<div class="line">...</div>
</div><!-- fragment --><p>The 4th argument in the list is an optional <code>int[]</code> array defining the individual string lengths of the parameters (if need be, or else readily available). Here, we used <code>NULL</code> instead, which will use <code>strlen()</code> on each supplied string-terminated parameter to determine its length automatically. Specifying the length may be necessary if the individual parameters are not 0-terminated strings, or else substrings from a continuing string are to be used as the parameter value.</p>
<p>In interactive mode, each request is sent to the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server, and the response is collected before the call returns with that response (or <code>NULL</code> if there was an error).</p>
<p><a class="anchor" id="pipelined-transactions"></a> </p>
<h3><a class="anchor" id="autotoc_md19"></a>
Pipelined transactions</h3>
<p>Depending on round-trip times over the network, interactive queries may be suitable for running up to a few hundred (or a few thousand) queries per second. For higher throughput (up to millions <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> transactions per second) you may need to access the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> database in pipelined mode.</p>
<p>In pipeline mode, requests are sent to the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server in quick succession without waiting for responses to return for each one individually. Responses are then processed in the background by a designated callback function.</p>
<div class="fragment"><div class="line"><span class="comment">// Your own function to process responses to pipelined requests...</span></div>
<div class="line"><span class="keywordtype">void</span> my_resp_processor(<a class="code hl_struct" href="structRESP.html">RESP</a> *r) {</div>
<div class="line">  <span class="comment">// Do what you need to do with the asynchronous responses</span></div>
<div class="line">  <span class="comment">// that come from Redis to bulk requests</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Before sending the requests, the user first needs to specify the function to process the responses, e.g.:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line">redisxSetPipelineConsumer(redis, my_resp_processor);</div>
</div><!-- fragment --><p>Request are sent via the <code><a class="el" href="redisx-client_8c.html#afc7b28288c07baf0b3c8fdc9d8ddf263">redisxSendRequestAsync()</a></code> and <code><a class="el" href="redisx-client_8c.html#a899f4f8853add789db4bd4de106fd6d8">redisxSendArrayRequestAsync()</a></code> functions. Note, the <code>Async</code> naming, which indicates the asynchronous nature of this calls &ndash; and which also suggests that these should be called with the approrpiate mutex locked to prevent concurrency issues.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// We&#39;ll use a dedicated pipeline connection for asynchronous requests</span></div>
<div class="line"><span class="comment">// This way, interactive requests can still be sent independently on the interactive</span></div>
<div class="line"><span class="comment">// channel independently, if need be.</span></div>
<div class="line">RedisClient *pipe = <a class="code hl_function" href="redisx-client_8c.html#a14907be8fba6a13505a352673cea5895">redisxGetClient</a>(redis, <a class="code hl_enumvalue" href="redisx_8h.html#a5349b7340813fbd1e32d04ed650bc3d9a1ff4eb2593538a6dda3cd49a1df30752">PIPELINE_CHANNEL</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check that the client is valid...</span></div>
<div class="line"><span class="keywordflow">if</span> (pipe == NULL) {</div>
<div class="line">   <span class="comment">// Abort: we do not appear to have an active pipeline connection...</span></div>
<div class="line">   <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get exclusive access to the pipeline channel, so no other thread may send</span></div>
<div class="line"><span class="comment">// other requests concurrently...</span></div>
<div class="line"><a class="code hl_function" href="redisx-client_8c.html#ac6c9928f425b6b1d97d721cbddc3cf28">redisxLockEnabled</a>(pipe);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// -------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Submit a whole bunch of asynchronous requests, e.g. from a loop...</span></div>
<div class="line"><span class="keywordflow">for</span> (...) {</div>
<div class="line">  <span class="keywordtype">int</span> status = <a class="code hl_function" href="redisx-client_8c.html#afc7b28288c07baf0b3c8fdc9d8ddf263">redisxSendRequestAsync</a>(pipe, ...);</div>
<div class="line">  <span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">    <span class="comment">// Oops, that did not go through...</span></div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// We probably want to keep a record of what was requested and in what order</span></div>
<div class="line">    <span class="comment">// so our processing function can make sense of the reponses as they arrive</span></div>
<div class="line">    <span class="comment">// (in the same order...)</span></div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="comment">// -------------------------------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Release the exclusive lock on the pipeline channel, so</span></div>
<div class="line"><span class="comment">// other threads may use it now that we sent off our requests...</span></div>
<div class="line"><a class="code hl_function" href="redisx-client_8c.html#a87efe53c80fcff3fcf189362cbc602f7">redisxUnlockClient</a>(pipe);</div>
<div class="ttc" id="aredisx-client_8c_html_a14907be8fba6a13505a352673cea5895"><div class="ttname"><a href="redisx-client_8c.html#a14907be8fba6a13505a352673cea5895">redisxGetClient</a></div><div class="ttdeci">RedisClient * redisxGetClient(Redis *redis, enum redisx_channel channel)</div><div class="ttdef"><b>Definition</b> redisx-client.c:273</div></div>
<div class="ttc" id="aredisx-client_8c_html_a87efe53c80fcff3fcf189362cbc602f7"><div class="ttname"><a href="redisx-client_8c.html#a87efe53c80fcff3fcf189362cbc602f7">redisxUnlockClient</a></div><div class="ttdeci">int redisxUnlockClient(RedisClient *cl)</div><div class="ttdef"><b>Definition</b> redisx-client.c:352</div></div>
<div class="ttc" id="aredisx-client_8c_html_ac6c9928f425b6b1d97d721cbddc3cf28"><div class="ttname"><a href="redisx-client_8c.html#ac6c9928f425b6b1d97d721cbddc3cf28">redisxLockEnabled</a></div><div class="ttdeci">int redisxLockEnabled(RedisClient *cl)</div><div class="ttdef"><b>Definition</b> redisx-client.c:325</div></div>
<div class="ttc" id="aredisx-client_8c_html_afc7b28288c07baf0b3c8fdc9d8ddf263"><div class="ttname"><a href="redisx-client_8c.html#afc7b28288c07baf0b3c8fdc9d8ddf263">redisxSendRequestAsync</a></div><div class="ttdeci">int redisxSendRequestAsync(RedisClient *cl, const char *command, const char *arg1, const char *arg2, const char *arg3)</div><div class="ttdef"><b>Definition</b> redisx-client.c:522</div></div>
<div class="ttc" id="aredisx_8h_html_a5349b7340813fbd1e32d04ed650bc3d9a1ff4eb2593538a6dda3cd49a1df30752"><div class="ttname"><a href="redisx_8h.html#a5349b7340813fbd1e32d04ed650bc3d9a1ff4eb2593538a6dda3cd49a1df30752">PIPELINE_CHANNEL</a></div><div class="ttdeci">@ PIPELINE_CHANNEL</div><div class="ttdoc">Redis channel number for pipelined transfers.</div><div class="ttdef"><b>Definition</b> redisx.h:111</div></div>
</div><!-- fragment --><hr  />
<p><a class="anchor" id="accessing-key-value-data"></a> </p>
<h2><a class="anchor" id="autotoc_md21"></a>
Accessing key / value data</h2>
<ul>
<li><a class="el" href="index.html#getting-and-setting-keyed-values">Getting and setting keyed values</a></li>
<li><a class="el" href="index.html#listing-and-scanning">Listing and scanning</a></li>
</ul>
<p><a class="anchor" id="getting-and-setting-keyed-values"></a> </p>
<h3><a class="anchor" id="autotoc_md22"></a>
Getting and setting keyed values</h3>
<p>Key/value pairs are the bread and butter of <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a>. They come in two variaties: (1) there are top-level key-value pairs, and (2) there are key-value pairs organized into hash tables, where the table name is a top-level key, but the fields in the table are not. The RedisX library offers a unified approach for dealing with key/value pairs, whether they are top level or hash-tables. Simply, a table name <code>NULL</code> is used to refer to top-level keys.</p>
<p>Retrieving individual keyed values is simple:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...;</div>
<div class="line"><span class="keywordtype">int</span> len; <span class="comment">// Variable in which we return the length of the value or an error code </span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the &quot;property&quot; field from the &quot;system:subsystem&quot; hash table</span></div>
<div class="line"><span class="keywordtype">char</span> *value = <a class="code hl_function" href="redisx-tab_8c.html#afc875f142146282860b6a8a3ac2f0fc8">redisxGetStringValue</a>(redis, <span class="stringliteral">&quot;system:subsystem&quot;</span>, <span class="stringliteral">&quot;property&quot;</span>, &amp;len);</div>
<div class="line"><span class="keywordflow">if</span> (len &lt; 0) {</div>
<div class="line">  <span class="comment">// Oops something went wrong.</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Discard the value once it&#39;s no longer needed.</span></div>
<div class="line">if(value) free(value);</div>
<div class="ttc" id="aredisx-tab_8c_html_afc875f142146282860b6a8a3ac2f0fc8"><div class="ttname"><a href="redisx-tab_8c.html#afc875f142146282860b6a8a3ac2f0fc8">redisxGetStringValue</a></div><div class="ttdeci">char * redisxGetStringValue(Redis *redis, const char *table, const char *key, int *len)</div><div class="ttdef"><b>Definition</b> redisx-tab.c:259</div></div>
</div><!-- fragment --><p>The same goes for top-level keyed values, using <code>NULL</code> for the hash table name:</p>
<div class="fragment"><div class="line"><span class="comment">// Get value for top-level key (not stored in hash table!)</span></div>
<div class="line"><span class="keywordtype">char</span> *value = <a class="code hl_function" href="redisx-tab_8c.html#afc875f142146282860b6a8a3ac2f0fc8">redisxGetStringValue</a>(redis, NULL, <span class="stringliteral">&quot;my-key&quot;</span>, &amp;len);</div>
</div><!-- fragment --><p>In turn, setting values is also straightforward:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the &quot;property&quot; field in the &quot;system:subsystem&quot; hash table to -2.5</span></div>
<div class="line"><span class="comment">// using the interactive client connection. </span></div>
<div class="line"><span class="keywordtype">int</span> status = <a class="code hl_function" href="redisx-tab_8c.html#aaf4dbea72c62bad0ed91800db9644cd9">redisxSetValue</a>(redis, <span class="stringliteral">&quot;system:subsystem&quot;</span>, <span class="stringliteral">&quot;property&quot;</span>, <span class="stringliteral">&quot;-2.5&quot;</span>, FALSE);</div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Oops something went wrong.</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="aredisx-tab_8c_html_aaf4dbea72c62bad0ed91800db9644cd9"><div class="ttname"><a href="redisx-tab_8c.html#aaf4dbea72c62bad0ed91800db9644cd9">redisxSetValue</a></div><div class="ttdeci">int redisxSetValue(Redis *redis, const char *table, const char *key, const char *value, boolean isPipelined)</div><div class="ttdef"><b>Definition</b> redisx-tab.c:124</div></div>
</div><!-- fragment --><p>It's worth noting here, that values in <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> are always represented as 'strings', hence non-string data, such as floating-point values, must be converted to strings first. Additionally, the <code><a class="el" href="redisx-tab_8c.html#aaf4dbea72c62bad0ed91800db9644cd9">redisxSetValue()</a></code> function works with 0-terminated string values only, but <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> may also store unterminated byte sequences of known length also. If you find that you need to store an unterminated string (such as a binary sequence) as a value, you may just use the lower-level <code><a class="el" href="redisx_8c.html#a13ae33bc25ee03621b23541236ef5f82">redisxArrayRequest()</a></code> instead to process a <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> <code>GET</code> or <code>HGET</code> command with explicit byte-length specifications.</p>
<p>In the above example we have set the value using the interactive client to <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a>, which means that the call will return only after confirmation is received from the server. As such, a subsequent <code><a class="el" href="redisx-tab_8c.html#a01bf1f5d830d1af19456ab78457a54ab">redisxGetValue()</a></code> of the same table/key will be guaranteed to return the updated value always. However, we could have set the new value asynchronously over the pipeline connection (by using <code>TRUE</code> as the last argument). In that case, the call will return as soon as the request was sent to <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> (but not confirmed, nor possibly transmitted yet!). As such, a subsequent <code><a class="el" href="redisx-tab_8c.html#a01bf1f5d830d1af19456ab78457a54ab">redisxGetValue()</a></code> on the same key/value field may race the request in transit, and may return the previous value on occasion. So, it's important to remember that while pipelining can make setting multiple <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> fields very efficient, we have to be careful about retrieving the same values afterwards from the same program thread. (Arguably, however, there should never be a need to query values we set ourselves, since we readily know what they are.)</p>
<p>Finally, if you want to set values for multiple fields in a <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> hash table atomically, you may use <code><a class="el" href="redisx-tab_8c.html#ada49b9dad00af34819a8de323b59be16">redisxMultiSet()</a></code>, which provides a high-level interface to the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> <code>HMSET</code> command.</p>
<p><a class="anchor" id="listing-and-scanning"></a> </p>
<h3><a class="anchor" id="autotoc_md23"></a>
Listing and Scanning</h3>
<p>The functions <code><a class="el" href="redisx-tab_8c.html#aaa45af252b10e19c647d2cd5b51d7c05">redisxGetKeys()</a></code> and <code><a class="el" href="redisx-tab_8c.html#af4290857fc98baac7edd15edb6d0bcac">redisxGetTable()</a></code> allow to return the set of <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> keywords or all key/value pairs in a table atomically. However, these commands can be computationally expensive for large tables and/or many top-level keywords, which means that the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server may block for undesirably long times while the result is computed.</p>
<p>This is where scanning offers a less selfish (hence much preferred) alternative. Rather than returning all the keys or key/value pairs contained in a table atomically at once, it allows to do it bit by bit with byte-sized individual transactions that are guaranteed to not block the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server long, so it may remain responsive to other queries also. For the caller the result is the same, the only difference being that the result is computed via a series of quick <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> queries rather than with one potentially very expensive query.</p>
<p>For example, to retrieve all top-level <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> keys, sorted alphabetically, using the scanning approach, you may write something like:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line">int nMatches;  <span class="comment">// We&#39;ll return the number of matching Redis keys here...</span></div>
<div class="line"><span class="keywordtype">int</span> status;    <span class="comment">// We&#39;ll return the error status here...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//  Return all redis keywords starting with &quot;system:&quot;</span></div>
<div class="line"><span class="keywordtype">char</span> **keys = <a class="code hl_function" href="redisx-tab_8c.html#a67dd05115ae75dac9637ac04220d73b6">redisxScanKeys</a>(redis, <span class="stringliteral">&quot;system:*&quot;</span>, &amp;n, &amp;status);</div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Oops something went wrong...</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use &#39;keys&#39; as appropriate, possibly de-referencing values we want to</span></div>
<div class="line"><span class="comment">// retain in other persistent data structures...</span></div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Once done using the &#39;keys&#39; array, we should destroy it</span></div>
<div class="line">redisxDestroyKeys(keys, nMatches);</div>
<div class="ttc" id="aredisx-tab_8c_html_a67dd05115ae75dac9637ac04220d73b6"><div class="ttname"><a href="redisx-tab_8c.html#a67dd05115ae75dac9637ac04220d73b6">redisxScanKeys</a></div><div class="ttdeci">char ** redisxScanKeys(Redis *redis, const char *pattern, int *n, int *status)</div><div class="ttdef"><b>Definition</b> redisx-tab.c:492</div></div>
</div><!-- fragment --><p>Similarly, to retrieve a set of keywords from a table, matching a glob pattern:</p>
<div class="fragment"><div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Scan all key/value pairs in hash table &quot;system:subsystem&quot;</span></div>
<div class="line">RedisEntry *entries = <a class="code hl_function" href="redisx-tab_8c.html#a47d28fd9f2f35f0af5abd67a1ae7b987">redisxScanTable</a>(redis, <span class="stringliteral">&quot;system:subsystem&quot;</span>, <span class="stringliteral">&quot;*&quot;</span>, &amp;nMatches, &amp;status);</div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Oops something went wrong.</span></div>
<div class="line">  ... </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use &#39;entries&#39; as appropriate, possibly de-referencing values we want to</span></div>
<div class="line"><span class="comment">// retain in other persistent data structures...</span></div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Once done using the &#39;keys&#39; array, we should destroy it</span></div>
<div class="line">redisxDEstroyEntries(entries, nMatches);</div>
<div class="ttc" id="aredisx-tab_8c_html_a47d28fd9f2f35f0af5abd67a1ae7b987"><div class="ttname"><a href="redisx-tab_8c.html#a47d28fd9f2f35f0af5abd67a1ae7b987">redisxScanTable</a></div><div class="ttdeci">RedisEntry * redisxScanTable(Redis *redis, const char *table, const char *pattern, int *n, int *status)</div><div class="ttdef"><b>Definition</b> redisx-tab.c:655</div></div>
</div><!-- fragment --><p>Finally, you may use <code><a class="el" href="redisx-tab_8c.html#ad299cc621ad0dab54c6f7a7fd6770db9">redisxSetScanCount()</a></code> to tune just how many results should individial scan queries return. Please refer to the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> documentation on the behavior of the <code>SCAN</code> and <code>HSCAN</code> commands to learn more.</p>
<hr  />
<p><a class="anchor" id="publish-subscribe-support"></a> </p>
<h2><a class="anchor" id="autotoc_md25"></a>
Publish/subscribe (PUB/SUB) support</h2>
<ul>
<li><a class="el" href="index.html#broadcasting-messages">Broadcasting messages</a></li>
<li><a class="el" href="index.html#subscriptions">Subscriptions</a></li>
</ul>
<p><a class="anchor" id="broadcasting-messages"></a> </p>
<h3><a class="anchor" id="autotoc_md26"></a>
Broadcasting messages</h3>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// publish a message to the &quot;hello_channel&quot; subscribers.</span></div>
<div class="line">int status = <a class="code hl_function" href="redisx-sub_8c.html#a3ae6a78cececda6a1a495eebefbd57e9">redisxPublish</a>(redis, <span class="stringliteral">&quot;hello_channel&quot;</span>, <span class="stringliteral">&quot;Hello world!&quot;</span>, 0);</div>
<div class="ttc" id="aredisx-sub_8c_html_a3ae6a78cececda6a1a495eebefbd57e9"><div class="ttname"><a href="redisx-sub_8c.html#a3ae6a78cececda6a1a495eebefbd57e9">redisxPublish</a></div><div class="ttdeci">int redisxPublish(Redis *redis, const char *channel, const char *data, int length)</div><div class="ttdef"><b>Definition</b> redisx-sub.c:137</div></div>
</div><!-- fragment --><p>The last argument is an optional string length, if readily available, or if sending a substring only (or a string that is not 0-terminated). If zero is used, as in the example above, it will automatically determine the length of the 0-terminated string message using <code>strlen()</code>.</p>
<p>Alternatively, you may use the <code><a class="el" href="redisx-sub_8c.html#a89b6c2128548882616c081553ea2436c">redisxPublishAsync()</a></code> instead if you want to publish on a subscription client to which you have already have exlusive access (e.g. after an appropriate <code><a class="el" href="redisx-client_8c.html#ac6c9928f425b6b1d97d721cbddc3cf28">redisxLockEnabled()</a></code> call).</p>
<p><a class="anchor" id="subscriptions"></a> </p>
<h3><a class="anchor" id="autotoc_md27"></a>
Subscriptions</h3>
<p>Subscriptions work conceptually similarly to pipelined requests. To process incoming messages you need to first specify one or more <code>RedisSubscriberCall</code> functions, which will process PUB/SUB notifications automatically, in the background, as soon as they are received. Each <code>RedisSubscriberCall</code> can pre-filter the channels for which it receives notifications, by defining a channel stem. This way, the given processor function won't even be invoked if a notification on a completely different channel arrives. Still, each <code>RedisSubscriberCall</code> implementation should further check the notifying channel name as appropriate to ensure that it is in fact qualified to deal with a given message.</p>
<p>Here is an example <code>RedisSubscriberCall</code> implementation to process messages:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> my_event_processor(<span class="keyword">const</span> <span class="keywordtype">char</span> *pattern, <span class="keyword">const</span> <span class="keywordtype">char</span> *channel, <span class="keyword">const</span> <span class="keywordtype">char</span> *msg, <span class="keywordtype">long</span> len) {</div>
<div class="line">  <span class="comment">// We&#39;ll print the message onto the console</span></div>
<div class="line">  printf(<span class="stringliteral">&quot;Incoming message on channel %s: %s\n&quot;</span>, channel, msg == NULL ? <span class="stringliteral">&quot;&lt;null&gt;&quot;</span> : msg);</div>
<div class="line">}</div>
</div><!-- fragment --><p>There are some basic rules (best practices) for message processing. They should be fast, and never block for extended periods. If extensive processing is required, or may need to wait extensively for some resource or mutex locking, then its best that the processing function simply places the incoming message onto a queue, and let a separate background thread to the heavy lifting without holding up the subsription processing of other callback routines.</p>
<p>Also, it is important that the call should never attempt to modify or call <code>free()</code> on the supplied string arguments, since that would interfere with other subscrivber calls.</p>
<p>Once the function is defined, you can activate it via:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line">int status = <a class="code hl_function" href="redisx-sub_8c.html#a8a31ecaa0f83150366b72aa9b47755f0">redisxAddSubscriber</a>(redis, <span class="stringliteral">&quot;event:&quot;</span>, my_event_processor);</div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Oops, something went wrong...</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="aredisx-sub_8c_html_a8a31ecaa0f83150366b72aa9b47755f0"><div class="ttname"><a href="redisx-sub_8c.html#a8a31ecaa0f83150366b72aa9b47755f0">redisxAddSubscriber</a></div><div class="ttdeci">void redisxAddSubscriber(Redis *redis, const char *channelStem, RedisSubscriberCall f)</div><div class="ttdef"><b>Definition</b> redisx-sub.c:205</div></div>
</div><!-- fragment --><p>We should also start subsribing to specific channels and/or channel patterns (seethe <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> <code>SUBSCRIBE</code> and <code>PSUBSCRIBE</code> commands for details).</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// We subscribe to all channels that beging with &quot;event:&quot;...</span></div>
<div class="line">int status = <a class="code hl_function" href="redisx-sub_8c.html#a0aa27b4fce0d0986cae75dfe7fa12f19">redisxSubscribe</a>(redis, <span class="stringliteral">&quot;event:*&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Oops, something went wrong...</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="aredisx-sub_8c_html_a0aa27b4fce0d0986cae75dfe7fa12f19"><div class="ttname"><a href="redisx-sub_8c.html#a0aa27b4fce0d0986cae75dfe7fa12f19">redisxSubscribe</a></div><div class="ttdeci">int redisxSubscribe(Redis *redis, const char *pattern)</div><div class="ttdef"><b>Definition</b> redisx-sub.c:369</div></div>
</div><!-- fragment --><p>Now, we are capturing and processing all messages published to channels whose name begins with <code>"event:"</code>, using our custom <code>my_event_processor</code> function.</p>
<p>To end the subscription, we trace back the same steps by calling <code><a class="el" href="redisx-sub_8c.html#accafa9bf1ced851cc2e95c2d9fa1e9f8">redisxUnsubscribe()</a></code> to stop receiving further messages to the subscription channel or pattern, and by removing the <code>my_event_procesor</code> subscriber function as appropriate (provided no other subscription needs it) via <code>redisxRemoveSubscriber()</code>.</p>
<hr  />
<p><a class="anchor" id="advanced-queries"></a> </p>
<h2><a class="anchor" id="autotoc_md29"></a>
Advanced queries</h2>
<p>Sometimes you might want to micro manage how requests are sent and responses to them are received. <b>RedisX</b> provides a set of asynchronous client functions that do that. (You've seen these already further above in the <a class="el" href="index.html#pipelined-transactions">Pipelined transaction</a> section.) These functions should be called with the specific client's mutex locked, to ensure that other threads do not interfere with your sequence of requests and responses. E.g.:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedisClient.html">RedisClient</a> *cl = <a class="code hl_function" href="redisx-client_8c.html#a14907be8fba6a13505a352673cea5895">redisxGetClient</a>(...);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Obtain an exclusive lock on the client</span></div>
<div class="line"><span class="keywordtype">int</span> status = <a class="code hl_function" href="redisx-client_8c.html#ac6c9928f425b6b1d97d721cbddc3cf28">redisxLockEnabled</a>(cl);</div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Abort: the client is probably not connected</span></div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now send commands, and receive responses as you like using the redisx...Async() calls</span></div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// When done, release the lock</span></div>
<div class="line">redisxUnlockClient(cl);</div>
<div class="ttc" id="astructRedisClient_html"><div class="ttname"><a href="structRedisClient.html">RedisClient</a></div><div class="ttdoc">Structure that represents a single Redis client connection instance.</div><div class="ttdef"><b>Definition</b> redisx.h:146</div></div>
</div><!-- fragment --><p>While you have the exclusive lock you may send any number of requests, e.g. via <code><a class="el" href="redisx-client_8c.html#afc7b28288c07baf0b3c8fdc9d8ddf263">redisxSendRequestAsync()</a></code> and/or <code>redixSendArrayRequestAsync()</code>. Then collect replies either with <code><a class="el" href="redisx-client_8c.html#abc855133c2af4f5d929a05292aa634d1">redisxReadReplyAsync()</a></code> or else <code><a class="el" href="redisx-client_8c.html#ac0f30d62044638a2ead07583ad723fdf">redisxIgnoreReplyAsync()</a></code>. For example, the basic anatomy of sending a single request and then receiving a response, while we have exclusive access to the client, might look something like this:</p>
<div class="fragment"><div class="line">...</div>
<div class="line"><span class="comment">// Send a command to Redis</span></div>
<div class="line">int status = <a class="code hl_function" href="redisx-client_8c.html#afc7b28288c07baf0b3c8fdc9d8ddf263">redisxSendRequestAsync</a>(cl, ...);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(status == X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Read the response</span></div>
<div class="line">  <a class="code hl_struct" href="structRESP.html">RESP</a> *reply = <a class="code hl_function" href="redisx-client_8c.html#abc855133c2af4f5d929a05292aa634d1">redisxReadReplyAsync</a>(cl);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// check and process the response</span></div>
<div class="line">  <span class="keywordflow">if</span>(<a class="code hl_function" href="redisx_8c.html#a2d3ffb89129ab04483e3966835a5ff71">redisxCheckRESP</a>(reply, ...) != X_SUCCESS) {</div>
<div class="line">    <span class="comment">// Ooops, not the reply what we expected...</span></div>
<div class="line">    ...</div>
<div class="line">  } </div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Process the response</span></div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Destroy the reply</span></div>
<div class="line">  <a class="code hl_function" href="redisx_8c.html#aa4e23a7454f7055711915ec430599011">redisxDestroyRESP</a>(reply);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="ttc" id="aredisx-client_8c_html_abc855133c2af4f5d929a05292aa634d1"><div class="ttname"><a href="redisx-client_8c.html#abc855133c2af4f5d929a05292aa634d1">redisxReadReplyAsync</a></div><div class="ttdeci">RESP * redisxReadReplyAsync(RedisClient *cl)</div><div class="ttdef"><b>Definition</b> redisx-client.c:650</div></div>
<div class="ttc" id="aredisx_8c_html_a2d3ffb89129ab04483e3966835a5ff71"><div class="ttname"><a href="redisx_8c.html#a2d3ffb89129ab04483e3966835a5ff71">redisxCheckRESP</a></div><div class="ttdeci">int redisxCheckRESP(const RESP *resp, char expectedType, int expectedSize)</div><div class="ttdef"><b>Definition</b> redisx.c:463</div></div>
</div><!-- fragment --><p>For the best performance, you may want to leave the processing of the replies until after you unlock the client. I.e., you only block other threads from accessing the clients while you send off the requests and collect the corresponding responses. Then you leave analyzing the responses at your leisure later, and outside of the mutexed section.</p>
<p>In some cases you may be OK with just firing off some <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> commands, without necessarily caring about responses. Rather than ignoring the replies with <code><a class="el" href="redisx-client_8c.html#ac0f30d62044638a2ead07583ad723fdf">redisxIgnoreReplyAsync()</a></code> you might call <code>redisxSkiReplyAsync()</code> instead <b>before</b> <code><a class="el" href="redisx-client_8c.html#afc7b28288c07baf0b3c8fdc9d8ddf263">redisxSendRequestAsync()</a></code> to instruct <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> to not even bother about sending a response to your request (it saves time and network bandwidth!):</p>
<div class="fragment"><div class="line"><span class="comment">// We don&#39;t want to receive a response to our next command... </span></div>
<div class="line"><span class="keywordtype">int</span> status = <a class="code hl_function" href="redisx-client_8c.html#a44c5d0bd24f5a4f2f131218f14c9c599">redisxSkipReplyAsync</a>(cl);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (status == X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Now send the request...</span></div>
<div class="line">  status = redisxSendRequest(cl, ...);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">   <span class="comment">// Ooops, the request did not go through...</span></div>
<div class="line">   ...</div>
<div class="line">}</div>
<div class="ttc" id="aredisx-client_8c_html_a44c5d0bd24f5a4f2f131218f14c9c599"><div class="ttname"><a href="redisx-client_8c.html#a44c5d0bd24f5a4f2f131218f14c9c599">redisxSkipReplyAsync</a></div><div class="ttdeci">int redisxSkipReplyAsync(RedisClient *cl)</div><div class="ttdef"><b>Definition</b> redisx-client.c:379</div></div>
</div><!-- fragment --><p>Of course you can build up arbitrarily complex set of queries and deal with a set of responses in different ways. Do what works best for your application.</p>
<hr  />
<p><a class="anchor" id="atomic-transaction-blocks-and-lua-scripts"></a> </p>
<h2><a class="anchor" id="autotoc_md31"></a>
Atomic execution blocks and LUA scripts</h2>
<ul>
<li><a class="el" href="index.html#execution-blocks">Execution blocks</a></li>
<li><a class="el" href="index.html#lua-script-loading-and-execution">LUA script loading and execution</a></li>
<li><a class="el" href="index.html#custom-functions">Custom functions</a></li>
</ul>
<p>Sometimes you may want to execute a series of <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> command atomically, such that nothing else may alter the database while the set of commands execute, so that related values are always in a coherent state. For example, you want to set or query a collection of related variables so they change together and are reported together. You have two choices. (1) you can execute the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> commands in an execution block, or else (2) load a LUA script onto the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server and call it with some parameters (possibly many times over).</p>
<p><a class="anchor" id="execution-blocks"></a> </p>
<h3><a class="anchor" id="autotoc_md32"></a>
Execution blocks</h3>
<p>Execution blocks offer a fairly simple way of bunching together a set of <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> commands that need to be executed atomically. Such an execution block in RedisX may look something like:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...;</div>
<div class="line"><a class="code hl_struct" href="structRESP.html">RESP</a> *result;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Obtain a lock on the client on which to execute the block.</span></div>
<div class="line"><span class="comment">// e.g. the INTERACTIVE_CHANNEL</span></div>
<div class="line"><a class="code hl_struct" href="structRedisClient.html">RedisClient</a> *cl = <a class="code hl_function" href="redisx-client_8c.html#a14907be8fba6a13505a352673cea5895">redisxGetClient</a>(redis, <a class="code hl_enumvalue" href="redisx_8h.html#a5349b7340813fbd1e32d04ed650bc3d9a414a7601469647f3a8827a3908c2c358">INTERACTIVE_CHANNEL</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> status = <a class="code hl_function" href="redisx-client_8c.html#ac6c9928f425b6b1d97d721cbddc3cf28">redisxLockEnabled</a>(cl);</div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Abort: we don&#39;t have exclusive access to the client</span></div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// -------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Start an atomic execution block</span></div>
<div class="line"><a class="code hl_function" href="redisx-client_8c.html#a3e49508e4e4fcc283832226fd1bffd85">redisxStartBlockAsync</a>(cl);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send a number of Async requests</span></div>
<div class="line"><a class="code hl_function" href="redisx-client_8c.html#afc7b28288c07baf0b3c8fdc9d8ddf263">redisxSendRequestAsync</a>(cl, ...);</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Execute the block of commands above atomically, and get the resulting RESP</span></div>
<div class="line">result = <a class="code hl_function" href="redisx-client_8c.html#a6fed65f9413569c771d5165a0194477a">redisxExecBlockAsync</a>(cl);</div>
<div class="line"><span class="comment">// -------------------------------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Release exlusive access to the client</span></div>
<div class="line"><a class="code hl_function" href="redisx-client_8c.html#a87efe53c80fcff3fcf189362cbc602f7">redisxUnlockClient</a>(cl);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Inspect the RESP, etc...</span></div>
<div class="line">... </div>
<div class="ttc" id="aredisx-client_8c_html_a3e49508e4e4fcc283832226fd1bffd85"><div class="ttname"><a href="redisx-client_8c.html#a3e49508e4e4fcc283832226fd1bffd85">redisxStartBlockAsync</a></div><div class="ttdeci">int redisxStartBlockAsync(RedisClient *cl)</div><div class="ttdef"><b>Definition</b> redisx-client.c:414</div></div>
<div class="ttc" id="aredisx-client_8c_html_a6fed65f9413569c771d5165a0194477a"><div class="ttname"><a href="redisx-client_8c.html#a6fed65f9413569c771d5165a0194477a">redisxExecBlockAsync</a></div><div class="ttdeci">RESP * redisxExecBlockAsync(RedisClient *cl)</div><div class="ttdef"><b>Definition</b> redisx-client.c:467</div></div>
<div class="ttc" id="aredisx_8h_html_a5349b7340813fbd1e32d04ed650bc3d9a414a7601469647f3a8827a3908c2c358"><div class="ttname"><a href="redisx_8h.html#a5349b7340813fbd1e32d04ed650bc3d9a414a7601469647f3a8827a3908c2c358">INTERACTIVE_CHANNEL</a></div><div class="ttdeci">@ INTERACTIVE_CHANNEL</div><div class="ttdoc">Redis channel number for interactive queries.</div><div class="ttdef"><b>Definition</b> redisx.h:110</div></div>
</div><!-- fragment --><p>If at any point things don't go according to plan in the middle of the block, you can call <code>redisAbortBlockAsync()</code> to abort and discard all prior commands submitted in the execution block already. It is important to remembet that every time you call <code><a class="el" href="redisx-client_8c.html#a3e49508e4e4fcc283832226fd1bffd85">redisxStartBlockAsync()</a></code>, you must call either <code><a class="el" href="redisx-client_8c.html#a6fed65f9413569c771d5165a0194477a">redisxExecBlockAsync()</a></code> to execute it or else <code><a class="el" href="redisx-client_8c.html#ab98b0e71d2d0941920e3097a66eae7b8">redisxAbortBlockAsync()</a></code> to discard it. Failure to do so, will effectively end you up with a hung <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> client.</p>
<p><a class="anchor" id="lua-script-loading-and-execution"></a> </p>
<h3><a class="anchor" id="autotoc_md33"></a>
LUA script loading and execution</h3>
<p><a href="https://www.lua.org/">LUA</a> scripting offers a more capable version of executing complex routines on the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server. LUA is a scripting language akin to python, and allows you to add extra logic, string manipulation etc. to your <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> queries. Best of all, once you upload the script to the server, it can reduce network traffic significantly by not having to repeatedly submit the same set of <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> commands every single time. LUA scipts also get executed very efficiently on the server, and produce only the result you want/need.</p>
<p>Assuming you have prepared your LUA script appropriately, you can upload it to the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server as:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line">char *script = ...         <span class="comment">// The LUA script as a 0-terminated string.</span></div>
<div class="line"><span class="keywordtype">char</span> *scriptSHA1 = NULL;   <span class="comment">// We&#39;ll store the SHA1 sum of the script here</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Load the script onto the Redis server</span></div>
<div class="line"><span class="keywordtype">int</span> status = redixLoadScript(redis, script, &amp;scriptSHA1);</div>
<div class="line"><span class="keywordflow">if</span>(status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Oops, something went wrong...</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> will refer to the script by its SHA1 sum, so it's important keep a record of it. You'll call the script with its SHA1 sum, a set of redis keys the script may use, and a set of other parameters it might need.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line">int status;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Execute the script, with one redis key argument (and no parameters)...</span></div>
<div class="line"><a class="code hl_struct" href="structRESP.html">RESP</a> *r = <a class="code hl_function" href="redisx_8c.html#a09092bd97eead5c5fa73fa0d9241018c">redisxRequest</a>(<span class="stringliteral">&quot;EVALSHA&quot;</span>, scriptSHA1, <span class="stringliteral">&quot;1&quot;</span>, <span class="stringliteral">&quot;my-redis-key-argument&quot;</span>, &amp;status);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check status and inspect RESP</span></div>
<div class="line">...</div>
</div><!-- fragment --><p>Clearly, if you have additional <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> key arguments and/or parameters to pass to the script, you'll have to use <code><a class="el" href="redisx_8c.html#a13ae33bc25ee03621b23541236ef5f82">redisxArrayRequest()</a></code>, instead.</p>
<p>One thing to keep in mind about LUA scripts is that they are not persistent. They are lost each time the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server is restarted.</p>
<p><a class="anchor" id="custom-functions"></a> </p>
<h3><a class="anchor" id="autotoc_md34"></a>
Custom functions</h3>
<p>Functions, introduced in <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> 7, offer another evolutionary step over the LUA scripting described above. Unlike scripts, functions are persistent and they can be called by name rather than a cryptic SHA1 sum. Otherwise, they offer more or less the same functionality as scripts. <b>RedisX</b> does not currently have a built-in high-level support for managing and calling user-defined functions, but it is a feature that may be added in the not-too-distant future. Stay tuned.</p>
<hr  />
<p><a class="anchor" id="error-handling"></a> </p>
<h2><a class="anchor" id="autotoc_md36"></a>
Error handling</h2>
<p>The principal error handling of RedisX is an extension of that of <b>xchange</b>, with further error codes defined in <code><a class="el" href="redisx_8h.html">redisx.h</a></code>. The RedisX functions that return an error status (either directly, or into the integer designated by a pointer argument), can be inspected by <code><a class="el" href="redisx_8c.html#a38f3de77ad5a48d37b302bce2e3cd25b">redisxErrorDescription()</a></code>, e.g.:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis ...</div>
<div class="line">int status = <a class="code hl_function" href="redisx-tab_8c.html#aaf4dbea72c62bad0ed91800db9644cd9">redisxSetValue</a>(...);</div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Ooops, something went wrong...</span></div>
<div class="line">  fprintf(stderr, <span class="stringliteral">&quot;WARNING! set value: %s&quot;</span>, redisErrorDescription(status));</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>In addition you can define your own handler function to deal with transmission (send/receive) errors, by defining your own <code>RedisErrorHandler</code> function, such as:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> my_error_handler(<a class="code hl_struct" href="structRedis.html">Redis</a> *redis, <span class="keyword">enum</span> <a class="code hl_enumeration" href="redisx_8h.html#a5349b7340813fbd1e32d04ed650bc3d9">redisx_channel</a> channel, <span class="keyword">const</span> <span class="keywordtype">char</span> *op) {</div>
<div class="line">  fprintf(stderr, <span class="stringliteral">&quot;ERROR! %s: Redis at %s, channel %d\n&quot;</span>, op, redis-&gt;<a class="code hl_variable" href="structRedis.html#aecb3b0d045ada529257a2fbf8f829599">id</a>, channel);</div>
<div class="line">}</div>
<div class="ttc" id="aredisx_8h_html_a5349b7340813fbd1e32d04ed650bc3d9"><div class="ttname"><a href="redisx_8h.html#a5349b7340813fbd1e32d04ed650bc3d9">redisx_channel</a></div><div class="ttdeci">redisx_channel</div><div class="ttdef"><b>Definition</b> redisx.h:109</div></div>
</div><!-- fragment --><p>Then activate it as:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line">redisSetTransmitErrorHandler(redis, my_error_handler);</div>
</div><!-- fragment --><p>After that, every time there is an error with sending or receiving packets over the network to any of the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> clients used, your handler will report it the way you want it.</p>
<hr  />
<p><a class="anchor" id="debug-support"></a> </p>
<h2><a class="anchor" id="autotoc_md38"></a>
Debug support</h2>
<p>The <b>xchange</b> library provides two macros: <code><a class="elRef" href="../../xchange/apidoc/html/xchange_8h.html#a1f038bf7ddb58819805cfc44162cb403">xvprintf()</a></code> and <code><a class="elRef" href="../../xchange/apidoc/html/xchange_8h.html#a2b0edfea798e9e08122f09dba5f189f8">xdprintf()</a></code>, for printing verbose and debug messages to <code>stderr</code>. Both work just like <code>printf()</code>, but they are conditional on verbosity being enabled via <code><a class="el" href="redisx_8c.html#a11454a2359f43b6fd024d25a8148644e">redisxSetVerbose(boolean)</a></code> and the global variable <code>xDebug</code> being <code>TRUE</code> (non-zero), respectively. Applications using <b>RedisX</b> may use these macros to produce their own verbose and/or debugging outputs conditional on the same global settings.</p>
<p>You can also turn debug messages by defining the <code>DEBUG</code> constant for the compiler, e.g. by adding <code>-DDEBUG</code> to <code>CFLAGS</code> prior to calling <code>make</code>.</p>
<hr  />
<p><a class="anchor" id="future-plans"></a> </p>
<h2><a class="anchor" id="autotoc_md40"></a>
Future plans</h2>
<p>Some obvious ways the library could evolve and grow in the not too distant future:</p>
<ul>
<li>Automated regression testing and coverage tracking.</li>
<li>Support for the <a href="https://github.com/antirez/RESP3/blob/master/spec.md">RESP3</a> standard and <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> <code>HELLO</code>.</li>
<li>Support for <a href="https://redis.io/docs/latest/develop/reference/sentinel-clients/">Redis Sentinel</a> clients, for high-availability server configurations.</li>
<li>TLS support (perhaps...)</li>
<li>Add high-level support for managing and calling custom <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> functions.</li>
<li>Add support for <code>CLIENT TRACKING</code> / <code>CLIENT CACHING</code>.</li>
<li>Add more high-level redis commands, e.g. for lists, streams, etc.</li>
<li>Improved debug capabilities (e.g. with built-in error traces)</li>
<li>Improved error handling (e.g. by consistently setting <code>errno</code> beyond just the <b>RedisX</b> error status).</li>
</ul>
<p>If you have an idea for a must have feature, please let me (Attila) know. Pull requests, for new features or fixes to existing ones are especially welcome!</p>
<hr  />
<p> Copyright (C) 2024 Attila Kov√°cs </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
