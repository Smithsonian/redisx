<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta charset="utf-8"/>
<meta name="description" content="A light-weight Redis client library for C/C++"/>
<meta name="keywords" content="Redis client library, C, C++, C99, software library, open source"/>
<meta name="author" content="Attila Kovacs"/>
<meta name="copyright" content="(C)2024 Attila Kovacs" />
<meta name="robots" content="index,follow"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2L0MEN3Z8Q"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-2L0MEN3Z8Q');
</script>
<link rel="shortcut icon" type="image/x-icon" href="/redisx/resources/favicon.ico" />
<link rel="icon" type="image/png" sizes="192x192" href="/redisx/resources/android-chrome-192x192.png" />
<link rel="icon" type="image/png" sizes="512x512" href="/redisx/resources/android-chrome-512x512.png" />
<link rel="apple-touch-icon" type="image/png" href="/redisx/resources/apple-touch-icon.png" />
<title>RedisX: RedisX</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="smithsonian-logo-55x55.png"/></td>
  <td id="projectalign">
   <div id="projectname">RedisX<span id="projectnumber">&#160;v0.9</span>
   </div>
   <div id="projectbrief">A simple, light-weight Redis database client</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">RedisX </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README-redisx"></a> A free, simple, and light-weight C/C++ <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> / Valkey client library.</p>
<ul>
<li><a href="https://smithsonian.github.io/redisx/apidoc/html/files.html">API documentation</a></li>
<li><a href="https://smithsonian.github.io/redisx">Project page</a> on github.io</li>
</ul>
<p>Author: Attila Kovacs</p>
<p>Last Updated: 13 December 2024</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Table of Contents</h2>
<ul>
<li><a class="el" href="index.html#introduction">Introduction</a></li>
<li><a class="el" href="index.html#prerequisites">Prerequisites</a></li>
<li><a class="el" href="index.html#building-redisx">Building RedisX</a></li>
<li><a class="el" href="index.html#redisx-cli">Command-line interface (`redisx-cli`)</a></li>
<li><a class="el" href="index.html#linking">Linking your application against RedisX</a></li>
<li><a class="el" href="index.html#managing-redis-server-connections">Managing Redis server connections</a></li>
<li><a class="el" href="index.html#simple-redis-queries">Simple Redis queries</a></li>
<li><a class="el" href="index.html#accessing-key-value-data">Accessing key / value data</a></li>
<li><a class="el" href="index.html#publish-subscribe-support">Publish / subscribe (PUB/SUB) support</a></li>
<li><a class="el" href="index.html#atomic-transaction-blocks-and-lua-scripts">Atomic execution blocks and LUA scripts</a></li>
<li><a class="el" href="index.html#advanced-queries">Advanced queries and pipelining</a></li>
<li><a class="el" href="index.html#error-handling">Error handling</a></li>
<li><a class="el" href="index.html#debug-support">Debug support</a></li>
<li><a class="el" href="index.html#future-plans">Future plans</a></li>
</ul>
<p><a class="anchor" id="introduction"></a> </p>
<h2><a class="anchor" id="autotoc_md4"></a>
Introduction</h2>
<p><b>RedisX</b> is a free, light-weight <a href="https://redis.io">Redis</a> client library for C/C++. As such, it should work with <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> forks / clones like <a href="https://dragonfly.io">Dragonfly</a> or <a href="https://valkey.io">Valkey</a> also. It supports both interactive and pipelined <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> queries, managing and processing subscriptions, atomic execution blocks, and LUA scripts loading. It can be used with multiple <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> servers simultaneously also. <b>RedisX</b> is free to use, in any way you like, without licensing restrictions.</p>
<p>While there are other C/C++ <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> clients available, this one is C99 compatible, and hence can be used on older platforms also. It is also small and fast, but still capable and versatile.</p>
<p>Rather than providing high-level support for every possible <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> command (which would probably be impossible given the pace new commands are being introduced all the time), it provides a basic framework for synchronous and asynchronous queries, with some higher-level functions, such as for managing key/value storage types (including hash tables) and PUB/SUB. Future releases may add further higher-level functionality based on demand for such features.</p>
<p>The <b>RedisX</b> library was created, and is maintained, by Attila Kov√°cs at the Center for Astrophysics | Harvard &amp; Smithsonian, and it is available through the <a href="https://github.com/Smithsonian/redisx">Smithsonian/redisx</a> repository on GitHub.</p>
<p>There are no official releases of <b>RedisX</b> yet. An initial 1.0.0 release is expected in late 2024 or early 2025. Before then the API may undergo slight changes and tweaks. Use the repository as is at your own risk for now.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Features overview</h3>
<h4><a class="anchor" id="autotoc_md6"></a>
Generic API Features</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Feature   </th><th class="markdownTableHeadCenter">supported   </th><th class="markdownTableHeadNone">comments    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">concurrent <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> instances   </td><td class="markdownTableBodyCenter"><b>yes</b>   </td><td class="markdownTableBodyNone">You can manage and use multiple <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> servers simultaneously    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">connect over TCP   </td><td class="markdownTableBodyCenter"><b>yes</b>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">connect over UDP   </td><td class="markdownTableBodyCenter">no   </td><td class="markdownTableBodyNone">(why would you, really?)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">connect / disconnect hooks   </td><td class="markdownTableBodyCenter"><b>yes</b>   </td><td class="markdownTableBodyNone">user-defined callbacks    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">custom socket setup   </td><td class="markdownTableBodyCenter"><b>yes</b>   </td><td class="markdownTableBodyNone">user-defined timeout and buffer size and/or callback    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">custom socket error handling   </td><td class="markdownTableBodyCenter"><b>yes</b>   </td><td class="markdownTableBodyNone">user-defined callback    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> to JSON   </td><td class="markdownTableBodyCenter"><b>yes</b>   </td><td class="markdownTableBodyNone">via <code>xchange</code> library    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> to structured data   </td><td class="markdownTableBodyCenter"><b>yes</b>   </td><td class="markdownTableBodyNone">via <code>xchange</code> library    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">debug error tracing   </td><td class="markdownTableBodyCenter"><b>yes</b>   </td><td class="markdownTableBodyNone">via <code><a class="elRef" href="../../xchange/apidoc/html/xchange_8h.html#a6c1304b59a5882b2286e86c6837faead">xSetDebug()</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">command-line client   </td><td class="markdownTableBodyCenter"><b>yes</b>   </td><td class="markdownTableBodyNone"><code>redisx-cli</code>   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md7"></a>
Redis / Valkey Features</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> / Valkey Feature   </th><th class="markdownTableHeadCenter">supported   </th><th class="markdownTableHeadNone">comments    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">user authentication   </td><td class="markdownTableBodyCenter"><b>yes</b>   </td><td class="markdownTableBodyNone">via <code>HELLO</code> if protocol is set, otherwise via <code>AUTH</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">RESP3 / <code>HELLO</code> support   </td><td class="markdownTableBodyCenter"><b>yes</b>   </td><td class="markdownTableBodyNone">optional (if specific protocol is set)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">thread safe (MT-safe)   </td><td class="markdownTableBodyCenter"><b>yes</b>   </td><td class="markdownTableBodyNone">synchronized + async calls with locking    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">push messages   </td><td class="markdownTableBodyCenter"><b>yes</b>   </td><td class="markdownTableBodyNone">user-defined callback    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">attributes   </td><td class="markdownTableBodyCenter"><b>yes</b>   </td><td class="markdownTableBodyNone">on demand    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">interactive queries   </td><td class="markdownTableBodyCenter"><b>yes</b>   </td><td class="markdownTableBodyNone">dedicated (low-latency) client    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">pipelined (batch) processing   </td><td class="markdownTableBodyCenter"><b>yes</b>   </td><td class="markdownTableBodyNone">dedicated (high-bandwidth) client / user-defined callback    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">PUB/SUB support   </td><td class="markdownTableBodyCenter"><b>yes</b>   </td><td class="markdownTableBodyNone">dedicated client / user callbacks / subscription management    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Sentinel support   </td><td class="markdownTableBodyCenter"><b>yes</b>   </td><td class="markdownTableBodyNone"><em>help me test it</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cluster support   </td><td class="markdownTableBodyCenter">no   </td><td class="markdownTableBodyNone"><em>coming soon...</em>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TLS support   </td><td class="markdownTableBodyCenter">no   </td><td class="markdownTableBodyNone"><em>coming soon...</em>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">resubscribe on reconnect   </td><td class="markdownTableBodyCenter">no   </td><td class="markdownTableBodyNone"></td></tr>
</table>
<h3><a class="anchor" id="autotoc_md8"></a>
Related links</h3>
<ul>
<li><a href="https://redis.io/docs/latest/commands/">Redis commands</a> (reference documentation)</li>
<li><a href="https://docs.google.com/document/d/1eYbWDClKkV7JnJxv4MxuNBNV47dFXuUWu7C4Ve_YTf0/edit?usp=sharing">SMA eXchange (SMA-X)</a> &ndash; A structured realtime database built on <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> / Valkey.<ul>
<li><a href="https://github.com/Smithsonian/smax-server">Smithsonian/smax-server</a> &ndash; SMA-X server configuration kit</li>
<li><a href="https://github.com/Smithsonian/smax-clib">Smithsonian/smax-clib</a> &ndash; A C/C++ client library and toolkit to SMA-X, based on <b>RedisX</b></li>
<li><a href="https://github.com/Smithsonian/smax-python">Smithsonian/smax-python</a> &ndash; A Python 3 client library to SMA-X</li>
</ul>
</li>
</ul>
<hr  />
<p><a class="anchor" id="prerequisites"></a> </p>
<h2><a class="anchor" id="autotoc_md10"></a>
Prerequisites</h2>
<p>The <a href="https://github.com/Smithsonian/xchange">Smithsonian/xchange</a> library is both a build and a runtime dependency of RedisX.</p>
<p>Additionally <code>redisx-cli</code> has the following dependencies on standard GNU/POSIX libraries:</p>
<ul>
<li>POPT (<code>popt-devel</code> on RPM-based, or <code>libpopt-dev</code> on Debian based Linux).</li>
<li>BSD (<code>libbsd-devel</code> on RPM-based, or <code>libbsd-dev</code> on Debian based Linux).</li>
<li>readline (<code>readline-devel</code> on RPM based, or <code>libreadline-dev</code> on Debian based Linux).</li>
</ul>
<hr  />
<p><a class="anchor" id="building-redisx"></a> </p>
<h2><a class="anchor" id="autotoc_md12"></a>
Building RedisX</h2>
<p>The <b>RedisX</b> library can be built either as a shared (<code>libredisx.so[.1]</code>) or as a static (<code>libredisx.a</code>) library, depending on what suits your needs best.</p>
<p>You can configure the build, either by editing <code>config.mk</code> or else by defining the relevant environment variables prior to invoking <code>make</code>. The following build variables can be configured:</p>
<ul>
<li><code>CC</code>: The C compiler to use (default: <code>gcc</code>).</li>
<li><code>CPPFLAGS</code>: C preprocessor flags, such as externally defined compiler constants.</li>
<li><code>CFLAGS</code>: Flags to pass onto the C compiler (default: <code>-g -Os -Wall</code>). Note, <code>-Iinclude</code> will be added automatically.</li>
<li><code>CSTANDARD</code>: Optionally, specify the C standard to compile for, e.g. <code>c99</code> to compile for the C99 standard. If defined then <code>-std=$(CSTANDARD)</code> is added to <code>CFLAGS</code> automatically.</li>
<li><code>WEXTRA</code>: If set to 1, <code>-Wextra</code> is added to <code>CFLAGS</code> automatically.</li>
<li><code>LDFLAGS</code>: Extra linker flags (default is <em>not set</em>). Note, <code>-lm -lxchange</code> will be added automatically.</li>
<li><code>CHECKEXTRA</code>: Extra options to pass to <code>cppcheck</code> for the <code>make check</code> target</li>
<li><code>XCHANGE</code>: If the <a href="https://github.com/Smithsonian/xchange">Smithsonian/xchange</a> library is not installed on your system (e.g. under <code>/usr</code>) set <code>XCHANGE</code> to where the distribution can be found. The build will expect to find <code><a class="elRef" href="../../xchange/apidoc/html/xchange_8h.html">xchange.h</a></code> under <code>$(XCHANGE)/include</code> and <code>libxchange.so</code> / <code>libxchange.a</code> under <code>$(XCHANGE)/lib</code> or else in the default <code>LD_LIBRARY_PATH</code>.</li>
</ul>
<p>After configuring, you can simply run <code>make</code>, which will build the <code>shared</code> (<code>lib/libredisx.so[.1]</code>) and <code>static</code> (<code>lib/libredisx.a</code>) libraries, local HTML documentation (provided <code>doxygen</code> is available), and performs static analysis via the <code>check</code> target. Or, you may build just the components you are interested in, by specifying the desired <code>make</code> target(s). (You can use <code>make help</code> to get a summary of the available <code>make</code> targets).</p>
<p>After building the library you can install the above components to the desired locations on your system. For a system-wide install you may simply run:</p>
<div class="fragment"><div class="line">$ sudo make install</div>
</div><!-- fragment --><p>Or, to install in some other locations, you may set a prefix and/or <code>DESTDIR</code>. For example, to install under <code>/opt</code> instead, you can:</p>
<div class="fragment"><div class="line">$ sudo make prefix=&quot;/opt&quot; install</div>
</div><!-- fragment --><p>Or, to stage the installation (to <code>/usr</code>) under a 'build root':</p>
<div class="fragment"><div class="line">$ make DESTDIR=&quot;/tmp/stage&quot; install</div>
</div><!-- fragment --><hr  />
<p><a class="anchor" id="redisx-cli"></a> </p>
<h2><a class="anchor" id="autotoc_md14"></a>
Command-line interface (&lt;tt&gt;redisx-cli&lt;/tt&gt;)</h2>
<p>The <b>RedisX</b> library provides its own command-line tool, called <code>redisx-cli</code>. It works very similar to <code>redis-cli</code>, except that our client has somewhat fewer bells and whistles.</p>
<div class="fragment"><div class="line">$ redisx-cli ping &quot;Hello World&quot;</div>
</div><!-- fragment --><p> will print:</p>
<div class="fragment"><div class="line">&quot;Hello world!&quot;</div>
</div><!-- fragment --><p>provided it successfully connected to the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> / Valkey server on localhost. (Otherwise it will print an error and a trace). It can also be used in interactive mode if no <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> command arguments are supplied. And, you can run <code>redisx-cli --help</code> to see what options are available, and you can also consult the <a href="https://redis.io/docs/latest/develop/tools/cli/">redis-cli</a> documentation for the same general description and usage (so far as our implementation supports it).</p>
<hr  />
<p><a class="anchor" id="linking"></a> </p>
<h2><a class="anchor" id="autotoc_md16"></a>
Linking your application against RedisX</h2>
<p>Provided you have installed the shared (<code>libredisx.so</code> and <code>libxchange.so</code>) or static (<code>libredisx.a</code> and <code>libxchange.a</code>) libraries in a location that is in your <code>LD_LIBRARY_PATH</code> (e.g. in <code>/usr/lib</code> or <code>/usr/local/lib</code>) you can simply link your program using the <code>-lredisx -lxchange</code> flags. Your <code>Makefile</code> may look like:</p>
<div class="fragment"><div class="line">myprog: ...</div>
<div class="line">    $(CC) -o $@ $^ $(LDFLAGS) -lredisx -lxchange </div>
</div><!-- fragment --><p>(Or, you might simply add <code>-lredisx -lxchange</code> to <code>LDFLAGS</code> and use a more standard recipe.) And, in if you installed the <b>RedisX</b> and/or <b>xchange</b> libraries elsewhere, you can simply add their location(s) to <code>LD_LIBRARY_PATH</code> prior to linking.</p>
<hr  />
<p><a class="anchor" id="managing-redis-server-connections"></a> </p>
<h2><a class="anchor" id="autotoc_md18"></a>
Managing Redis server connections</h2>
<ul>
<li><a class="el" href="index.html#initializing">Initializing</a></li>
<li><a class="el" href="index.html#configuring">Configuring</a></li>
<li><a class="el" href="index.html#connecting">Connecting</a></li>
<li><a class="el" href="index.html#disconnecting">Disconnecting</a></li>
</ul>
<p>The library maintains up to three separate connections (channels) for each separate <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server instance used: (1) an interactive client for sequential round-trip transactions, (2) a pipeline client for bulk queries and asynchronous background processing, and (3) a subscription client for PUB/SUB requests and notifications. The interactive client is always connected, the pipeline client is connected only if explicitly requested at the time of establishing the server connection, while the subscription client is connected only as needed.</p>
<p><a class="anchor" id="initializing"></a> </p>
<h3><a class="anchor" id="autotoc_md19"></a>
Initializing</h3>
<p>The first step is to create a <code><a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a></code> object, with the server name or IP address.</p>
<div class="fragment"><div class="line"><span class="comment">// Configure the redis server to connect to &quot;redis.mydomain.com&quot;.</span></div>
<div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = <a class="code hl_function" href="redisx-net_8c.html#a5c78c2189a76a077231016564a0cecd5">redisxInit</a>(<span class="stringliteral">&quot;redis.mydomain.com&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (redis == NULL) {</div>
<div class="line">  <span class="comment">// Abort: something did not got to plan...</span></div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (optional) configure a non-standard port number to use</span></div>
<div class="line"><a class="code hl_function" href="redisx-net_8c.html#a37f39ede48014a2463e4c72bf6eb5a3e">redisxSetPort</a>(redis, 7089);</div>
<div class="ttc" id="aredisx-net_8c_html_a37f39ede48014a2463e4c72bf6eb5a3e"><div class="ttname"><a href="redisx-net_8c.html#a37f39ede48014a2463e4c72bf6eb5a3e">redisxSetPort</a></div><div class="ttdeci">int redisxSetPort(Redis *redis, int port)</div><div class="ttdef"><b>Definition</b> redisx-net.c:1050</div></div>
<div class="ttc" id="aredisx-net_8c_html_a5c78c2189a76a077231016564a0cecd5"><div class="ttname"><a href="redisx-net_8c.html#a5c78c2189a76a077231016564a0cecd5">redisxInit</a></div><div class="ttdeci">Redis * redisxInit(const char *server)</div><div class="ttdef"><b>Definition</b> redisx-net.c:794</div></div>
<div class="ttc" id="astructRedis_html"><div class="ttname"><a href="structRedis.html">Redis</a></div><div class="ttdoc">Structure that represents a Redis database instance, with one or more RedisClient connections.</div><div class="ttdef"><b>Definition</b> redisx.h:229</div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md20"></a>
Sentinel</h4>
<p>Alternatively, instead of <code><a class="el" href="redisx-net_8c.html#a5c78c2189a76a077231016564a0cecd5">redisxInit()</a></code> above you may initialize the client for a high-availability configuration using with a set of <a href="https://redis.io/docs/latest/develop/reference/sentinel-clients/">Redis Sentinel</a> servers, using <code><a class="el" href="redisx-net_8c.html#a993ae780daeae021fba1866d752ba9c5">redisxInitSentinel()</a></code>, e.g.:</p>
<div class="fragment"><div class="line"><span class="comment">// An array defining N sentinel servers and ports to use.</span></div>
<div class="line"><span class="comment">// A port number 0 or negative will use the default Redis port of 6379.</span></div>
<div class="line"><a class="code hl_struct" href="structRedisServer.html">RedisServer</a> sentinels[N] = { { <span class="stringliteral">&quot;server1&quot;</span>, 0 }, { <span class="stringliteral">&quot;server2&quot;</span>, 7024 } ... };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Configure a Redis client instance for the Sentinel servers and &quot;my-service&quot; service name</span></div>
<div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = <a class="code hl_function" href="redisx-net_8c.html#a993ae780daeae021fba1866d752ba9c5">redisxInitSentinel</a>(sentinels, N, <span class="stringliteral">&quot;my-service&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (redis == NULL) {</div>
<div class="line">  <span class="comment">// Abort: something did not got to plan...</span></div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (optional) set a sentinel discovery timeout in ms...</span></div>
<div class="line"><a class="code hl_function" href="redisx-net_8c.html#a192ba03de94c1e8a1876d7c533b4df9a">redisxSetSentinelTimeout</a>(redis, 30);</div>
<div class="ttc" id="aredisx-net_8c_html_a192ba03de94c1e8a1876d7c533b4df9a"><div class="ttname"><a href="redisx-net_8c.html#a192ba03de94c1e8a1876d7c533b4df9a">redisxSetSentinelTimeout</a></div><div class="ttdeci">int redisxSetSentinelTimeout(Redis *redis, int millis)</div><div class="ttdef"><b>Definition</b> redisx-net.c:943</div></div>
<div class="ttc" id="aredisx-net_8c_html_a993ae780daeae021fba1866d752ba9c5"><div class="ttname"><a href="redisx-net_8c.html#a993ae780daeae021fba1866d752ba9c5">redisxInitSentinel</a></div><div class="ttdeci">Redis * redisxInitSentinel(const char *serviceName, const RedisServer *serverList, int nServers)</div><div class="ttdef"><b>Definition</b> redisx-net.c:897</div></div>
<div class="ttc" id="astructRedisServer_html"><div class="ttname"><a href="structRedisServer.html">RedisServer</a></div><div class="ttdef"><b>Definition</b> redisx.h:208</div></div>
</div><!-- fragment --><p>After successful initialization, you may proceed with the configuration the same way as for the regular standalone server connection.</p>
<p>One thing to keep in mind about Sentinel is that once the connection to the master is established, it works just like a regular server connection, including the possibility of that connection being broken. It is up to the application to initiate reconnection and recovery as appropriate in case of errors. (See more in on <a class="el" href="index.html#reconnecting">Reconnecting</a> further below).</p>
<p><a class="anchor" id="configuring"></a> </p>
<h3><a class="anchor" id="autotoc_md21"></a>
Configuring</h3>
<p>Before connecting to the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server, you may configure the database authentication (if any):</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (optional) Configure the database user (since Redis 6.0, using ACL)</span></div>
<div class="line">redisxSetUser(redis, <span class="stringliteral">&quot;johndoe&quot;</span>); </div>
<div class="line"> </div>
<div class="line"><span class="comment">// (optional) Configure the database password...</span></div>
<div class="line"><a class="code hl_function" href="redisx_8c.html#a0e9eda38aa6f084ac151cbebe2886c2f">redisxSetPassword</a>(redis, mySecretPasswordString);</div>
<div class="ttc" id="aredisx_8c_html_a0e9eda38aa6f084ac151cbebe2886c2f"><div class="ttname"><a href="redisx_8c.html#a0e9eda38aa6f084ac151cbebe2886c2f">redisxSetPassword</a></div><div class="ttdeci">int redisxSetPassword(Redis *redis, const char *passwd)</div><div class="ttdef"><b>Definition</b> redisx.c:162</div></div>
</div><!-- fragment --><p>You can also set the <a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> protocol to use (provided your server is compatible with <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> 6 or later):</p>
<div class="fragment"><div class="line"><span class="comment">// (optional) Use RESP3 (provided the server supports it)</span></div>
<div class="line"><a class="code hl_function" href="redisx_8c.html#a842cfeb16ae3cb690cb40c5b006dd918">redisxSetProtocol</a>(redis, <a class="code hl_enumvalue" href="redisx_8h.html#ae63bc3e31da55ad4e1603d9302f41cccacd031421d135447f8d1b1422966c8277">REDISX_RESP3</a>);</div>
<div class="ttc" id="aredisx_8c_html_a842cfeb16ae3cb690cb40c5b006dd918"><div class="ttname"><a href="redisx_8c.html#a842cfeb16ae3cb690cb40c5b006dd918">redisxSetProtocol</a></div><div class="ttdeci">int redisxSetProtocol(Redis *redis, enum redisx_protocol protocol)</div><div class="ttdef"><b>Definition</b> redisx.c:194</div></div>
<div class="ttc" id="aredisx_8h_html_ae63bc3e31da55ad4e1603d9302f41cccacd031421d135447f8d1b1422966c8277"><div class="ttname"><a href="redisx_8h.html#ae63bc3e31da55ad4e1603d9302f41cccacd031421d135447f8d1b1422966c8277">REDISX_RESP3</a></div><div class="ttdeci">@ REDISX_RESP3</div><div class="ttdoc">RESP3 protocol (since Redis version 6.0.0)</div><div class="ttdef"><b>Definition</b> redisx.h:153</div></div>
</div><!-- fragment --><p>The above call will use the <code>HELLO</code> command (since <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> 6) upon connecting. If you do not set the protocol, <code>HELLO</code> will not be used, and RESP2 will be assumed &ndash; which is best for older servers (<a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> &lt;6). (Note, that you can always check the actual protocol used after connecting, using <code><a class="el" href="redisx_8c.html#af756044530dd5b424ec64e89e22eb0a0">redisxGetProtocol()</a></code>). Note, that after connecting, you may retrieve the set of server properties sent in response to <code>HELLO</code> using <code><a class="el" href="redisx_8c.html#a89fd65118ba731931fe281c83f6fa8ba">redisxGetHelloData()</a></code>.</p>
<p>Optionally, you can select the database index to use now (or later, after connecting), if not the default (index 0):</p>
<div class="fragment"><div class="line"><span class="comment">// (optional) Select the database index 2</span></div>
<div class="line"><a class="code hl_function" href="redisx_8c.html#aec99fb8b19d6751038bf9c4c6d04f8d0">redisxSelectDB</a>(redis, 2); </div>
<div class="ttc" id="aredisx_8c_html_aec99fb8b19d6751038bf9c4c6d04f8d0"><div class="ttname"><a href="redisx_8c.html#aec99fb8b19d6751038bf9c4c6d04f8d0">redisxSelectDB</a></div><div class="ttdeci">int redisxSelectDB(Redis *redis, int idx)</div><div class="ttdef"><b>Definition</b> redisx.c:435</div></div>
</div><!-- fragment --><p>Note, that you can switch the database index any time, with the caveat that it's not possible to change it for the subscription client when there are active subscriptions.</p>
<p><a class="anchor" id="socket-configuration"></a> </p>
<h4><a class="anchor" id="autotoc_md22"></a>
Socket-level configuration</h4>
<p>You might also tweak the socket options used for clients, if you find the socket defaults sub-optimal for your application:</p>
<div class="fragment"><div class="line"><span class="comment">// (optional) Set 1000 ms socket read/write timeout for future connections.</span></div>
<div class="line"><a class="code hl_function" href="redisx-net_8c.html#aaa87635d37e5d348b7dbb12952b39183">redisxSetSocketTimeout</a>(redis, 1000);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (optional) Set the TCP send/rcv buffer sizes to use if not default values.</span></div>
<div class="line"><a class="code hl_function" href="redisx-net_8c.html#a648557774b354ff99e279d3dcf94d240">redisxSetTcpBuf</a>(redis, 65536);</div>
<div class="ttc" id="aredisx-net_8c_html_a648557774b354ff99e279d3dcf94d240"><div class="ttname"><a href="redisx-net_8c.html#a648557774b354ff99e279d3dcf94d240">redisxSetTcpBuf</a></div><div class="ttdeci">int redisxSetTcpBuf(Redis *redis, int size)</div><div class="ttdef"><b>Definition</b> redisx-net.c:1026</div></div>
<div class="ttc" id="aredisx-net_8c_html_aaa87635d37e5d348b7dbb12952b39183"><div class="ttname"><a href="redisx-net_8c.html#aaa87635d37e5d348b7dbb12952b39183">redisxSetSocketTimeout</a></div><div class="ttdeci">int redisxSetSocketTimeout(Redis *redis, int millis)</div><div class="ttdef"><b>Definition</b> redisx-net.c:1076</div></div>
</div><!-- fragment --><p>If you want, you can perform further customization of the client sockets via a user-defined callback function, e.g.:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> my_socket_config(<span class="keywordtype">int</span> sock, <span class="keyword">enum</span> <a class="code hl_enumeration" href="redisx_8h.html#a5349b7340813fbd1e32d04ed650bc3d9">redisx_channel</a> channel) {</div>
<div class="line">   <span class="comment">// Set up the socket any way you like...</span></div>
<div class="line">   ...</div>
<div class="line">   </div>
<div class="line">   <span class="keywordflow">return</span> <a class="code hl_defineRef" href="../../xchange/apidoc/html/xchange_8h.html#a7b2679c964ea5f2160380ed55654b873">X_SUCCESS</a>;</div>
<div class="line">}</div>
<div class="ttc" id="aredisx_8h_html_a5349b7340813fbd1e32d04ed650bc3d9"><div class="ttname"><a href="redisx_8h.html#a5349b7340813fbd1e32d04ed650bc3d9">redisx_channel</a></div><div class="ttdeci">redisx_channel</div><div class="ttdef"><b>Definition</b> redisx.h:138</div></div>
<div class="ttc" id="axchange_8h_html_a7b2679c964ea5f2160380ed55654b873"><div class="ttname"><a href="../../xchange/apidoc/html/xchange_8h.html#a7b2679c964ea5f2160380ed55654b873">X_SUCCESS</a></div><div class="ttdeci">#define X_SUCCESS</div></div>
</div><!-- fragment --><p>which you can then apply to your <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> instance as:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="redisx_8c.html#a085da763bc6a656c649a33dfd296d33f">redisxSetSocketConfigurator</a>(my_socket_config);</div>
<div class="ttc" id="aredisx_8c_html_a085da763bc6a656c649a33dfd296d33f"><div class="ttname"><a href="redisx_8c.html#a085da763bc6a656c649a33dfd296d33f">redisxSetSocketConfigurator</a></div><div class="ttdeci">int redisxSetSocketConfigurator(Redis *redis, RedisSocketConfigurator func)</div><div class="ttdef"><b>Definition</b> redisx.c:244</div></div>
</div><!-- fragment --><p><a class="anchor" id="connection-hooks"></a> </p>
<h4><a class="anchor" id="autotoc_md23"></a>
Connection &amp; disconnection hooks</h4>
<p>The user of the <b>RedisX</b> library might want to know when connections to the server are established, or when clients get disconnected (either as intended or as a result of errors), and may want to perform some configuration or clean-up accordingly. For this reason, the library provides support for connection 'hooks' &ndash; that is custom functions that are called in the even of connecting to or disconnecting from a <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server.</p>
<p>Here is an example of a connection hook, which simply prints a message about the connection to the console.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> my_connect_hook(<a class="code hl_struct" href="structRedis.html">Redis</a> *redis) {</div>
<div class="line">   printf(<span class="stringliteral">&quot;Connected to Redis server: %s\n&quot;</span>, redis-&gt;<a class="code hl_variable" href="structRedis.html#aecb3b0d045ada529257a2fbf8f829599">id</a>);</div>
<div class="line">}</div>
<div class="ttc" id="astructRedis_html_aecb3b0d045ada529257a2fbf8f829599"><div class="ttname"><a href="structRedis.html#aecb3b0d045ada529257a2fbf8f829599">Redis::id</a></div><div class="ttdeci">char * id</div><div class="ttdoc">The string ID of the Redis server. Default is IP, e.g. &quot;127.0.0.1&quot;.</div><div class="ttdef"><b>Definition</b> redisx.h:230</div></div>
</div><!-- fragment --><p>And, it can be added to a <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> instance, between the <code><a class="el" href="redisx-net_8c.html#a5c78c2189a76a077231016564a0cecd5">redisxInit()</a></code> and the <code><a class="el" href="redisx-net_8c.html#ad71822356ffd40ed4b1c71d065f48809">redisxConnect()</a></code> calls.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line">redisxAddConnectHook(redis, my_connect_hook);</div>
</div><!-- fragment --><p>You may add multiple callbacks. All of them will be called (in the same order as added) when connection is established. You may also remove specific connection callbacks via <code><a class="el" href="redisx-hooks_8c.html#aa6b85dc9160e50da8a47152d2995a3dd">redisxRemoveConnectHook()</a></code> if you now longer want a particular function to be called any more in the even.</p>
<p>The same goes for disconnect hooks, using <code><a class="el" href="redisx-hooks_8c.html#a37d95c69831058865b078f0f0f20d540">redisxAddDisconnectHook()</a></code> / <code><a class="el" href="redisx-hooks_8c.html#a7d57699ce7c728a4c936a4ba040b12f0">redisxRemoveDisconnectHook()</a></code> instead.</p>
<p><a class="anchor" id="connecting"></a> </p>
<h3><a class="anchor" id="autotoc_md24"></a>
Connecting</h3>
<p>Once configured, you can connect to the server as:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Connect to Redis, including a 2nd dedicated client for pipelined requests</span></div>
<div class="line">int status = <a class="code hl_function" href="redisx-net_8c.html#ad71822356ffd40ed4b1c71d065f48809">redisxConnect</a>(redis, TRUE);</div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">   <span class="comment">// Abort: we could not connect for some reason...</span></div>
<div class="line">   ...</div>
<div class="line">   <span class="comment">// Clean up...</span></div>
<div class="line">   <a class="code hl_function" href="redisx-net_8c.html#ac54dd4c46d8615db4da02702c18f062b">redisxDestroy</a>(redis);</div>
<div class="line">   ...</div>
<div class="line">}</div>
<div class="ttc" id="aredisx-net_8c_html_ac54dd4c46d8615db4da02702c18f062b"><div class="ttname"><a href="redisx-net_8c.html#ac54dd4c46d8615db4da02702c18f062b">redisxDestroy</a></div><div class="ttdeci">void redisxDestroy(Redis *redis)</div><div class="ttdef"><b>Definition</b> redisx-net.c:975</div></div>
<div class="ttc" id="aredisx-net_8c_html_ad71822356ffd40ed4b1c71d065f48809"><div class="ttname"><a href="redisx-net_8c.html#ad71822356ffd40ed4b1c71d065f48809">redisxConnect</a></div><div class="ttdeci">int redisxConnect(Redis *redis, boolean usePipeline)</div><div class="ttdef"><b>Definition</b> redisx-net.c:1108</div></div>
</div><!-- fragment --><p>The above will establish both an interactive connection and a pipelined connection client, for processing both synchronous and asynchronous requests (and responses). For <a href="https://redis.io/docs/latest/develop/reference/sentinel-clients/">Sentinel</a> configurations, it will return with <code>X_SUCCESS</code> only after having located and connected to the master server, and confirmed that it is indeed the master.</p>
<p><a class="anchor" id="disconnecting"></a> </p>
<h3><a class="anchor" id="autotoc_md25"></a>
Disconnecting</h3>
<p>When you are done with a specific <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server, you should disconnect from it:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line">redisxDisconnect(redis);</div>
</div><!-- fragment --><p>And then to free up all resources used by the <code><a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a></code> instance, you might also call</p>
<div class="fragment"><div class="line"><span class="comment">// Destroy the Redis instance and free up resources</span></div>
<div class="line"><a class="code hl_function" href="redisx-net_8c.html#ac54dd4c46d8615db4da02702c18f062b">redisxDestroy</a>(redis);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the destroyed Redis instance pointer to NULL, as best practice.</span></div>
<div class="line">redis = NULL;</div>
</div><!-- fragment --><p><a class="anchor" id="reconnecting"></a> </p>
<h3><a class="anchor" id="autotoc_md26"></a>
Reconnecting</h3>
<p>Reconnections to the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> servers are never automatic, and there is no automatic failover for <b>RedisX</b> clients (there are good reasons for that). It is up to you to decide when to reconnect and how exactly. For example, the application may reconnect to the same or different server (including Sentinel), and perform a set of necessary recovery steps, to continue where things were left off on the previous connection, such as:</p>
<ul>
<li>reload LUA scripts</li>
<li>reinstate subscriptions</li>
<li>re-submit any request for which no replies have been received before the connection was broken.</li>
<li>re-publish any notifications on PUB/SUB, which may not have been delivered.</li>
</ul>
<hr  />
<p><a class="anchor" id="simple-redis-queries"></a> </p>
<h2><a class="anchor" id="autotoc_md28"></a>
Simple Redis queries</h2>
<ul>
<li><a class="el" href="index.html#interactive-transactions">Interactive transactions</a></li>
<li><a class="el" href="index.html#attributes">Bundled Attributes</a></li>
<li><a class="el" href="index.html#push-notifications">Push notifications</a></li>
<li><a class="el" href="index.html#resp-data-type">RESP data type</a></li>
</ul>
<p><a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> queries are sent as strings, according the the specification of the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> protocol. All responses sent back by the server using the <a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> protocol. Specifically, <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> uses version 2 of the <a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> protocol (a.k.a. RESP2) by default, with optional support for the newer RESP3 introduced in <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> version 6.0. The <b>RedisX</b> library provides support for both RESP2 and RESP3.</p>
<p><a class="anchor" id="interactive-transactions"></a> </p>
<h3><a class="anchor" id="autotoc_md29"></a>
Interactive transactions</h3>
<p>The simplest way for running a few <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> queries is to do it in interactive mode:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line">RESP *resp;     <span class="comment">// This will be the pointer we receive to the Redis response</span></div>
<div class="line"><span class="keywordtype">int</span> status;     <span class="comment">// execution status to be populated.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send &quot;HGET my_table my_key&quot; request</span></div>
<div class="line">resp = <a class="code hl_function" href="redisx_8c.html#a09092bd97eead5c5fa73fa0d9241018c">redisxRequest</a>(redis, <span class="stringliteral">&quot;HGET&quot;</span>, <span class="stringliteral">&quot;my_table&quot;</span>, <span class="stringliteral">&quot;my_key&quot;</span>, NULL, &amp;status);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check return status...</span></div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Oops something went wrong...</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="ttc" id="aredisx_8c_html_a09092bd97eead5c5fa73fa0d9241018c"><div class="ttname"><a href="redisx_8c.html#a09092bd97eead5c5fa73fa0d9241018c">redisxRequest</a></div><div class="ttdeci">RESP * redisxRequest(Redis *redis, const char *command, const char *arg1, const char *arg2, const char *arg3, int *status)</div><div class="ttdef"><b>Definition</b> redisx.c:586</div></div>
</div><!-- fragment --><p>The <code><a class="el" href="redisx_8c.html#a09092bd97eead5c5fa73fa0d9241018c">redisxRequest()</a></code> sends a command with up to three arguments. If the command takes fewer than 3 parameters, then the remaining ones must be set to <code>NULL</code>. This function thus offers a simple interface for running most basic sequential queries. In cases where 3 parameters are not sufficient, you may use <code><a class="el" href="redisx_8c.html#ac6767cea95b4cc90348796c61ebdac75">redisxArrayRequest()</a></code> instead, e.g.:</p>
<div class="fragment"><div class="line">...</div>
<div class="line">char *args[] = { <span class="stringliteral">&quot;my_table&quot;</span>, <span class="stringliteral">&quot;my_key&quot;</span> };  <span class="comment">// parameters as an array...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send &quot;HGET my_table my_key&quot; request with an array of 2 parameters...</span></div>
<div class="line">resp = <a class="code hl_function" href="redisx_8c.html#ac6767cea95b4cc90348796c61ebdac75">redisxArrayRequest</a>(redis, <span class="stringliteral">&quot;HGET&quot;</span>, args, NULL, 2, &amp;status);</div>
<div class="line">...</div>
<div class="ttc" id="aredisx_8c_html_ac6767cea95b4cc90348796c61ebdac75"><div class="ttname"><a href="redisx_8c.html#ac6767cea95b4cc90348796c61ebdac75">redisxArrayRequest</a></div><div class="ttdeci">RESP * redisxArrayRequest(Redis *redis, const char **args, const int *lengths, int n, int *status)</div><div class="ttdef"><b>Definition</b> redisx.c:641</div></div>
</div><!-- fragment --><p>The 4th argument in the list is an optional <code>int[]</code> array defining the individual string lengths of the parameters (if need be, or else readily available). Here, we used <code>NULL</code> instead, which will use <code>strlen()</code> on each supplied string-terminated parameter to determine its length automatically. Specifying the length may be necessary if the individual parameters are not 0-terminated strings.</p>
<p>In interactive mode, each request is sent to the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server, and the response is collected before the call returns with that response (or <code>NULL</code> if there was an error).</p>
<p><a class="anchor" id="attributes"></a> </p>
<h3><a class="anchor" id="autotoc_md30"></a>
Bundled Attributes</h3>
<p><a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> 6 introduced the possibility of sending optional attributes along with responses, using the RESP3 protocol. These attributes are not included in the responses sent to users, in accordance with RESP3 protocol. Rather, they are made available to users on demand, when needed, after the response to a request is received. You may retrieve the attributes to interactive requests <em>after</em> the <code><a class="el" href="redisx_8c.html#a09092bd97eead5c5fa73fa0d9241018c">redisxRequest()</a></code> or <code><a class="el" href="redisx_8c.html#ac6767cea95b4cc90348796c61ebdac75">redisxArrayRequest()</a></code> queries, using <code><a class="el" href="redisx_8c.html#a48b6b8949276f59cd2f13d6b13384996">redisxGetAttributes()</a></code>, e.g.:</p>
<div class="fragment"><div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Some interactive request</span></div>
<div class="line">RESP *reply = <a class="code hl_function" href="redisx_8c.html#a09092bd97eead5c5fa73fa0d9241018c">redisxRequest</a>(redis, ...);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the attributes (if any) that were bundled with the response...</span></div>
<div class="line"><a class="code hl_struct" href="structRESP.html">RESP</a> *attributes = <a class="code hl_function" href="redisx_8c.html#a48b6b8949276f59cd2f13d6b13384996">redisxGetAttributes</a>(redis);</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="ttc" id="aredisx_8c_html_a48b6b8949276f59cd2f13d6b13384996"><div class="ttname"><a href="redisx_8c.html#a48b6b8949276f59cd2f13d6b13384996">redisxGetAttributes</a></div><div class="ttdeci">RESP * redisxGetAttributes(Redis *redis)</div><div class="ttdef"><b>Definition</b> redisx.c:696</div></div>
<div class="ttc" id="astructRESP_html"><div class="ttname"><a href="structRESP.html">RESP</a></div><div class="ttdoc">Structure that represents a Redis response (RESP format).</div><div class="ttdef"><b>Definition</b> redisx.h:170</div></div>
</div><!-- fragment --><p><a class="anchor" id="push-notifications"></a> </p>
<h3><a class="anchor" id="autotoc_md31"></a>
Push notifications</h3>
<p><a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> 6 introduced out-of-band push notifications along with RESP3. It allows the server to send messages to any connected client that are not in response to a query. For example, <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> 6 allows <code>CLIENT TRACKING</code> to use such push notifications (e.g. <code>INVALIDATE foo</code>), to notify connected clients when a watched variable has been updated from somewhere else.</p>
<p><b>RedisX</b> allows you to specify a custom callback <code>RedisPushProcessor</code> function to handle such push notifications, e.g.:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> my_push_processor(<a class="code hl_struct" href="structRESP.html">RESP</a> *message, <span class="keywordtype">void</span> *ptr) {</div>
<div class="line">  <span class="keywordtype">char</span> *owner = (<span class="keywordtype">char</span> *) ptr;  <span class="comment">// Additional argument we need, in this case a string.</span></div>
<div class="line">  printf(<span class="stringliteral">&quot;[%s] Got push message: type %c, n = %d.\n&quot;</span>, owner, message-&gt;<a class="code hl_variable" href="structRESP.html#a93869a69154ac2297800b0afff64d600">type</a>, message-&gt;<a class="code hl_variable" href="structRESP.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>);</div>
<div class="line">}</div>
<div class="ttc" id="astructRESP_html_a76f11d9a0a47b94f72c2d0e77fb32240"><div class="ttname"><a href="structRESP.html#a76f11d9a0a47b94f72c2d0e77fb32240">RESP::n</a></div><div class="ttdeci">int n</div><div class="ttdoc">dimension of the value field.</div><div class="ttdef"><b>Definition</b> redisx.h:172</div></div>
<div class="ttc" id="astructRESP_html_a93869a69154ac2297800b0afff64d600"><div class="ttname"><a href="structRESP.html#a93869a69154ac2297800b0afff64d600">RESP::type</a></div><div class="ttdeci">enum resp_type type</div><div class="ttdoc">RESP type; RESP_ARRAY, RESP_INT ...</div><div class="ttdef"><b>Definition</b> redisx.h:171</div></div>
</div><!-- fragment --><p>Then you can activate the processing of push notifications with <code><a class="el" href="redisx_8c.html#a2caca9bc8a09225edb88699fdda10602">redisxSetPushProcessor()</a></code>. You can specify the optional additional data that you want to pass along to the push processor function &ndash; just make sure that the data has a sufficient scope / lifetime such that it is valid at all times while push messages are being processed. E.g.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> owner = <span class="stringliteral">&quot;my process&quot;</span>; <span class="comment">// The long life data we want to pass to my_push_processor...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use my_push_processor and pass along the owner as a parameter</span></div>
<div class="line"><a class="code hl_function" href="redisx_8c.html#a2caca9bc8a09225edb88699fdda10602">redisxSetPushProcessor</a>(redis, my_push_processor, owner);</div>
<div class="ttc" id="aredisx_8c_html_a2caca9bc8a09225edb88699fdda10602"><div class="ttname"><a href="redisx_8c.html#a2caca9bc8a09225edb88699fdda10602">redisxSetPushProcessor</a></div><div class="ttdeci">int redisxSetPushProcessor(Redis *redis, RedisPushProcessor func, void *arg)</div><div class="ttdef"><b>Definition</b> redisx.c:735</div></div>
</div><!-- fragment --><p>There are some things to look out for in your <code>RedisPushProcessor</code> implementation:</p>
<ul>
<li>The call should not block (except perhaps for a quick mutex lock) and should return quickly. If blocking calls, or extensive processing is required, you should place a copy of the PUSH notification onto a queue and let an asynchronous thread take it from there.</li>
<li>The call should not attempt to alter or destroy the push message. If needed it can copy parts or the whole.</li>
<li>You should not attempt to lock or release clients from the call. If you need access to a client (e.g. to submit a new <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> request), it's best to put a copy of the <a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> notification onto a queue and let an asynchronous thread deal with it.</li>
</ul>
<p><a class="anchor" id="resp-data-type"></a> </p>
<h3><a class="anchor" id="autotoc_md32"></a>
RESP data type</h3>
<p>All responses coming from the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server are represented by a dynamically allocated <code><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a></code> type (defined in <code><a class="el" href="redisx_8h.html">redisx.h</a></code>) structure.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code hl_struct" href="structRESP.html">RESP</a> {</div>
<div class="line">  <span class="keywordtype">char</span> <a class="code hl_variable" href="structRESP.html#a93869a69154ac2297800b0afff64d600">type</a>;                    <span class="comment">// RESP type: RESP_ARRAY, RESP_INT ...</span></div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_variable" href="structRESP.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>;                        <span class="comment">// Either the integer value of a RESP_INT response, or the </span></div>
<div class="line">                                <span class="comment">// dimension of the value field.</span></div>
<div class="line">  <span class="keywordtype">void</span> *<a class="code hl_variable" href="structRESP.html#a0f61d63b009d0880a89c843bd50d8d76">value</a>;                  <span class="comment">// Pointer to text (char *) content or to an array of components </span></div>
<div class="line">                                <span class="comment">// (RESP **)</span></div>
<div class="line">} <a class="code hl_struct" href="structRESP.html">RESP</a>;</div>
<div class="ttc" id="astructRESP_html_a0f61d63b009d0880a89c843bd50d8d76"><div class="ttname"><a href="structRESP.html#a0f61d63b009d0880a89c843bd50d8d76">RESP::value</a></div><div class="ttdeci">void * value</div><div class="ttdef"><b>Definition</b> redisx.h:174</div></div>
</div><!-- fragment --><p>whose contents are:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> <code>type</code>   </th><th class="markdownTableHeadNone"><a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> ID   </th><th class="markdownTableHeadNone"><code>n</code>   </th><th class="markdownTableHeadNone"><code>value</code> cast in C    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>RESP_ARRAY</code>   </td><td class="markdownTableBodyNone"><code>*</code>   </td><td class="markdownTableBodyNone">number of <code><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> *</code> pointers   </td><td class="markdownTableBodyNone"><code>(<a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> **)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>RESP_INT</code>   </td><td class="markdownTableBodyNone"><code>:</code>   </td><td class="markdownTableBodyNone">integer return value   </td><td class="markdownTableBodyNone"><code>(void)</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>RESP_SIMPLE_STRING</code>   </td><td class="markdownTableBodyNone"><code>+</code>   </td><td class="markdownTableBodyNone">string length   </td><td class="markdownTableBodyNone"><code>(char *)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>RESP_ERROR</code>   </td><td class="markdownTableBodyNone"><code>-</code>   </td><td class="markdownTableBodyNone">total string length   </td><td class="markdownTableBodyNone"><code>(char *)</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>RESP_BULK_STRING</code>   </td><td class="markdownTableBodyNone"><code>$</code>   </td><td class="markdownTableBodyNone">string length or -1 if <code>NULL</code>   </td><td class="markdownTableBodyNone"><code>(char *)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>RESP3_NULL</code>   </td><td class="markdownTableBodyNone"><code>_</code>   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone"><code>(void)</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>RESP3_BOOLEAN</code>   </td><td class="markdownTableBodyNone"><code>#</code>   </td><td class="markdownTableBodyNone">1 if <em>true</em>, 0 if <em>false</em>   </td><td class="markdownTableBodyNone"><code>(void)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>RESP3_DOUBLE</code>   </td><td class="markdownTableBodyNone"><code>,</code>   </td><td class="markdownTableBodyNone"><em>unused</em>   </td><td class="markdownTableBodyNone"><code>(double *)</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>RESP3_BIG_NUMBER</code>   </td><td class="markdownTableBodyNone"><code>(</code>   </td><td class="markdownTableBodyNone">string representation length   </td><td class="markdownTableBodyNone"><code>(char *)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>RESP3_BLOB_ERROR</code>   </td><td class="markdownTableBodyNone"><code>!</code>   </td><td class="markdownTableBodyNone">total string length   </td><td class="markdownTableBodyNone"><code>(char *)</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>RESP3_VERBATIM_TEXT</code>   </td><td class="markdownTableBodyNone"><code>=</code>   </td><td class="markdownTableBodyNone">text length (incl. type)   </td><td class="markdownTableBodyNone"><code>(char *)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>RESP3_SET</code>   </td><td class="markdownTableBodyNone"><code>~</code>   </td><td class="markdownTableBodyNone">number of <code><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> *</code> pointers   </td><td class="markdownTableBodyNone"><code>(<a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> *)</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>RESP3_MAP</code>   </td><td class="markdownTableBodyNone"><code>%</code>   </td><td class="markdownTableBodyNone">number of key / value pairs   </td><td class="markdownTableBodyNone"><code>(<a class="el" href="structRedisMapEntry.html">RedisMapEntry</a> *)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>RESP3_ATTRIBUTE</code>   </td><td class="markdownTableBodyNone"><code>\|</code>   </td><td class="markdownTableBodyNone">number of key / value pairs   </td><td class="markdownTableBodyNone"><code>(<a class="el" href="structRedisMapEntry.html">RedisMapEntry</a> *)</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>RESP3_PUSH</code>   </td><td class="markdownTableBodyNone"><code>&gt;</code>   </td><td class="markdownTableBodyNone">number of <code><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> *</code> pointers   </td><td class="markdownTableBodyNone"><code>(<a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> **)</code>   </td></tr>
</table>
<p>Each <code><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a></code> has a type (e.g. <code>RESP_SIMPLE_STRING</code>), an integer value <code>n</code>, and a <code>value</code> pointer to further data. If the type is <code>RESP_INT</code>, then <code>n</code> represents the actual return value (and the <code>value</code> pointer is not used). For string type values <code>n</code> is the number of characters in the string <code>value</code> (not including termination), while for <code>RESP_ARRAY</code> types the <code>value</code> is a pointer to an embedded <code><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a></code> array and <code>n</code> is the number of elements in that.</p>
<p>To help with deciding what cast to use for a given <code>value</code> field of the <a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> data structure, we provide the convenience methods <code><a class="el" href="resp_8c.html#a944a623a34b5a6a7af064fc0d0cc35bf">redisxIsScalarType()</a></code>, <code><a class="el" href="resp_8c.html#a7fb3a83bc8345413eb1a722444386abd">redisxIsStringType()</a></code>, <code><a class="el" href="resp_8c.html#af7d1a91b1d89fb11e6b16db04653a871">redisxIsArrayType()</a></code>, and <code><a class="el" href="resp_8c.html#a460822029ff730cd7a55d64797c329a3">redisxIsMapType()</a></code> functions.</p>
<p>You can check that two <code><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a></code> data structures are equivalent with <code>redisxIsEqualRESP(RESP *a, RESP *b)</code>.</p>
<p>You may also check the integrity of a <code><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a></code> using <code><a class="el" href="resp_8c.html#a4b5674d08da07250c0ca6116a4c48ccf">redisxCheckRESP()</a></code>. Since <code><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a></code> data is dynamically allocated, the user is responsible for discarding them once they are no longer needed, e.g. by calling <code><a class="el" href="resp_8c.html#aa4e23a7454f7055711915ec430599011">redisxDestroyRESP()</a></code>. The two steps may be combined to automatically discard invalid or unexpected <code><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a></code> data in a single step by calling <code><a class="el" href="resp_8c.html#a80d5a305523c51da7bc7cf4c9deca962">redisxCheckDestroyRESP()</a></code>.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRESP.html">RESP</a> *r = ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Let&#39;s say we expect &#39;r&#39; to contain of an embedded RESP array of 3 elements... </span></div>
<div class="line">int status = <a class="code hl_function" href="resp_8c.html#a80d5a305523c51da7bc7cf4c9deca962">redisxCheckDestroyRESP</a>(r, <a class="code hl_enumvalue" href="redisx_8h.html#afa5c90630d37c2f77e5d7985932941a0ad16eee767b19b1c4bb650deea0dd0b30">RESP_ARRAY</a>, 3);</div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">   <span class="comment">// Oops, &#39;r&#39; was either NULL, or does not contain a RESP array with 3 elements...</span></div>
<div class="line">   ...</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> {</div>
<div class="line">   <span class="comment">// Process the expected response...</span></div>
<div class="line">   ...</div>
<div class="line">   <a class="code hl_function" href="resp_8c.html#aa4e23a7454f7055711915ec430599011">redisxDestroyRESP</a>(r);</div>
<div class="line">}</div>
<div class="ttc" id="aredisx_8h_html_afa5c90630d37c2f77e5d7985932941a0ad16eee767b19b1c4bb650deea0dd0b30"><div class="ttname"><a href="redisx_8h.html#afa5c90630d37c2f77e5d7985932941a0ad16eee767b19b1c4bb650deea0dd0b30">RESP_ARRAY</a></div><div class="ttdeci">@ RESP_ARRAY</div><div class="ttdoc">RESP array type.</div><div class="ttdef"><b>Definition</b> redisx.h:103</div></div>
<div class="ttc" id="aresp_8c_html_a80d5a305523c51da7bc7cf4c9deca962"><div class="ttname"><a href="resp_8c.html#a80d5a305523c51da7bc7cf4c9deca962">redisxCheckDestroyRESP</a></div><div class="ttdeci">int redisxCheckDestroyRESP(RESP *resp, enum resp_type expectedType, int expectedSize)</div><div class="ttdef"><b>Definition</b> resp.c:190</div></div>
<div class="ttc" id="aresp_8c_html_aa4e23a7454f7055711915ec430599011"><div class="ttname"><a href="resp_8c.html#aa4e23a7454f7055711915ec430599011">redisxDestroyRESP</a></div><div class="ttdeci">void redisxDestroyRESP(RESP *resp)</div><div class="ttdef"><b>Definition</b> resp.c:38</div></div>
</div><!-- fragment --><p>Before destroying a <a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> structure, the caller may want to dereference values within it if they are to be used as is (without making copies), e.g.:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRESP.html">RESP</a> *r = ...</div>
<div class="line">char *stringValue = NULL;   <span class="comment">// to be extracted from &#39;r&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Let&#39;s say we expect &#39;r&#39; to contain of a simple string response (of whatever length)</span></div>
<div class="line"><span class="keywordtype">int</span> status = <a class="code hl_function" href="resp_8c.html#a80d5a305523c51da7bc7cf4c9deca962">redisxCheckDestroyRESP</a>(r, <a class="code hl_enumvalue" href="redisx_8h.html#afa5c90630d37c2f77e5d7985932941a0a7868e33fc03b809c864bf271abd009b9">RESP_SIMPLE_STRING</a>, 0);</div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Oops, &#39;r&#39; was either NULL, or it was not a simple string type</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> {</div>
<div class="line">  <span class="comment">// Set &#39;stringValue&#39; and dereference the value field in the RESP so it&#39;s not </span></div>
<div class="line">  <span class="comment">// destroyed with the RESP itself.</span></div>
<div class="line">  stringValue = (<span class="keywordtype">char</span> *) r-&gt;<a class="code hl_variable" href="structRESP.html#a0f61d63b009d0880a89c843bd50d8d76">value</a>;</div>
<div class="line">  r-&gt;<a class="code hl_variable" href="structRESP.html#a0f61d63b009d0880a89c843bd50d8d76">value</a> = NULL;</div>
<div class="line">   </div>
<div class="line">  <a class="code hl_function" href="resp_8c.html#aa4e23a7454f7055711915ec430599011">redisxDestroyRESP</a>(r);     <span class="comment">// &#39;stringValue&#39; is still a valid pointer after! </span></div>
<div class="line">}</div>
<div class="ttc" id="aredisx_8h_html_afa5c90630d37c2f77e5d7985932941a0a7868e33fc03b809c864bf271abd009b9"><div class="ttname"><a href="redisx_8h.html#afa5c90630d37c2f77e5d7985932941a0a7868e33fc03b809c864bf271abd009b9">RESP_SIMPLE_STRING</a></div><div class="ttdeci">@ RESP_SIMPLE_STRING</div><div class="ttdoc">RESP simple string type.</div><div class="ttdef"><b>Definition</b> redisx.h:105</div></div>
</div><!-- fragment --><p>Note, that you can convert a <a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> to an <code><a class="elRef" href="../../xchange/apidoc/html/structXField.html">XField</a></code>, and/or to JSON representation using the <code><a class="el" href="resp_8c.html#adc7235cd1b6be038b9f3c7beb11a13ef">redisxRESP2XField()</a></code> and <code><a class="el" href="resp_8c.html#a7f4e74ee03cebf38eb9c1fb873784a35">redisxRESP2JSON()</a></code> functions, e.g.:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> redis = ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Obtain a copy of the response received from HELLO upon connecting...</span></div>
<div class="line">RESP *resp = <a class="code hl_function" href="redisx_8c.html#a89fd65118ba731931fe281c83f6fa8ba">redisxGetHelloData</a>(redis);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Print the response from HELLO to the standard output in JSON format</span></div>
<div class="line"><span class="keywordtype">char</span> *json = <a class="code hl_function" href="resp_8c.html#a7f4e74ee03cebf38eb9c1fb873784a35">redisxRESP2JSON</a>(<span class="stringliteral">&quot;hello_response&quot;</span>, resp);</div>
<div class="line"><span class="keywordflow">if</span>(json != NULL) {</div>
<div class="line">  printf(<span class="stringliteral">&quot;%s&quot;</span>, json);</div>
<div class="line">  free(json);</div>
<div class="line">}</div>
<div class="line">  </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Clean up</span></div>
<div class="line">redisxDestroyRESP(resp);</div>
<div class="ttc" id="aredisx_8c_html_a89fd65118ba731931fe281c83f6fa8ba"><div class="ttname"><a href="redisx_8c.html#a89fd65118ba731931fe281c83f6fa8ba">redisxGetHelloData</a></div><div class="ttdeci">RESP * redisxGetHelloData(Redis *redis)</div><div class="ttdef"><b>Definition</b> redisx.c:759</div></div>
<div class="ttc" id="aresp_8c_html_a7f4e74ee03cebf38eb9c1fb873784a35"><div class="ttname"><a href="resp_8c.html#a7f4e74ee03cebf38eb9c1fb873784a35">redisxRESP2JSON</a></div><div class="ttdeci">char * redisxRESP2JSON(const char *name, const RESP *resp)</div><div class="ttdef"><b>Definition</b> resp.c:749</div></div>
</div><!-- fragment --><p>All <a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> can be represented in JSON format. This is trivial for map entries, which have strings as their keywords &ndash; which is the case for all <a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a> sent by <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a>. And, it is also possible for map entries with non-string keys, albeit via a more tedious (and less standard) JSON representation, stored under the <code>.non-string-keys</code> keyword.</p>
<hr  />
<p><a class="anchor" id="accessing-key-value-data"></a> </p>
<h2><a class="anchor" id="autotoc_md34"></a>
Accessing key / value data</h2>
<ul>
<li><a class="el" href="index.html#getting-and-setting-keyed-values">Getting and setting keyed values</a></li>
<li><a class="el" href="index.html#listing-and-scanning">Listing and scanning</a></li>
</ul>
<p><a class="anchor" id="getting-and-setting-keyed-values"></a> </p>
<h3><a class="anchor" id="autotoc_md35"></a>
Getting and setting keyed values</h3>
<p>Key/value pairs are the bread and butter of <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a>. They come in two varieties: (1) there are top-level key-value pairs, and (2) there are key-value pairs organized into hash tables, where the table name is a top-level key, but the fields in the table are not. The RedisX library offers a unified approach for dealing with key/value pairs, whether they are top level or hash-tables. Simply, a table name <code>NULL</code> is used to refer to top-level keys.</p>
<p>Retrieving individual keyed values is simple:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...;</div>
<div class="line"><span class="keywordtype">int</span> len; <span class="comment">// Variable in which we return the length of the value or an error code </span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get the &quot;property&quot; field from the &quot;system:subsystem&quot; hash table</span></div>
<div class="line"><span class="keywordtype">char</span> *value = <a class="code hl_function" href="redisx-tab_8c.html#afc875f142146282860b6a8a3ac2f0fc8">redisxGetStringValue</a>(redis, <span class="stringliteral">&quot;system:subsystem&quot;</span>, <span class="stringliteral">&quot;property&quot;</span>, &amp;len);</div>
<div class="line"><span class="keywordflow">if</span> (len &lt; 0) {</div>
<div class="line">  <span class="comment">// Oops something went wrong.</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Discard the value once it&#39;s no longer needed.</span></div>
<div class="line">if(value) free(value);</div>
<div class="ttc" id="aredisx-tab_8c_html_afc875f142146282860b6a8a3ac2f0fc8"><div class="ttname"><a href="redisx-tab_8c.html#afc875f142146282860b6a8a3ac2f0fc8">redisxGetStringValue</a></div><div class="ttdeci">char * redisxGetStringValue(Redis *redis, const char *table, const char *key, int *len)</div><div class="ttdef"><b>Definition</b> redisx-tab.c:261</div></div>
</div><!-- fragment --><p>The same goes for top-level keyed values, using <code>NULL</code> for the hash table name:</p>
<div class="fragment"><div class="line"><span class="comment">// Get value for top-level key (not stored in hash table!)</span></div>
<div class="line"><span class="keywordtype">char</span> *value = <a class="code hl_function" href="redisx-tab_8c.html#afc875f142146282860b6a8a3ac2f0fc8">redisxGetStringValue</a>(redis, NULL, <span class="stringliteral">&quot;my-key&quot;</span>, &amp;len);</div>
</div><!-- fragment --><p>Alternatively, you can get the value as an undigested <code><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a></code>, using <code><a class="el" href="redisx-tab_8c.html#a01bf1f5d830d1af19456ab78457a54ab">redisxGetValue()</a></code> instead, which allows you to check and inspect the response in more detail (e.g. to check for potential errors, or unexpected response types).</p>
<p>Setting values is straightforward also:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set the &quot;property&quot; field in the &quot;system:subsystem&quot; hash table to -2.5</span></div>
<div class="line"><span class="comment">// using the interactive client connection, without requiring confirmation. </span></div>
<div class="line"><span class="keywordtype">int</span> status = <a class="code hl_function" href="redisx-tab_8c.html#a1465b1a965ddd685e16bccbf0b34f08b">redisxSetValue</a>(redis, <span class="stringliteral">&quot;system:subsystem&quot;</span>, <span class="stringliteral">&quot;property&quot;</span>, <span class="stringliteral">&quot;-2.5&quot;</span>, FALSE);</div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Oops something went wrong.</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="aredisx-tab_8c_html_a1465b1a965ddd685e16bccbf0b34f08b"><div class="ttname"><a href="redisx-tab_8c.html#a1465b1a965ddd685e16bccbf0b34f08b">redisxSetValue</a></div><div class="ttdeci">int redisxSetValue(Redis *redis, const char *table, const char *key, const char *value, boolean confirm)</div><div class="ttdef"><b>Definition</b> redisx-tab.c:125</div></div>
</div><!-- fragment --><p>It's worth noting here, that values in <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> are always represented as strings, hence non-string data, such as floating-point values, must be converted to strings first. Additionally, the <code><a class="el" href="redisx-tab_8c.html#a1465b1a965ddd685e16bccbf0b34f08b">redisxSetValue()</a></code> function works with 0-terminated string values only, but <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> allows storing unterminated byte sequences of known length also. If you find that you need to store an unterminated string (such as a binary sequence) as a value, you may just use the lower-level <code><a class="el" href="redisx_8c.html#ac6767cea95b4cc90348796c61ebdac75">redisxArrayRequest()</a></code> instead to process a <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> <code>SET</code> or <code>HSET</code> command with explicit byte-length specifications.</p>
<p>In the above example we have set the value using the interactive client to <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a>, which means that the call will return only after confirmation or result is received back from the server. As such, a subsequent <code><a class="el" href="redisx-tab_8c.html#a01bf1f5d830d1af19456ab78457a54ab">redisxGetValue()</a></code> of the same table/key will be guaranteed to return the updated value always.</p>
<p>However, we could have set the new value asynchronously over the pipeline connection (by using <code>TRUE</code> as the last argument). In that case, the call will return as soon as the request was sent to <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> (but not confirmed, nor possibly transmitted yet!). As such, a subsequent <code><a class="el" href="redisx-tab_8c.html#a01bf1f5d830d1af19456ab78457a54ab">redisxGetValue()</a></code> on the same key/value field may race the request in transit, and may return the previous value on occasion. So, it's important to remember that while pipelining can make setting multiple <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> fields very efficient, we have to be careful about retrieving the same values afterwards from the same program thread. (Arguably, however, there should never be a need to query values we set ourselves, since we readily know what they are.)</p>
<p>Finally, if you want to set values for multiple fields in a <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> hash table atomically, you may use <code><a class="el" href="redisx-tab_8c.html#aa8fd65a355394af08c86b4f0e943d3a6">redisxMultiSet()</a></code>, which provides a high-level interface to the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> <code>HMSET</code> command.</p>
<p><a class="anchor" id="listing-and-scanning"></a> </p>
<h3><a class="anchor" id="autotoc_md36"></a>
Listing and Scanning</h3>
<p>The functions <code><a class="el" href="redisx-tab_8c.html#aaa45af252b10e19c647d2cd5b51d7c05">redisxGetKeys()</a></code> and <code><a class="el" href="redisx-tab_8c.html#af4290857fc98baac7edd15edb6d0bcac">redisxGetTable()</a></code> allow to return the set of <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> keywords or all key/value pairs in a table atomically. However, these commands can be computationally expensive for large tables and/or many top-level keywords, which means that the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server may block for undesirably long times while the result is computed.</p>
<p>This is where scanning offers a less selfish (hence much preferred) alternative. Rather than returning all the keys or key/value pairs contained in a table atomically at once, it allows to do it bit by bit with byte-sized individual transactions that are guaranteed to not block the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server long, so it may remain responsive to other queries also. For the caller the result is the same (notwithstanding the atomicity), except that the result is computed via a series of quick <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> queries rather than with one potentially very expensive query.</p>
<p>For example, to retrieve all top-level <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> keys, sorted alphabetically, using the scanning approach, you may write something like:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line">int nMatches;  <span class="comment">// We&#39;ll return the number of matching Redis keys here...</span></div>
<div class="line"><span class="keywordtype">int</span> status;    <span class="comment">// We&#39;ll return the error status here...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//  Return all Redis top-level keywords starting with &quot;system:&quot;</span></div>
<div class="line"><span class="keywordtype">char</span> **keys = <a class="code hl_function" href="redisx-tab_8c.html#a67dd05115ae75dac9637ac04220d73b6">redisxScanKeys</a>(redis, <span class="stringliteral">&quot;system:*&quot;</span>, &amp;nMatches, &amp;status);</div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Oops something went wrong...</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use &#39;keys&#39; as appropriate, possibly dereferencing values we want to</span></div>
<div class="line"><span class="comment">// retain in other persistent data structures...</span></div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Once done using the &#39;keys&#39; array, we should destroy it</span></div>
<div class="line">redisxDestroyKeys(keys, nMatches);</div>
<div class="ttc" id="aredisx-tab_8c_html_a67dd05115ae75dac9637ac04220d73b6"><div class="ttname"><a href="redisx-tab_8c.html#a67dd05115ae75dac9637ac04220d73b6">redisxScanKeys</a></div><div class="ttdeci">char ** redisxScanKeys(Redis *redis, const char *pattern, int *n, int *status)</div><div class="ttdef"><b>Definition</b> redisx-tab.c:526</div></div>
</div><!-- fragment --><p>Or, to retrieve the values from a hash table for a set of keywords that match a glob pattern:</p>
<div class="fragment"><div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Scan all key/value pairs in hash table &quot;system:subsystem&quot;</span></div>
<div class="line">RedisEntry *entries = <a class="code hl_function" href="redisx-tab_8c.html#a47d28fd9f2f35f0af5abd67a1ae7b987">redisxScanTable</a>(redis, <span class="stringliteral">&quot;system:subsystem&quot;</span>, <span class="stringliteral">&quot;*&quot;</span>, &amp;nMatches, &amp;status);</div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Oops something went wrong.</span></div>
<div class="line">  ... </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use &#39;entries&#39; as appropriate, possibly dereferencing values we want to</span></div>
<div class="line"><span class="comment">// retain in other persistent data structures...</span></div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Once done using the &#39;keys&#39; array, we should destroy it</span></div>
<div class="line">redisxDestroyEntries(entries, nMatches);</div>
<div class="ttc" id="aredisx-tab_8c_html_a47d28fd9f2f35f0af5abd67a1ae7b987"><div class="ttname"><a href="redisx-tab_8c.html#a47d28fd9f2f35f0af5abd67a1ae7b987">redisxScanTable</a></div><div class="ttdeci">RedisEntry * redisxScanTable(Redis *redis, const char *table, const char *pattern, int *n, int *status)</div><div class="ttdef"><b>Definition</b> redisx-tab.c:693</div></div>
</div><!-- fragment --><p>Finally, you may use <code><a class="el" href="redisx-tab_8c.html#a3bd0d2964966ed6655358ff2fe0802c0">redisxSetScanCount()</a></code> to tune just how many results should individual scan queries should return (but only if you are really itching to tweak it). Please refer to the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> documentation on the behavior of the <code>SCAN</code> and <code>HSCAN</code> commands to learn more.</p>
<hr  />
<p><a class="anchor" id="publish-subscribe-support"></a> </p>
<h2><a class="anchor" id="autotoc_md38"></a>
Publish / subscribe (PUB/SUB) support</h2>
<ul>
<li><a class="el" href="index.html#broadcasting-messages">Broadcasting messages</a></li>
<li><a class="el" href="index.html#subscriptions">Subscriptions</a></li>
</ul>
<p><a class="anchor" id="broadcasting-messages"></a> </p>
<h3><a class="anchor" id="autotoc_md39"></a>
Broadcasting messages</h3>
<p>It is simple to send messages to subscribers of a given channel:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// publish a message to the &quot;hello_channel&quot; subscribers.</span></div>
<div class="line">int status = <a class="code hl_function" href="redisx-sub_8c.html#a3ae6a78cececda6a1a495eebefbd57e9">redisxPublish</a>(redis, <span class="stringliteral">&quot;hello_channel&quot;</span>, <span class="stringliteral">&quot;Hello world!&quot;</span>, 0);</div>
<div class="ttc" id="aredisx-sub_8c_html_a3ae6a78cececda6a1a495eebefbd57e9"><div class="ttname"><a href="redisx-sub_8c.html#a3ae6a78cececda6a1a495eebefbd57e9">redisxPublish</a></div><div class="ttdeci">int redisxPublish(Redis *redis, const char *channel, const char *data, int length)</div><div class="ttdef"><b>Definition</b> redisx-sub.c:142</div></div>
</div><!-- fragment --><p>The last argument is an optional string length, if readily available, or if sending a byte sequence that is not null-terminated. If zero is used for the length, as in the example above, it will automatically determine the length of the 0-terminated string message using <code>strlen()</code>.</p>
<p>Alternatively, you may use the <code><a class="el" href="redisx-sub_8c.html#a89b6c2128548882616c081553ea2436c">redisxPublishAsync()</a></code> instead if you want to publish on a subscription client to which you have already have exclusive access (e.g. after an appropriate <code><a class="el" href="redisx-client_8c.html#aad864c08ef9365c264c30bbacb0b77b2">redisxLockConnected()</a></code> call).</p>
<p><a class="anchor" id="subscriptions"></a> </p>
<h3><a class="anchor" id="autotoc_md40"></a>
Subscriptions</h3>
<p>Subscriptions work conceptually similarly to pipelined requests. To process incoming messages you need to first specify one or more <code>RedisSubscriberCall</code> functions, which will process PUB/SUB notifications automatically, in the background, as soon as they are received. Each <code>RedisSubscriberCall</code> can pre-filter the channels for which it receives notifications, by defining a channel stem. This way, the given processor function won't even be invoked if a notification on a completely different channel arrives. Still, each <code>RedisSubscriberCall</code> implementation should further check the notifying channel name as appropriate to ensure that it is in fact qualified to deal with a given message.</p>
<p>Here is an example <code>RedisSubscriberCall</code> implementation to process messages:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> my_event_processor(<span class="keyword">const</span> <span class="keywordtype">char</span> *pattern, <span class="keyword">const</span> <span class="keywordtype">char</span> *channel, <span class="keyword">const</span> <span class="keywordtype">char</span> *msg, <span class="keywordtype">long</span> len) {</div>
<div class="line">  <span class="comment">// We&#39;ll print the message onto the console</span></div>
<div class="line">  printf(<span class="stringliteral">&quot;Incoming message on channel %s: %s\n&quot;</span>, channel, msg == NULL ? <span class="stringliteral">&quot;&lt;null&gt;&quot;</span> : msg);</div>
<div class="line">}</div>
</div><!-- fragment --><p>There are some basic rules (best practices) for message processing. They should be fast, and never block for extended periods. If extensive processing is required, or may need to wait extensively for some resource or mutex locking, then its best that the processing function simply places the incoming message onto a queue, and let a separate background thread do the heavy lifting without holding up the subscription processing of other callback routines, or without losing responsiveness to other incoming messages.</p>
<p>Also, it is important that the call should never attempt to modify or call <code>free()</code> on the supplied string arguments, since that would interfere with other subscriber calls.</p>
<p>Once the function is defined, you can activate it via:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line">int status = <a class="code hl_function" href="redisx-sub_8c.html#a4c268c33f23438af67117b09c26ec615">redisxAddSubscriber</a>(redis, <span class="stringliteral">&quot;event:&quot;</span>, my_event_processor);</div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Oops, something went wrong...</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="aredisx-sub_8c_html_a4c268c33f23438af67117b09c26ec615"><div class="ttname"><a href="redisx-sub_8c.html#a4c268c33f23438af67117b09c26ec615">redisxAddSubscriber</a></div><div class="ttdeci">int redisxAddSubscriber(Redis *redis, const char *channelStem, RedisSubscriberCall f)</div><div class="ttdef"><b>Definition</b> redisx-sub.c:208</div></div>
</div><!-- fragment --><p>We should also start subscribing to specific channels and/or channel patterns.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// We subscribe to all channels that beging with &quot;event:&quot;...</span></div>
<div class="line">int status = <a class="code hl_function" href="redisx-sub_8c.html#a0aa27b4fce0d0986cae75dfe7fa12f19">redisxSubscribe</a>(redis, <span class="stringliteral">&quot;event:*&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Oops, something went wrong...</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="aredisx-sub_8c_html_a0aa27b4fce0d0986cae75dfe7fa12f19"><div class="ttname"><a href="redisx-sub_8c.html#a0aa27b4fce0d0986cae75dfe7fa12f19">redisxSubscribe</a></div><div class="ttdeci">int redisxSubscribe(Redis *redis, const char *pattern)</div><div class="ttdef"><b>Definition</b> redisx-sub.c:353</div></div>
</div><!-- fragment --><p>The <code><a class="el" href="redisx-sub_8c.html#a0aa27b4fce0d0986cae75dfe7fa12f19">redisxSubscribe()</a></code> function will translate to either a <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> <code>PSUBSCRIBE</code> or <code>SUBSCRIBE</code> command, depending on whether the <code>pattern</code> argument contains globbing patterns or not (respectively).</p>
<p>Now, we are capturing and processing all messages published to channels whose name begins with <code>"event:"</code>, using our custom <code>my_event_processor</code> function.</p>
<p>To end the subscription, we trace back the same steps by calling <code><a class="el" href="redisx-sub_8c.html#accafa9bf1ced851cc2e95c2d9fa1e9f8">redisxUnsubscribe()</a></code> to stop receiving further messages to the subscription channel or pattern, and by removing the <code>my_event_procesor</code> subscriber function as appropriate (provided no other subscription needs it) via <code>redisxRemoveSubscriber()</code>.</p>
<hr  />
<p><a class="anchor" id="atomic-transaction-blocks-and-lua-scripts"></a> </p>
<h2><a class="anchor" id="autotoc_md42"></a>
Atomic execution blocks and LUA scripts</h2>
<ul>
<li><a class="el" href="index.html#execution-blocks">Execution blocks</a></li>
<li><a class="el" href="index.html#lua-script-loading-and-execution">LUA script loading and execution</a></li>
<li><a class="el" href="index.html#custom-functions">Custom Redis functions</a></li>
</ul>
<p>Sometimes you may want to execute a series of <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> command atomically, such that nothing else may alter the database while the set of commands execute, so that related values are always in a coherent state. For example, you want to set or query a collection of related variables so they change together and are reported together. You have two choices. (1) you can execute the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> commands in an execution block, or else (2) load a LUA script onto the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server and call it with some parameters (possibly many times over).</p>
<p><a class="anchor" id="execution-blocks"></a> </p>
<h3><a class="anchor" id="autotoc_md43"></a>
Execution blocks</h3>
<p>Execution blocks offer a fairly simple way of bunching together a set of <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> commands that need to be executed atomically. Such an execution block in <b>RedisX</b> may look something like:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...;</div>
<div class="line"><a class="code hl_struct" href="structRESP.html">RESP</a> *result;</div>
<div class="line"><span class="keywordtype">int</span> status;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Obtain a lock on the client on which to execute the block.</span></div>
<div class="line"><span class="comment">// e.g. the interactive client channel.</span></div>
<div class="line"><a class="code hl_struct" href="structRedisClient.html">RedisClient</a> *cl = <a class="code hl_function" href="redisx-client_8c.html#a19d2fb18f2f939edfdc412d064741f9f">redisxGetLockedConnectedClient</a>(redis, <a class="code hl_enumvalue" href="redisx_8h.html#a5349b7340813fbd1e32d04ed650bc3d9a65b4f2926885665960480d008ab2a456">REDISX_INTERACTIVE_CHANNEL</a>);</div>
<div class="line"><span class="keywordflow">if</span> (cl == NULL) {</div>
<div class="line">  <span class="comment">// Abort: we don&#39;t have exclusive access to the client</span></div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// -------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Start an atomic execution block</span></div>
<div class="line"><a class="code hl_function" href="redisx-client_8c.html#a3e49508e4e4fcc283832226fd1bffd85">redisxStartBlockAsync</a>(cl);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send a number of Async requests</span></div>
<div class="line">status = <a class="code hl_function" href="redisx-client_8c.html#afc7b28288c07baf0b3c8fdc9d8ddf263">redisxSendRequestAsync</a>(cl, ...);</div>
<div class="line"><span class="keywordflow">if</span>(status &lt; 0) {</div>
<div class="line">  <span class="comment">// Oops, something went wrong, we should abort and return</span></div>
<div class="line">  <a class="code hl_function" href="redisx-client_8c.html#ab98b0e71d2d0941920e3097a66eae7b8">redisxAbortBlockAsync</a>(cl);</div>
<div class="line">  <span class="keywordflow">return</span> status;</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Execute the block of commands above atomically, and get the resulting RESP</span></div>
<div class="line">result = <a class="code hl_function" href="redisx-client_8c.html#a766ad80d9b84f4ca16be3da08e1968c9">redisxExecBlockAsync</a>(cl, &amp;status);</div>
<div class="line"><span class="comment">// -------------------------------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Release exlusive access to the client</span></div>
<div class="line"><a class="code hl_function" href="redisx-client_8c.html#a87efe53c80fcff3fcf189362cbc602f7">redisxUnlockClient</a>(cl);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Oops, the block execition failed...</span></div>
<div class="line">  <span class="keywordflow">return</span> status;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Inspect the RESP, etc...</span></div>
<div class="line">... </div>
<div class="ttc" id="aredisx-client_8c_html_a19d2fb18f2f939edfdc412d064741f9f"><div class="ttname"><a href="redisx-client_8c.html#a19d2fb18f2f939edfdc412d064741f9f">redisxGetLockedConnectedClient</a></div><div class="ttdeci">RedisClient * redisxGetLockedConnectedClient(Redis *redis, enum redisx_channel channel)</div><div class="ttdef"><b>Definition</b> redisx-client.c:346</div></div>
<div class="ttc" id="aredisx-client_8c_html_a3e49508e4e4fcc283832226fd1bffd85"><div class="ttname"><a href="redisx-client_8c.html#a3e49508e4e4fcc283832226fd1bffd85">redisxStartBlockAsync</a></div><div class="ttdeci">int redisxStartBlockAsync(RedisClient *cl)</div><div class="ttdef"><b>Definition</b> redisx-client.c:488</div></div>
<div class="ttc" id="aredisx-client_8c_html_a766ad80d9b84f4ca16be3da08e1968c9"><div class="ttname"><a href="redisx-client_8c.html#a766ad80d9b84f4ca16be3da08e1968c9">redisxExecBlockAsync</a></div><div class="ttdeci">RESP * redisxExecBlockAsync(RedisClient *cl, int *pStatus)</div><div class="ttdef"><b>Definition</b> redisx-client.c:542</div></div>
<div class="ttc" id="aredisx-client_8c_html_a87efe53c80fcff3fcf189362cbc602f7"><div class="ttname"><a href="redisx-client_8c.html#a87efe53c80fcff3fcf189362cbc602f7">redisxUnlockClient</a></div><div class="ttdeci">int redisxUnlockClient(RedisClient *cl)</div><div class="ttdef"><b>Definition</b> redisx-client.c:425</div></div>
<div class="ttc" id="aredisx-client_8c_html_ab98b0e71d2d0941920e3097a66eae7b8"><div class="ttname"><a href="redisx-client_8c.html#ab98b0e71d2d0941920e3097a66eae7b8">redisxAbortBlockAsync</a></div><div class="ttdeci">int redisxAbortBlockAsync(RedisClient *cl)</div><div class="ttdef"><b>Definition</b> redisx-client.c:513</div></div>
<div class="ttc" id="aredisx-client_8c_html_afc7b28288c07baf0b3c8fdc9d8ddf263"><div class="ttname"><a href="redisx-client_8c.html#afc7b28288c07baf0b3c8fdc9d8ddf263">redisxSendRequestAsync</a></div><div class="ttdeci">int redisxSendRequestAsync(RedisClient *cl, const char *command, const char *arg1, const char *arg2, const char *arg3)</div><div class="ttdef"><b>Definition</b> redisx-client.c:596</div></div>
<div class="ttc" id="aredisx_8h_html_a5349b7340813fbd1e32d04ed650bc3d9a65b4f2926885665960480d008ab2a456"><div class="ttname"><a href="redisx_8h.html#a5349b7340813fbd1e32d04ed650bc3d9a65b4f2926885665960480d008ab2a456">REDISX_INTERACTIVE_CHANNEL</a></div><div class="ttdeci">@ REDISX_INTERACTIVE_CHANNEL</div><div class="ttdoc">Redis channel number for interactive queries.</div><div class="ttdef"><b>Definition</b> redisx.h:139</div></div>
<div class="ttc" id="astructRedisClient_html"><div class="ttname"><a href="structRedisClient.html">RedisClient</a></div><div class="ttdoc">Structure that represents a single Redis client connection instance.</div><div class="ttdef"><b>Definition</b> redisx.h:217</div></div>
</div><!-- fragment --><p>If at any point things don't go according to plan in the middle of the block, you can call <code>redisAbortBlockAsync()</code> to abort and discard all prior commands submitted in the execution block already. It is important to remember that every time you call <code><a class="el" href="redisx-client_8c.html#a3e49508e4e4fcc283832226fd1bffd85">redisxStartBlockAsync()</a></code>, you must call either <code><a class="el" href="redisx-client_8c.html#a766ad80d9b84f4ca16be3da08e1968c9">redisxExecBlockAsync()</a></code> to execute it or else <code><a class="el" href="redisx-client_8c.html#ab98b0e71d2d0941920e3097a66eae7b8">redisxAbortBlockAsync()</a></code> to discard it. Failure to do so, will effectively end you up with a hung <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> client.</p>
<p><a class="anchor" id="lua-script-loading-and-execution"></a> </p>
<h3><a class="anchor" id="autotoc_md44"></a>
LUA script loading and execution</h3>
<p><a href="https://www.lua.org/">LUA</a> scripting offers a more capable version of executing complex routines on the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server. LUA is a scripting language akin to python, and allows you to add extra logic, string manipulation etc. to your <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> queries. Best of all, once you upload the script to the server, it can reduce network traffic significantly by not having to repeatedly submit the same set of <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> commands every single time. LUA scripts also get executed very efficiently on the server, and produce only the result you want/need without returning unnecessary intermediates.</p>
<p>Assuming you have prepared your LUA script appropriately, you can upload it to the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server as:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line">char *script = ...         <span class="comment">// The LUA script as a 0-terminated string.</span></div>
<div class="line"><span class="keywordtype">char</span> *scriptSHA1 = NULL;   <span class="comment">// We&#39;ll store the SHA1 sum of the script here</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Load the script onto the Redis server</span></div>
<div class="line"><span class="keywordtype">int</span> status = redixLoadScript(redis, script, &amp;scriptSHA1);</div>
<div class="line"><span class="keywordflow">if</span>(status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Oops, something went wrong...</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> will refer to the script by its SHA1 sum, so it's important keep a record of it. You'll call the script with its SHA1 sum, a set of <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> keys the script may use, and a set of other parameters it might need.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line">char *keyArgs[] = { <span class="stringliteral">&quot;my-redis-key-argument&quot;</span>, NULL }; <span class="comment">// NULL-terminated array of keyword arguments</span></div>
<div class="line"><span class="keywordtype">char</span> *params[] = { <span class="stringliteral">&quot;some-string&quot;</span>, <span class="stringliteral">&quot;-1.11&quot;</span>, NULL };   <span class="comment">// NULL-terminated array of extra parameters</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> status;     <span class="comment">// We will return error status in this variable</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Execute the script, with the specified keyword arguments and parameters</span></div>
<div class="line"><a class="code hl_struct" href="structRESP.html">RESP</a> *reply = <a class="code hl_function" href="redisx-script_8c.html#aebd84c84082d2367d8cbe233cfe14535">redisxRunScript</a>(redis, scriptSHA1, keyArgs, params, &amp;status);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check and inspect the reply</span></div>
<div class="line">...</div>
<div class="ttc" id="aredisx-script_8c_html_aebd84c84082d2367d8cbe233cfe14535"><div class="ttname"><a href="redisx-script_8c.html#aebd84c84082d2367d8cbe233cfe14535">redisxRunScript</a></div><div class="ttdeci">RESP * redisxRunScript(Redis *redis, const char *sha1, const char **keys, const char **params, int *status)</div><div class="ttdef"><b>Definition</b> redisx-script.c:122</div></div>
</div><!-- fragment --><p>Or, you can use <code><a class="el" href="redisx-script_8c.html#a711d6ba68a67ab814ddda0adc998a2ce">redisxRunScriptAsync()</a></code> instead to send the request to run the script, and then collect the response later, as appropriate.</p>
<p>One thing to keep in mind about LUA scripts is that they are not fully persistent. They will be lost each time the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server is restarted.</p>
<p><a class="anchor" id="custom-functions"></a> </p>
<h3><a class="anchor" id="autotoc_md45"></a>
Custom Redis functions</h3>
<p>Functions, introduced in <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> 7, offer another evolutionary step over the LUA scripting described above. Unlike scripts, functions are persistent and they can be called by name rather than a cryptic SHA1 sum. Otherwise, they offer more or less the same functionality as scripts. <b>RedisX</b> does not currently have a built-in high-level support for managing and calling user-defined functions, but it is a feature that may be added in the not-too-distant future. Stay tuned.</p>
<hr  />
<p><a class="anchor" id="advanced-queries"></a> </p>
<h2><a class="anchor" id="autotoc_md47"></a>
Advanced queries and pipelining</h2>
<ul>
<li><a class="el" href="index.html#asynchronous-client-processing">Asynchronous client processing</a></li>
<li><a class="el" href="index.html#async-attributes">Bundled Attributes</a></li>
<li><a class="el" href="index.html#pipelined-transactions">Pipelined transactions</a></li>
</ul>
<p><a class="anchor" id="asynchronous-client-processing"></a> </p>
<h3><a class="anchor" id="autotoc_md48"></a>
Asynchronous client processing</h3>
<p>Sometimes you might want to micro manage how requests are sent and responses to them are received. <b>RedisX</b> provides a set of asynchronous client functions that do that. (You've seen these already further above in the <a class="el" href="index.html#pipelined-transactions">Pipelined transaction</a> section.) These functions should be called with the specific client's mutex locked, to ensure that other threads do not interfere with your sequence of requests and responses. E.g.:</p>
<div class="fragment"><div class="line"><span class="comment">// Obtain the appropriate client with an exclusive lock on it.</span></div>
<div class="line"><a class="code hl_struct" href="structRedisClient.html">RedisClient</a> *cl = <a class="code hl_function" href="redisx-client_8c.html#a19d2fb18f2f939edfdc412d064741f9f">redisxGetLockedConnectedClient</a>(...);</div>
<div class="line"><span class="keywordflow">if</span> (cl == NULL) {</div>
<div class="line">  <span class="comment">// Abort: no such client is connected</span></div>
<div class="line">  <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now send commands, and receive responses as you like using the redisx...Async() calls</span></div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// When done, release the lock</span></div>
<div class="line">redisxUnlockClient(cl);</div>
</div><!-- fragment --><p>While you have the exclusive lock you may send any number of requests, e.g. via <code><a class="el" href="redisx-client_8c.html#afc7b28288c07baf0b3c8fdc9d8ddf263">redisxSendRequestAsync()</a></code> and/or <code>redixSendArrayRequestAsync()</code>. Then collect replies either with <code><a class="el" href="redisx-client_8c.html#a06c5b62c7b92c83af8f080dd1bb91b17">redisxReadReplyAsync()</a></code> or else <code><a class="el" href="redisx-client_8c.html#ac0f30d62044638a2ead07583ad723fdf">redisxIgnoreReplyAsync()</a></code>. For example, the basic anatomy of sending a single request and then receiving a response, while we have exclusive access to the client, might look something like this:</p>
<div class="fragment"><div class="line">...</div>
<div class="line"><span class="comment">// Send a command to Redis</span></div>
<div class="line">int status = <a class="code hl_function" href="redisx-client_8c.html#afc7b28288c07baf0b3c8fdc9d8ddf263">redisxSendRequestAsync</a>(cl, ...);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(status == X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Read the response</span></div>
<div class="line">  <a class="code hl_struct" href="structRESP.html">RESP</a> *reply = <a class="code hl_function" href="redisx-client_8c.html#a06c5b62c7b92c83af8f080dd1bb91b17">redisxReadReplyAsync</a>(cl, &amp;status);</div>
<div class="line">  <span class="keywordflow">if</span>(status != X_SUCCESS) {</div>
<div class="line">    <span class="comment">// Ooops, not the reply what we expected...</span></div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// check and process the response</span></div>
<div class="line">  <span class="keywordflow">if</span>(<a class="code hl_function" href="resp_8c.html#a4b5674d08da07250c0ca6116a4c48ccf">redisxCheckRESP</a>(reply, ...) != X_SUCCESS) {</div>
<div class="line">    <span class="comment">// Ooops, not the reply what we expected...</span></div>
<div class="line">    ...</div>
<div class="line">  } </div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Process the response</span></div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Destroy the reply</span></div>
<div class="line">  <a class="code hl_function" href="resp_8c.html#aa4e23a7454f7055711915ec430599011">redisxDestroyRESP</a>(reply);</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="ttc" id="aredisx-client_8c_html_a06c5b62c7b92c83af8f080dd1bb91b17"><div class="ttname"><a href="redisx-client_8c.html#a06c5b62c7b92c83af8f080dd1bb91b17">redisxReadReplyAsync</a></div><div class="ttdeci">RESP * redisxReadReplyAsync(RedisClient *cl, int *pStatus)</div><div class="ttdef"><b>Definition</b> redisx-client.c:854</div></div>
<div class="ttc" id="aresp_8c_html_a4b5674d08da07250c0ca6116a4c48ccf"><div class="ttname"><a href="resp_8c.html#a4b5674d08da07250c0ca6116a4c48ccf">redisxCheckRESP</a></div><div class="ttdeci">int redisxCheckRESP(const RESP *resp, enum resp_type expectedType, int expectedSize)</div><div class="ttdef"><b>Definition</b> resp.c:160</div></div>
</div><!-- fragment --><p>For the best performance, you may want to leave the processing of the replies until after you unlock the client. I.e., you only block other threads from accessing the client while you send off the requests and collect the corresponding responses. You can then analyze the responses at your leisure outside of the mutexed section.</p>
<p>In some cases you may be OK with just firing off some <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> commands, without necessarily caring about responses. Rather than ignoring the replies with <code><a class="el" href="redisx-client_8c.html#ac0f30d62044638a2ead07583ad723fdf">redisxIgnoreReplyAsync()</a></code> you might call <code><a class="el" href="redisx-client_8c.html#a44c5d0bd24f5a4f2f131218f14c9c599">redisxSkipReplyAsync()</a></code> instead <b>before</b> <code><a class="el" href="redisx-client_8c.html#afc7b28288c07baf0b3c8fdc9d8ddf263">redisxSendRequestAsync()</a></code> to instruct <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> to not even bother about sending a response to your request (it saves time and network bandwidth!):</p>
<div class="fragment"><div class="line"><span class="comment">// We don&#39;t want to receive a response to our next command... </span></div>
<div class="line"><span class="keywordtype">int</span> status = <a class="code hl_function" href="redisx-client_8c.html#a44c5d0bd24f5a4f2f131218f14c9c599">redisxSkipReplyAsync</a>(cl);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (status == X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Now send the request...</span></div>
<div class="line">  status = redisxSendRequest(cl, ...);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">   <span class="comment">// Ooops, the request did not go through...</span></div>
<div class="line">   ...</div>
<div class="line">}</div>
<div class="ttc" id="aredisx-client_8c_html_a44c5d0bd24f5a4f2f131218f14c9c599"><div class="ttname"><a href="redisx-client_8c.html#a44c5d0bd24f5a4f2f131218f14c9c599">redisxSkipReplyAsync</a></div><div class="ttdeci">int redisxSkipReplyAsync(RedisClient *cl)</div><div class="ttdef"><b>Definition</b> redisx-client.c:454</div></div>
</div><!-- fragment --><p>Of course you can build up arbitrarily complex set of queries and deal with a set of responses in different ways. Do what works best for your application.</p>
<p><a class="anchor" id="async-attributes"></a> </p>
<h3><a class="anchor" id="autotoc_md49"></a>
Bundled Attributes</h3>
<p>As of <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> 6, the server might send ancillary data along with replies, if the RESP3 protocol is used. These are collected together with the expected responses. However, these optional attributes are not returned to the user automatically. Instead, the user may retrieve attributes directly after getting a response from <code><a class="el" href="redisx-client_8c.html#a06c5b62c7b92c83af8f080dd1bb91b17">redisxReadReplyAsync()</a></code> using <code><a class="el" href="redisx-client_8c.html#a6c9d4ce9babbcaac35e45f536d47858d">redisxGetAttributesAsync()</a></code>. And, attributes that were received previously can be discarded with <code><a class="el" href="redisx-client_8c.html#a576bb47774aaf4d5d735a5ef18253048">redisxClearAttributesAsync()</a></code>. For example,</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedisClient.html">RedisClient</a> *cl = ...  <span class="comment">// The client we use for our transactions</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>(redisxLockEnabled(cl) == X_SUCCESS) {</div>
<div class="line">  ...</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Clear any prior attributes we may have previously received for the client...</span></div>
<div class="line">  <a class="code hl_function" href="redisx-client_8c.html#a576bb47774aaf4d5d735a5ef18253048">redisxClearAttributesAsync</a>(cl);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Read a response for a request we sent earlier...</span></div>
<div class="line">  <a class="code hl_struct" href="structRESP.html">RESP</a> *reply = <a class="code hl_function" href="redisx-client_8c.html#a06c5b62c7b92c83af8f080dd1bb91b17">redisxReadReplyAsync</a>(cl);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Retrieve the attributes (if any) that were sent with the response.</span></div>
<div class="line">  <a class="code hl_struct" href="structRESP.html">RESP</a> *attributes = <a class="code hl_function" href="redisx_8c.html#a48b6b8949276f59cd2f13d6b13384996">redisxGetAttributes</a>(cl);</div>
<div class="line">  </div>
<div class="line">  ...</div>
<div class="line">  </div>
<div class="line">  <a class="code hl_function" href="redisx-client_8c.html#a87efe53c80fcff3fcf189362cbc602f7">redisxUnlockClient</a>(cl);</div>
<div class="line">}</div>
<div class="ttc" id="aredisx-client_8c_html_a576bb47774aaf4d5d735a5ef18253048"><div class="ttname"><a href="redisx-client_8c.html#a576bb47774aaf4d5d735a5ef18253048">redisxClearAttributesAsync</a></div><div class="ttdeci">int redisxClearAttributesAsync(RedisClient *cl)</div><div class="ttdef"><b>Definition</b> redisx-client.c:836</div></div>
</div><!-- fragment --><p><a class="anchor" id="pipelined-transactions"></a> </p>
<h3><a class="anchor" id="autotoc_md50"></a>
Pipelined transactions</h3>
<p>Depending on round-trip times over the network, interactive queries may be suitable for running up to a few thousand queries per second. For higher throughput (up to ~1 million <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> transactions per second) you may need to access the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> database in pipelined mode. RedisX provides a dedicated pipeline client/channel to the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server (provided the option to enable it has been used when <code>redixConnect()</code> was called).</p>
<p>In pipeline mode, requests are sent to the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server over the pipeline client in quick succession, without waiting for responses to return for each one individually. Responses are processed in the background by a designated callback function (or else discarded if no callback function has been set). This is what a callback function looks like:</p>
<div class="fragment"><div class="line"><span class="comment">// Your own function to process responses to pipelined requests...</span></div>
<div class="line"><span class="keywordtype">void</span> my_resp_processor(<a class="code hl_struct" href="structRESP.html">RESP</a> *r) {</div>
<div class="line">  <span class="comment">// Do what you need to do with the asynchronous responses</span></div>
<div class="line">  <span class="comment">// that come from Redis to bulk requests.</span></div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>It is important to note that the processing function should not call <code>free</code> on the <code><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a></code> pointer argument, but it may dereference and use parts of it as appropriate (just remember to set the bits referenced elsewhere to <code>NULL</code> so they do not get destroyed when the pipeline listener destroys the <code><a class="el" href="structRESP.html" title="Structure that represents a Redis response (RESP format).">RESP</a></code> after your function is done processing it). Before sending the pipelined requests, the user first needs to specify the function to process the responses, e.g.:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line">redisxSetPipelineConsumer(redis, my_resp_processor);</div>
</div><!-- fragment --><p>Request are sent via the <code><a class="el" href="redisx-client_8c.html#afc7b28288c07baf0b3c8fdc9d8ddf263">redisxSendRequestAsync()</a></code> and <code><a class="el" href="redisx-client_8c.html#a17de2c4323d3da4b3a3d386d85c12d8e">redisxSendArrayRequestAsync()</a></code> functions. Note again, the <code>Async</code> naming, which indicates the asynchronous nature of this calls &ndash; and which indicates that these functions should be called with the appropriate mutex locked to prevent concurrency issues, and to maintain a predictable order (very important!) for processing the responses.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// We&#39;ll use a dedicated pipeline connection for asynchronous requests</span></div>
<div class="line"><span class="comment">// This way, interactive requests can still be sent independently on the interactive</span></div>
<div class="line"><span class="comment">// channel independently, if need be.</span></div>
<div class="line">RedisClient *pipe = <a class="code hl_function" href="redisx-client_8c.html#a19d2fb18f2f939edfdc412d064741f9f">redisxGetLockedConnectedClient</a>(redis, <a class="code hl_enumvalue" href="redisx_8h.html#a5349b7340813fbd1e32d04ed650bc3d9a7a240839c1e943706535b8d69a605f0c">REDISX_PIPELINE_CHANNEL</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check that the client is valid...</span></div>
<div class="line"><span class="keywordflow">if</span> (pipe == NULL) {</div>
<div class="line">   <span class="comment">// Abort: we do not appear to have an active pipeline connection...</span></div>
<div class="line">   <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// -------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Submit a whole bunch of asynchronous requests, e.g. from a loop...</span></div>
<div class="line"><span class="keywordflow">for</span> (...) {</div>
<div class="line">  <span class="keywordtype">int</span> status = <a class="code hl_function" href="redisx-client_8c.html#afc7b28288c07baf0b3c8fdc9d8ddf263">redisxSendRequestAsync</a>(pipe, ...);</div>
<div class="line">  <span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">    <span class="comment">// Oops, that did not go through...</span></div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// We probably want to keep a record of what was requested and in what order</span></div>
<div class="line">    <span class="comment">// so our processing function can make sense of the reponses as they arrive</span></div>
<div class="line">    <span class="comment">// (in the same order...)</span></div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="comment">// -------------------------------------------------------------------------</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Release the exclusive lock on the pipeline channel, so</span></div>
<div class="line"><span class="comment">// other threads may use it now that we sent off our requests...</span></div>
<div class="line"><a class="code hl_function" href="redisx-client_8c.html#a87efe53c80fcff3fcf189362cbc602f7">redisxUnlockClient</a>(pipe);</div>
<div class="ttc" id="aredisx_8h_html_a5349b7340813fbd1e32d04ed650bc3d9a7a240839c1e943706535b8d69a605f0c"><div class="ttname"><a href="redisx_8h.html#a5349b7340813fbd1e32d04ed650bc3d9a7a240839c1e943706535b8d69a605f0c">REDISX_PIPELINE_CHANNEL</a></div><div class="ttdeci">@ REDISX_PIPELINE_CHANNEL</div><div class="ttdoc">Redis channel number for pipelined transfers.</div><div class="ttdef"><b>Definition</b> redisx.h:140</div></div>
</div><!-- fragment --><p>It is important to remember that on the pipeline client you should never try to process responses directly from the same function from which commands are being sent. That's what the interactive connection is for. Pipeline responses are always processed by a background thread (or, if you don't specify your callback function they will be discarded). The only thing your callback function can count on is that the same number of responses will be received as the number of asynchronous requests that were sent out, and that the responses arrive in the same order as the order in which the requests were sent.</p>
<p>It is up to you and your callback function to keep track of what responses are expected and in what order. Some best practices to help deal with pipeline responses are summarized here:</p>
<ul>
<li>Use <code><a class="el" href="redisx-client_8c.html#a44c5d0bd24f5a4f2f131218f14c9c599">redisxSkipReplyAsync()</a></code> prior to sending pipeline requests for which you do not need a response. (This way your callback does not have to deal with unnecessary responses at all.</li>
<li>For requests that return a value, keep a record (in a FIFO) of the expected types and your data that depends on the content of the responses. For example, for pipelined <code>HGET</code> commands, your FIFO should have a record that specifies that a bulk string response is expected, and a pointer to data which is used to store the returned value &ndash; so that you pipeline response processing callback function can check that the response is the expected type (and size) and knows to assign/process the response appropriately to your application data.</li>
<li>You may insert <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> <code>PING</code>/<code>ECHO</code> commands to section your responses, or to provide directives to your pipeline response processor function. You can tag them uniquely so that the echoed responses can be parsed and interpreted by your callback function. For example, you may send a <code>PING</code>/<code>ECHO</code> commands to <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> with the tag <code>"@my_resp_processor: START sequence A"</code>, or something else meaningful that you can uniquely distinguish from all other responses that you might receive.</li>
</ul>
<p><b>RedisX</b> optimizes the pipeline client for high throughput (bandwidth), whereas the interactive and subscription clients are optimized for low-latency, at the socket level.</p>
<hr  />
<p><a class="anchor" id="error-handling"></a> </p>
<h2><a class="anchor" id="autotoc_md52"></a>
Error handling</h2>
<p>The principal error handling of <b>RedisX</b> is an extension of that of <b>xchange</b>, with further error codes defined in <code><a class="el" href="redisx_8h.html">redisx.h</a></code>. The <b>RedisX</b> functions that return an error status (either directly, or into the integer designated by a pointer argument), can be inspected by <code><a class="el" href="redisx_8c.html#a38f3de77ad5a48d37b302bce2e3cd25b">redisxErrorDescription()</a></code>, e.g.:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis ...</div>
<div class="line">int status = <a class="code hl_function" href="redisx-tab_8c.html#a1465b1a965ddd685e16bccbf0b34f08b">redisxSetValue</a>(...);</div>
<div class="line"><span class="keywordflow">if</span> (status != X_SUCCESS) {</div>
<div class="line">  <span class="comment">// Ooops, something went wrong...</span></div>
<div class="line">  fprintf(stderr, <span class="stringliteral">&quot;WARNING! set value: %s&quot;</span>, redisErrorDescription(status));</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>In addition you can define your own handler function to deal with transmission (send/receive) errors, by defining your own <code>RedisErrorHandler</code> function, such as:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> my_error_handler(<a class="code hl_struct" href="structRedis.html">Redis</a> *redis, <span class="keyword">enum</span> <a class="code hl_enumeration" href="redisx_8h.html#a5349b7340813fbd1e32d04ed650bc3d9">redisx_channel</a> channel, <span class="keyword">const</span> <span class="keywordtype">char</span> *op) {</div>
<div class="line">  fprintf(stderr, <span class="stringliteral">&quot;ERROR! %s: Redis at %s, channel %d\n&quot;</span>, op, redis-&gt;<a class="code hl_variable" href="structRedis.html#aecb3b0d045ada529257a2fbf8f829599">id</a>, channel);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Then activate it as:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structRedis.html">Redis</a> *redis = ...</div>
<div class="line"> </div>
<div class="line">redisxSetSocketErrorHandler(redis, my_error_handler);</div>
</div><!-- fragment --><p>After that, every time there is an error with sending or receiving packets over the network to any of the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> clients used, your handler will report it the way you want it.</p>
<h3><a class="anchor" id="autotoc_md53"></a>
Socket-level errors</h3>
<p>There are multiple ways the user may get informed when errors happen at the socket read / write level:</p>
<ul>
<li><b>RedisX</b> will propagate and report errors from failed socket reads and writes, both via return values to its functions (via <code>X_NO_SERVICE</code> error code or <code>NULL</code> returns, plus <code>errno</code>), and</li>
<li><b>RedisX</b> will call the configured socket error handler callback function (see above) as soon as the error is encountered.</li>
<li><b>RedisX</b> will call all disconnect hooks configured if the client disconnects (either as intended or unexpectedly as a result of a persistent socket-level error).</li>
</ul>
<p>It is up to you to decide which of the following method(s) you wish to rely on to detect broken connections and act as appropriate. To help with your decisions, below is a step-by-step outline of how <b>RedisX</b> handles errors originating from the socket level of clients, indicating also the points at which users are notified by each of the above mentioned methods.</p>
<ol type="1">
<li>The socket error handler (if configured) callback is immediately after a read or write error is detected on a client's socket. The error handler callback function is called while the affected client is still locked and nominally in a 'functioning' state. That means you are free to use any <code>Async</code> call on the affected client as appropriate, but the error handler should not attempt to release the exclusive lock on the client or call synchronized functions. The background processing of replies (on the pipeline and/or subscription clients) is still active at this stage.</li>
<li>If the error is caused by a timeout (<code>errno</code> being <code>EAGAIN</code> or <code>EWOULDBLOCK</code>), nothing changes at this stage. However, if the error is persistent, the client will be disabled and reset, and subsequent read or write calls will fail immediately. Any disconnection hooks will be called also as the client is disconnected. The background processing of server replies (on the pipeline and subscriptions channels) will stop soon after the disconnection is initiated.</li>
<li>The <b>RedisX</b> call return either <code>X_NO_SERVICE</code>, or <code>X_TIMEDOUT</code>, or else <code>NULL</code>. The application should check return values (and <code>errno</code>) as appropriate.</li>
</ol>
<hr  />
<p><a class="anchor" id="debug-support"></a> </p>
<h2><a class="anchor" id="autotoc_md55"></a>
Debug support</h2>
<p>You can enable verbose output of the <b>RedisX</b> library with <code><a class="elRef" href="../../xchange/apidoc/html/xchange_8h.html#afbe85067ddbc92577cd00ac8f6e3026f">xSetVerbose(boolean)</a></code>. When enabled, it will produce status messages to <code>stderr</code>so you can follow what's going on. In addition (or alternatively), you can enable debug messages with <code><a class="elRef" href="../../xchange/apidoc/html/xchange_8h.html#a6c1304b59a5882b2286e86c6837faead">xSetDebug(boolean)</a></code>. When enabled, all errors encountered by the library (such as invalid arguments passed) will be printed to <code>stderr</code>, including call traces, so you can walk back to see where the error may have originated from. (You can also enable debug messages by default by defining the <code>DEBUG</code> constant for the compiler, e.g. by adding <code>-DDEBUG</code> to <code>CFLAGS</code> prior to calling <code>make</code>).</p>
<p>In addition, you can use <code><a class="el" href="redisx_8c.html#a7cde25fca6ae274d8d0a66d5c8b63ff5">redisxDebugTraffic(boolean)</a></code> to debug low-level traffic to/from the <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> server, which prints excerpts of all incoming and outgoing messages from/to <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> to <code>stderr</code>.</p>
<p>For helping to debug your application, the <b>xchange</b> library provides two macros: <code><a class="elRef" href="../../xchange/apidoc/html/xchange_8h.html#a1f038bf7ddb58819805cfc44162cb403">xvprintf()</a></code> and <code><a class="elRef" href="../../xchange/apidoc/html/xchange_8h.html#a2b0edfea798e9e08122f09dba5f189f8">xdprintf()</a></code>, for printing verbose and debug messages to <code>stderr</code>. Both work just like <code>printf()</code>, but they are conditional on verbosity being enabled via <code><a class="elRef" href="../../xchange/apidoc/html/xchange_8h.html#afbe85067ddbc92577cd00ac8f6e3026f">xSetVerbose(boolean)</a></code> and <code><a class="elRef" href="../../xchange/apidoc/html/xchange_8h.html#a6c1304b59a5882b2286e86c6837faead">xSetDebug(boolean)</a></code>, respectively. Applications using <b>RedisX</b> may use these macros to produce their own verbose and/or debugging outputs conditional on the same global settings.</p>
<hr  />
<p><a class="anchor" id="future-plans"></a> </p>
<h2><a class="anchor" id="autotoc_md57"></a>
Future plans</h2>
<p>Some obvious ways the library could evolve and grow in the not too distant future:</p>
<ul>
<li>Automated regression testing and coverage tracking.</li>
<li>Keep track of subscription patterns, and automatically resubscribe to them on reconnecting.</li>
<li>TLS support.</li>
<li><a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> cluster support.</li>
<li>Add high-level support for managing and calling custom <a class="el" href="structRedis.html" title="Structure that represents a Redis database instance, with one or more RedisClient connections.">Redis</a> functions.</li>
<li>Add more high-level <a href="https://redis.io/docs/latest/commands/">Redis commands</a>, e.g. for lists, streams, etc.</li>
</ul>
<p>If you have an idea for a must have feature, please let me (Attila) know. Pull requests, for new features or fixes to existing ones, are especially welcome!</p>
<hr  />
<p> Copyright (C) 2024 Attila Kov√°cs </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
